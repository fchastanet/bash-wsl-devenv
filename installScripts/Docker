#!/usr/bin/env bash
###############################################################################
# GENERATED FACADE FROM https://github.com/fchastanet/bash-dev-env/tree/master/src/_binaries/installScripts/Docker.sh
# DO NOT EDIT IT
# @generated
###############################################################################
# shellcheck disable=SC2288,SC2034
# BIN_FILE=${BASH_DEV_ENV_ROOT_DIR}/installScripts/Docker

# ensure that no user aliases could interfere with
# commands used in this script
unalias -a || true
shopt -u expand_aliases

# shellcheck disable=SC2034
((failures = 0)) || true

# Bash will remember & return the highest exit code in a chain of pipes.
# This way you can catch the error inside pipes, e.g. mysqldump | gzip
set -o pipefail
set -o errexit

# Command Substitution can inherit errexit option since bash v4.4
shopt -s inherit_errexit || true

# if set, and job control is not active, the shell runs the last command
# of a pipeline not executed in the background in the current shell
# environment.
shopt -s lastpipe

# a log is generated when a command fails
set -o errtrace

# use nullglob so that (file*.php) will return an empty array if no file
# matches the wildcard
shopt -s nullglob

# ensure regexp are interpreted without accentuated characters
export LC_ALL=POSIX

export TERM=xterm-256color

# avoid interactive install
export DEBIAN_FRONTEND=noninteractive
export DEBCONF_NONINTERACTIVE_SEEN=true

# store command arguments for later usage
# shellcheck disable=SC2034
declare -a BASH_FRAMEWORK_ARGV=("$@")
# shellcheck disable=SC2034
declare -a ORIGINAL_BASH_FRAMEWORK_ARGV=("$@")

# @see https://unix.stackexchange.com/a/386856
# shellcheck disable=SC2317
interruptManagement() {
  # restore SIGINT handler
  trap - INT
  # ensure that Ctrl-C is trapped by this script and not by sub process
  # report to the parent that we have indeed been interrupted
  kill -s INT "$$"
}
trap interruptManagement INT
SCRIPT_NAME=${0##*/}
REAL_SCRIPT_FILE="$(readlink -e "$(realpath "${BASH_SOURCE[0]}")")"
if [[ -n "${EMBED_CURRENT_DIR}" ]]; then
  CURRENT_DIR="${EMBED_CURRENT_DIR}"
else
  CURRENT_DIR="$(cd "$(readlink -e "${REAL_SCRIPT_FILE%/*}")" && pwd -P)"
fi

################################################
# Temp dir management
################################################

KEEP_TEMP_FILES="${KEEP_TEMP_FILES:-0}"
export KEEP_TEMP_FILES

# PERSISTENT_TMPDIR is not deleted by traps
PERSISTENT_TMPDIR="${TMPDIR:-/tmp}/bash-framework"
export PERSISTENT_TMPDIR
mkdir -p "${PERSISTENT_TMPDIR}"

# shellcheck disable=SC2034
TMPDIR="$(mktemp -d -p "${PERSISTENT_TMPDIR:-/tmp}" -t bash-framework-$$-XXXXXX)"
export TMPDIR

# temp dir cleaning
# shellcheck disable=SC2317
cleanOnExit() {
  if [[ "${KEEP_TEMP_FILES:-0}" = "1" ]]; then
    Log::displayInfo "KEEP_TEMP_FILES=1 temp files kept here '${TMPDIR}'"
  elif [[ -n "${TMPDIR+xxx}" ]]; then
    Log::displayDebug "KEEP_TEMP_FILES=0 removing temp files '${TMPDIR}'"
    rm -Rf "${TMPDIR:-/tmp/fake}" >/dev/null 2>&1
  fi
}
trap cleanOnExit EXIT HUP QUIT ABRT TERM

# @description concat each element of an array with a separator
# but wrapping text when line length is more than provided argument
# The algorithm will try not to cut the array element if it can.
# - if an arg can be placed on current line it will be,
#   otherwise current line is printed and arg is added to the new
#   current line
# - Empty arg is interpreted as a new line.
# - Add \r to arg in order to force break line and avoid following
#   arg to be concatenated with current arg.
#
# @arg $1 glue:String
# @arg $2 maxLineLength:int
# @arg $3 indentNextLine:int
# @arg $@ array:String[]
Array::wrap2() {
  local glue="${1-}"
  local -i glueLength="${#glue}"
  shift || true
  local -i maxLineLength=$1
  shift || true
  local -i indentNextLine=$1
  shift || true
  local indentStr=""
  if ((indentNextLine > 0)); then
    indentStr="$(head -c "${indentNextLine}" </dev/zero | tr '\0' " ")"
  fi
  if (($# == 0)); then
    return 0
  fi

  printCurrentLine() {
    if ((isNewline == 0)) || ((previousLineEmpty == 1)); then
      echo
    fi
    ((isNewline = 1))
    echo -en "${indentStr}"
    ((currentLineLength = indentNextLine)) || true
  }
  appendToCurrentLine() {
    local text="$1"
    local -i length=$2
    ((currentLineLength += length)) || true
    ((isNewline = 0)) || true
    if [[ "${text: -1}" = $'\r' ]]; then
      text="${text:0:-1}"
      echo -en "${text%%+([[:blank:]])}"
      printCurrentLine
    else
      echo -en "${text%%+([[:blank:]])}"
    fi
  }

  (
    local currentLine
    local -i currentLineLength=0 isNewline=1 argLength=0
    local -a additionalLines
    local -i previousLineEmpty=0
    local arg=""

    while (($# > 0)); do
      arg="$1"
      shift || true

      # replace tab by 2 spaces
      arg="${arg//$'\t'/  }"
      # remove trailing spaces
      arg="${arg%[[:blank:]]}"
      if [[ "${arg}" = $'\n' || -z "${arg}" ]]; then
        printCurrentLine
        ((previousLineEmpty = 1))
        continue
      else
        if ((previousLineEmpty == 1)); then
          printCurrentLine
        fi
        ((previousLineEmpty = 0)) || true
      fi
      # convert eol to args
      mapfile -t additionalLines <<<"${arg}"
      if ((${#additionalLines[@]} > 1)); then
        set -- "${additionalLines[@]}" "$@"
        continue
      fi

      ((argLength = ${#arg})) || true

      # empty arg
      if ((argLength == 0)); then
        if ((isNewline == 0)); then
          # isNewline = 0 means currentLine is not empty
          printCurrentLine
        fi
        continue
      fi

      if ((isNewline == 0)); then
        glueLength="${#glue}"
      else
        glueLength="0"
      fi
      if ((currentLineLength + argLength + glueLength > maxLineLength)); then
        if ((argLength + glueLength > maxLineLength)); then
          # arg is too long to even fit on one line
          # we have to split the arg on current and next line
          local -i remainingLineLength
          ((remainingLineLength = maxLineLength - currentLineLength - glueLength))
          appendToCurrentLine "${glue:0:${glueLength}}${arg:0:${remainingLineLength}}" "$((glueLength + remainingLineLength))"
          printCurrentLine
          arg="${arg:${remainingLineLength}}"
          # remove leading spaces
          arg="${arg##[[:blank:]]}"

          set -- "${arg}" "$@"
        else
          # the arg can fit on next line
          printCurrentLine
          appendToCurrentLine "${arg}" "${argLength}"
        fi
      else
        appendToCurrentLine "${glue:0:${glueLength}}${arg}" "$((glueLength + argLength))"
      fi
    done
    if [[ "${currentLine}" != "" ]] && [[ ! "${currentLine}" =~ ^[\ \t]+$ ]]; then
      printCurrentLine
    fi
  ) | sed -E -e 's/[[:blank:]]+$//'
}

# @description checks if function name provided exists
# @arg $1 functionName:String
# @exitcode 1 if function name doesn't exist
Assert::functionExists() {
  declare -F "$1" >/dev/null
}

# @description convert base64 encoded back to target file
# if target file is executable prepend dir of target
# file to PATH to make binary available everywhere
# it is advised to include in the path of the target file
# the md5sum of the binFile
#
# @arg $1 targetFile:String the file to write
# @arg $2 binFileBase64:String the base64 encoded file
# @arg $3 fileMode:String the chmod to set on the file
# @set PATH String prepend target embedded file binary directory to PATH variable if binary executable
Compiler::Embed::extractFileFromBase64() {
  local targetFile="$1"
  local binFileBase64="$2"
  local fileMode="${3:-+x}"

  if [[ ! -f "${targetFile}" ]]; then
    mkdir -p "$(dirname "${targetFile}")"
    base64 -d >"${targetFile}" <<<"${binFileBase64}"
    chmod "${fileMode}" "${targetFile}"
  fi

  if [[ -x "${targetFile}" ]]; then
    Env::pathPrepend "$(dirname "${targetFile}")"
  fi
}

# @description list files of dir with given extension and display it as a list one by line
#
# @arg $1 dir:String the directory to list
# @arg $2 prefix:String the profile file prefix (default: "")
# @arg $3 ext:String the extension
# @arg $4 findOptions:String find options, eg: -type d (Default value: '-type f')
# @arg $5 indentStr:String the indentation can be any string compatible with sed not containing any / (Default value: '       - ')
# @stdout list of files without extension/directory
# @example text
#       - default.local
#       - default.remote
#       - localhost-root
# @exitcode 1 if directory does not exists
Conf::list() {
  local dir="$1"
  local prefix="${2:-}"
  local ext="${3}"
  local findOptions="${4--type f}"
  local indentStr="${5-       - }"

  if [[ ! -d "${dir}" ]]; then
    Log::displayError "Directory ${dir} does not exist"
  fi
  if [[ -n "${ext}" && "${ext:0:1}" != "." ]]; then
    ext=".${ext}"
  fi
  (
    # shellcheck disable=SC2086
    cd "${dir}" &&
      find . -maxdepth 1 ${findOptions} -name "${prefix}*${ext}" |
      sed -E "s#^\./${prefix}##g" |
        sed -E "s#${ext}\$##g" | sort | sed -E "s#^#${indentStr}#"
  )
}

envFileTemplate="$(
  cat <<'EOF'
# shellcheck disable=SC2034
# wsl username
USERNAME="wsl"
USERGROUP="wsl"
USER_HOME="/home/wsl"

# your login to connect to ssh servers if any
SSH_LOGIN=""

# your git full name 'FirstName LastName'
GIT_USERNAME=""
# email used for git 'ldap@domain.com'
GIT_USER_MAIL=""

# hostname of the distro
DISTRO_HOSTNAME="wslHost"

# conf files that will be used to configure the different tools
CONF_DIR="${BASH_DEV_ENV_ROOT_DIR}/conf"

# conf files that will be used to configure the different tools
# some tools configuration will use CONF_DIR as template and
# copy files into this directory
CONF_OVERRIDE_DIR="${BASH_DEV_ENV_ROOT_DIR}/conf.override"

# where to install bash-tools, ...
# shellcheck disable=SC2153
PROJECTS_DIR="${USER_HOME}/projects"

# where overridden config files will be backed up
BACKUP_DIR="${BASH_DEV_ENV_ROOT_DIR}/backup"
# logs CONF_DIR
LOGS_DIR="${BASH_DEV_ENV_ROOT_DIR}/logs"
# installScripts dir
INSTALL_SCRIPTS_DIR="${BASH_DEV_ENV_ROOT_DIR}/installScripts"

# 0   => no upgrade at all
# lts => UPGRADE to latest ubuntu lts version
# dev => UPGRADE to latest ubuntu dev version
# Use if you know what you are doing,
# could cause some packages to not being available yet
UPGRADE_UBUNTU_VERSION=0

# -----------------------------------------
# PROFILES options

# Choose your AWS authenticator tool
# possible choices: Saml2Aws, Awsume
AWS_AUTHENTICATOR="Saml2Aws"

# Choose your preferred shell
# possible choices: BashProfile (Legacy experience), ZshProfile (Recommended experience)
PREFERRED_SHELL="BashProfile"

# Display Fortune tooltip at bash/zsh session open
SHOW_FORTUNES=1

# Display MOTD at bash/zsh session open
SHOW_MOTD=1

# Install Docker inside wsl
DOCKER_INSIDE_WSL=1

# Configuration files are overwritten even if exists
# !!!! First time initialization: let this value to 1 !!!!
# Value 0:
# - If target configuration file exists, displays a message and do not overwrite the file
# - If target configuration file doesn't exist, installs the file
# Value 1
# - install or overwrite the file without checking existence
OVERWRITE_CONFIG_FILES=1

# Windows files can be overridden if 1
# if 0
# - skip changes to %USERPROFILE%/.wslconfig
# - skip copying fonts
CHANGE_WINDOWS_FILES=1

# Indicate that install script can warn you using speaker when your input is needed
CAN_TALK_DURING_INSTALLATION=1

# if 1 install script will skip all interactive activity (saml2aws, ...),
# so dependent installation will be skipped as well
INSTALL_NON_INTERACTIVE=0

# display elapsed time since last log
DISPLAY_DURATION=1

# -----------------------------------------
# WSLCONFIG - these parameters will help to automatically
# configure %USERPROFILE%/.wslconfig file
# Adjust these values to your needs
# @see https://docs.microsoft.com/en-us/windows/wsl/wsl-config
# Recommended 50% of total memory
WSLCONFIG_MAX_MEMORY=8GB
# personally I prefer run out of memory instead of beginning swapping
# So I know immediately if some processes have to be stopped
WSLCONFIG_SWAP=0

# -----------------------------------------
# Hacks
# on some configurations we have to force path of some windows commands
#POWERSHELL_BIN=/mnt/c/Windows/System32/WindowsPowerShell/v1.0/powershell.exe
#IPCONFIG_BIN=/mnt/c/Windows/system32/ipconfig.exe
#WSL_EXE_BIN=/mnt/c/Windows/system32/wsl.exe

# -----------------------------------------
# Distro
# Only necessary when using the script distro
# to create or update a wsl distribution

# The name of the distro displayed in `wsl -l -v` command
DISTRO_NAME="UbuntuTest"
# where to download the distribution
DISTRO_URL="https://aka.ms/wslubuntu2004"
# Profile to use with install command
DISTRO_INSTALL_PROFILE="default"
# The path where bash-dev-env project will be copied into target distro
DISTRO_BASH_DEV_ENV_TARGET_DIR="${BASH_DEV_ENV_ROOT_DIR}"
EOF
)"

# @description load .env file
# @arg $1 envFile:String the file to load
Engine::Config::loadConfig() {
  if [[ "${BASH_DEV_ENV_CONFIG_LOADED:-}" = "1" ]]; then
    return 0
  fi
  local envFile="${BASH_DEV_ENV_ROOT_DIR}/.env"
  Engine::Config::createEnvFileFromTemplate \
    "${envFile}" "${envFileTemplate}" || exit 1
  set -o allexport
  # shellcheck source=/.env.template
  source <(echo "${envFileTemplate}")
  # shellcheck source=/.env
  source "${BASH_DEV_ENV_ROOT_DIR}/.env"
  set +o allexport

  # load environment variables ID, VERSION_CODENAME
  Engine::Config::loadOsRelease

  if ! Engine::Config::checkEnv; then
    Log::displayError "one or more variables are invalid, check above logs and fix '${envFile}' file accordingly"
    return 1
  fi

  Engine::Config::loadUserVariables
  Engine::Config::loadHostIp

  Engine::Config::requireWslu

  #Linux::Wsl::initEnv
  Engine::Config::loadWslVariables

  Engine::Config::installUpdateEnv "${CONF_DIR}" "${LDAP_LOGIN}" "${WINDOWS_PROFILE_DIR}"
  Log::requireLoad

  export BASH_DEV_ENV_CONFIG_LOADED=1
}

# @description ensure env files are loaded
# @arg $@ list of default files to load at the end
# @exitcode 1 if one of env files fails to load
# @stderr diagnostics information is displayed
# shellcheck disable=SC2120
Env::requireLoad() {
  local -a defaultFiles=("$@")
  # get list of possible config files
  local -a configFiles=()
  if [[ -n "${BASH_FRAMEWORK_ENV_FILES[0]+1}" ]]; then
    # BASH_FRAMEWORK_ENV_FILES is an array
    configFiles+=("${BASH_FRAMEWORK_ENV_FILES[@]}")
  fi
  if [[ -f "$(pwd)/.framework-config" ]]; then
    configFiles+=("$(pwd)/.framework-config")
  fi
  if [[ -f "${FRAMEWORK_ROOT_DIR}/.framework-config" ]]; then
    configFiles+=("${FRAMEWORK_ROOT_DIR}/.framework-config")
  fi
  configFiles+=("${optionEnvFiles[@]}")
  configFiles+=("${defaultFiles[@]}")

  for file in "${configFiles[@]}"; do
    # shellcheck source=/.framework-config
    CURRENT_LOADED_ENV_FILE="${file}" source "${file}" || {
      Log::displayError "while loading config file: ${file}"
      return 1
    }
  done
}

# @description create a temp file using default TMPDIR variable
# initialized in _includes/_commonHeader.sh
# @env TMPDIR String (default value /tmp)
# @arg $1 templateName:String template name to use(optional)
Framework::createTempFile() {
  mktemp -p "${TMPDIR:-/tmp}" -t "${1:-}.XXXXXXXXXXXX"
}

# @description the command launch different actions(install, configure, test)
# depending on the options selected
# @see src/_includes/install.default.options.tpl
# @env SKIP_INSTALL
# @env SKIP_CONFIGURE
# @env SKIP_TEST
# @env LOGS_DIR
InstallScripts::command() {
  local logsDir="${LOGS_DIR:-#}"
  local scriptName
  scriptName="$(scriptName)"
  rm -f "${logsDir}/${scriptName}-.*" || true

  # shellcheck disable=SC2317
  onInterrupt() {
    Log::displayError "${scriptName} aborted"
    exit 1
  }
  trap onInterrupt INT TERM ABRT

  local startDate logFile statsFile
  local installStatus="0"
  if [[ "${SKIP_INSTALL}" = "0" ]]; then
    Log::headLine "INSTALL - Installing ${scriptName}"
    logFile="${logsDir}/${scriptName}-install.log"
    statsFile="${logsDir}/${scriptName}-install.stat"

    # break at first install error
    (
      startDate="$(date +%s)"
      trap 'Stats::computeStatsTrap "Installation ${scriptName}" "${logFile}" "${statsFile}" "${startDate}"' EXIT INT TERM ABRT

      install 2>&1 | tee "${logFile}"
    )
  fi

  local configStatus="0"
  if [[ "${SKIP_CONFIGURE}" = "0" && "${installStatus}" = "0" ]]; then
    Log::headLine "CONFIG  - Configuring ${scriptName}"
    logFile="${logsDir}/${scriptName}-config.log"
    statsFile="${logsDir}/${scriptName}-config.stat"
    (
      startDate="$(date +%s)"
      trap 'Stats::computeStatsTrap "Configuration ${scriptName}" "${logFile}" "${statsFile}" "${startDate}"' EXIT INT TERM ABRT

      configure 2>&1 | tee "${logFile}"
    ) || configStatus="$?" || true

    if [[ "${configStatus}" != "0" ]] && breakOnConfigFailure; then
      # break if config script error
      exit "${configStatus}"
    fi
  fi

  local testInstallStatus="0"
  if [[ "${SKIP_TEST}" = "0" && "${installStatus}" = "0" ]]; then
    Log::headLine "TEST    - Testing ${scriptName} installation"
    logFile="${logsDir}/${scriptName}-test-install.log"
    statsFile="${logsDir}/${scriptName}-test-install.stat"
    (
      startDate="$(date +%s)"
      trap 'Stats::computeStatsTrap "Test ${scriptName}" "${logFile}" "${statsFile}" "${startDate}"' EXIT INT TERM ABRT

      testInstall 2>&1 | tee "${logFile}"
    ) || testInstallStatus="$?" || true
    if [[ "${testInstallStatus}" != "0" ]] && breakOnTestFailure; then
      # break if test script error
      exit "${testInstallStatus}"
    fi
  fi

  local testConfigStatus="0"
  if [[ "${SKIP_TEST}" = "0" && "${installStatus}" = "0" && "${configStatus}" = "0" ]]; then
    Log::headLine "TEST    - Testing ${scriptName} configuration"
    logFile="${logsDir}/${scriptName}-test-configuration.log"
    statsFile="${logsDir}/${scriptName}-test-configuration.stat"
    (
      startDate="$(date +%s)"
      trap 'Stats::computeStatsTrap "Test ${scriptName}" "${logFile}" "${statsFile}" "${startDate}"' EXIT INT TERM ABRT

      testConfigure 2>&1 | tee "${logFile}"
    ) || testConfigStatus="$?" || true
    if [[ "${testConfigStatus}" != "0" ]] && breakOnTestFailure; then
      # break if test script error
      exit "${testConfigStatus}"
    fi
  fi
}

# @description apt-get install
# @arg $@ softwares:String[] list of softwares to install
# @feature Retry::default
# Linux::requireSudoCommand
# @require Linux::requireUbuntu
# @stdout diagnostics logs
Linux::Apt::install() {
  Log::displayInfo "Apt install $*"
  Retry::default sudo apt-get install -y -q "$@"
}

# @description update apt packages list
# @feature Retry::default
# Linux::requireSudoCommand
# @require Linux::requireUbuntu
# @stdout diagnostics logs
Linux::Apt::update() {
  Log::displayInfo "Apt update ..."
  Retry::default sudo apt-get update -y --fix-missing -o Acquire::ForceIPv4=true
}

# @description checks if Systemd is running
# @noargs
# @exitcode 1 if systemd is not running
# @stdout diagnostics information
Linux::isSystemdRunning() {
  if [[ "$(readlink -f /sbin/init)" = "/usr/lib/systemd/systemd" ]]; then
    Log::displayInfo "SystemD is running"
    return 0
  fi
  Log::displayInfo "SystemD is not running"
  return 1
}

# @description Log namespace provides 2 kind of functions
# - Log::display* allows to display given message with
#   given display level
# - Log::log* allows to log given message with
#   given log level
# Log::display* functions automatically log the message too
# @see Env::requireLoad to load the display and log level from .env file

# @description log level off
export __LEVEL_OFF=0
# @description log level error
export __LEVEL_ERROR=1
# @description log level warning
export __LEVEL_WARNING=2
# @description log level info
export __LEVEL_INFO=3
# @description log level success
export __LEVEL_SUCCESS=3
# @description log level debug
export __LEVEL_DEBUG=4

# @description verbose level off
export __VERBOSE_LEVEL_OFF=0
# @description verbose level info
export __VERBOSE_LEVEL_INFO=1
# @description verbose level info
export __VERBOSE_LEVEL_DEBUG=2
# @description verbose level info
export __VERBOSE_LEVEL_TRACE=3

# @description Display message using debug color (grey)
# @arg $1 message:String the message to display
Log::displayDebug() {
  if ((BASH_FRAMEWORK_DISPLAY_LEVEL >= __LEVEL_DEBUG)); then
    echo -e "${__DEBUG_COLOR}DEBUG   - ${1}${__RESET_COLOR}" >&2
  fi
  Log::logDebug "$1"
}

# @description Display message using error color (red)
# @arg $1 message:String the message to display
Log::displayError() {
  if ((BASH_FRAMEWORK_DISPLAY_LEVEL >= __LEVEL_ERROR)); then
    echo -e "${__ERROR_COLOR}ERROR   - ${1}${__RESET_COLOR}" >&2
  fi
  Log::logError "$1"
}

FIRST_LOG_DATE="$(date '+%s%3N')"
LOG_LAST_LOG_DATE="${FIRST_LOG_DATE}"
LOG_LAST_LOG_DATE_INIT=1

# @description Display message using info color (bg light blue/fg white)
# @arg $1 message:String the message to display
# @env DISPLAY_DURATION int (default 0) if 1 display elapsed time information between 2 info logs
Log::displayInfo() {
  local type="${2:-INFO}"
  if ((BASH_FRAMEWORK_DISPLAY_LEVEL >= __LEVEL_INFO)); then
    local durationMsg=""
    if ((DISPLAY_DURATION == 1)); then
      local duration
      local -i currentLogDate
      currentLogDate="$(date '+%s%3N')"
      if ((LOG_LAST_LOG_DATE_INIT == 1)); then
        LOG_LAST_LOG_DATE_INIT=0
        duration="Ref"
      else
        duration="$(( (currentLogDate - FIRST_LOG_DATE) /1000 ))s/+$(( (currentLogDate - LOG_LAST_LOG_DATE) /1000 ))s"
      fi
      LOG_LAST_LOG_DATE="${currentLogDate}"
      durationMsg="$(date '+%H:%M:%S.%3N')(${duration}) - "
    fi
    echo -e "${__INFO_COLOR}${type}    - ${durationMsg}${1}${__RESET_COLOR}" >&2
  fi
  Log::logInfo "$1" "${type}"
}

# @description Display message using success color (bg green/fg white)
# @arg $1 message:String the message to display
Log::displaySuccess() {
  if ((BASH_FRAMEWORK_DISPLAY_LEVEL >= __LEVEL_INFO)); then
    echo -e "${__SUCCESS_COLOR}SUCCESS - ${1}${__RESET_COLOR}" >&2
  fi
  Log::logSuccess "$1"
}

# @description Display message using warning color (yellow)
# @arg $1 message:String the message to display
Log::displayWarning() {
  if ((BASH_FRAMEWORK_DISPLAY_LEVEL >= __LEVEL_WARNING)); then
    echo -e "${__WARNING_COLOR}WARN    - ${1}${__RESET_COLOR}" >&2
  fi
  Log::logWarning "$1"
}

# @description Display message using error color (red) and exit immediately with error status 1
# @arg $1 message:String the message to display
Log::fatal() {
  echo -e "${__ERROR_COLOR}FATAL   - ${1}${__RESET_COLOR}" >&2
  Log::logFatal "$1"
  exit 1
}

# @description activate or not Log::display* and Log::log* functions
# based on BASH_FRAMEWORK_DISPLAY_LEVEL and BASH_FRAMEWORK_LOG_LEVEL
# environment variables loaded by Env::requireLoad
# try to create log file and rotate it if necessary
# @noargs
# @set BASH_FRAMEWORK_LOG_LEVEL int to OFF level if BASH_FRAMEWORK_LOG_FILE is empty or not writable
# @env BASH_FRAMEWORK_DISPLAY_LEVEL int
# @env BASH_FRAMEWORK_LOG_LEVEL int
# @env BASH_FRAMEWORK_LOG_FILE String
# @env BASH_FRAMEWORK_LOG_FILE_MAX_ROTATION int do log rotation if > 0
# @exitcode 0 always successful
# @stderr diagnostics information about log file is displayed
# @require Env::requireLoad
# @require UI::requireTheme
Log::requireLoad() {
  if [[ -z "${BASH_FRAMEWORK_LOG_FILE:-}" ]]; then
    BASH_FRAMEWORK_LOG_LEVEL=${__LEVEL_OFF}
    export BASH_FRAMEWORK_LOG_LEVEL
  fi

  if ((BASH_FRAMEWORK_LOG_LEVEL > __LEVEL_OFF)); then
    if [[ ! -f "${BASH_FRAMEWORK_LOG_FILE}" ]]; then
      if
        ! mkdir -p "$(dirname "${BASH_FRAMEWORK_LOG_FILE}")" 2>/dev/null ||
          ! touch --no-create "${BASH_FRAMEWORK_LOG_FILE}" 2>/dev/null
      then
        BASH_FRAMEWORK_LOG_LEVEL=${__LEVEL_OFF}
        echo -e "${__ERROR_COLOR}ERROR   - File ${BASH_FRAMEWORK_LOG_FILE} is not writable${__RESET_COLOR}" >&2
      fi
    elif [[ ! -w "${BASH_FRAMEWORK_LOG_FILE}" ]]; then
      BASH_FRAMEWORK_LOG_LEVEL=${__LEVEL_OFF}
      echo -e "${__ERROR_COLOR}ERROR   - File ${BASH_FRAMEWORK_LOG_FILE} is not writable${__RESET_COLOR}" >&2
    fi

  fi

  if ((BASH_FRAMEWORK_LOG_LEVEL > __LEVEL_OFF)); then
    # will always be created even if not in info level
    Log::logMessage "INFO" "Logging to file ${BASH_FRAMEWORK_LOG_FILE} - Log level ${BASH_FRAMEWORK_LOG_LEVEL}"
    if ((BASH_FRAMEWORK_LOG_FILE_MAX_ROTATION > 0)); then
      Log::rotate "${BASH_FRAMEWORK_LOG_FILE}" "${BASH_FRAMEWORK_LOG_FILE_MAX_ROTATION}"
    fi
  fi
}

# @description Retry a command 5 times with a delay of 15 seconds between each attempt
# @arg $@ command:String[] the command to run
# @exitcode 0 on success
# @exitcode 1 if max retries count reached
Retry::default() {
  Retry::parameterized 5 15 "" "$@"
}

# @description draw a line with the character passed in parameter repeated depending on terminal width
# @arg $1 character:String character to use as separator (default value #)
UI::drawLine() {
  local character="${1:-#}"
  printf '%*s\n' "${COLUMNS:-$([[ -t 0 ]] && tput cols || echo)}" '' | tr ' ' "${character}"
}

# @description load colors theme constants
# @warning if tty not opened, noColor theme will be chosen
# @arg $1 theme:String the theme to use (default, noColor)
# @arg $@ args:String[]
# @set __ERROR_COLOR String indicate error status
# @set __INFO_COLOR String indicate info status
# @set __SUCCESS_COLOR String indicate success status
# @set __WARNING_COLOR String indicate warning status
# @set __SKIPPED_COLOR String indicate skipped status
# @set __DEBUG_COLOR String indicate debug status
# @set __HELP_COLOR String indicate help status
# @set __TEST_COLOR String not used
# @set __TEST_ERROR_COLOR String not used
# @set __HELP_TITLE_COLOR String used to display help title in help strings
# @set __HELP_OPTION_COLOR String used to display highlight options in help strings
#
# @set __RESET_COLOR String reset default color
#
# @set __HELP_EXAMPLE String to remove
# @set __HELP_TITLE String to remove
# @set __HELP_NORMAL String to remove
# shellcheck disable=SC2034
UI::theme() {
  local theme="${1-default}"
  if [[ ! "${theme}" =~ -force$ ]] && ! Assert::tty; then
    theme="noColor"
  fi
  case "${theme}" in
    default | default-force)
      theme="default"
      ;;
    noColor) ;;
    *)
      Log::fatal "invalid theme provided"
      ;;
  esac
  if [[ "${theme}" = "default" ]]; then
    BASH_FRAMEWORK_THEME="default"
    # check colors applicable https://misc.flogisoft.com/bash/tip_colors_and_formatting
    __ERROR_COLOR='\e[31m'         # Red
    __INFO_COLOR='\e[44m'          # white on lightBlue
    __SUCCESS_COLOR='\e[32m'       # Green
    __WARNING_COLOR='\e[33m'       # Yellow
    __SKIPPED_COLOR='\e[33m'       # Yellow
    __DEBUG_COLOR='\e[37m'         # Grey
    __HELP_COLOR='\e[7;49;33m'     # Black on Gold
    __TEST_COLOR='\e[100m'         # Light magenta
    __TEST_ERROR_COLOR='\e[41m'    # white on red
    __HELP_TITLE_COLOR="\e[1;37m"  # Bold
    __HELP_OPTION_COLOR="\e[1;34m" # Blue
    # Internal: reset color
    __RESET_COLOR='\e[0m' # Reset Color
    # shellcheck disable=SC2155,SC2034
    __HELP_EXAMPLE="$(echo -e "\e[2;97m")"
    # shellcheck disable=SC2155,SC2034
    __HELP_TITLE="$(echo -e "\e[1;37m")"
    # shellcheck disable=SC2155,SC2034
    __HELP_NORMAL="$(echo -e "\033[0m")"
  else
    BASH_FRAMEWORK_THEME="noColor"
    # check colors applicable https://misc.flogisoft.com/bash/tip_colors_and_formatting
    __ERROR_COLOR=''
    __INFO_COLOR=''
    __SUCCESS_COLOR=''
    __WARNING_COLOR=''
    __SKIPPED_COLOR=''
    __DEBUG_COLOR=''
    __HELP_COLOR=''
    __TEST_COLOR=''
    __TEST_ERROR_COLOR=''
    __HELP_TITLE_COLOR=''
    __HELP_OPTION_COLOR=''
    # Internal: reset color
    __RESET_COLOR=''
    __HELP_EXAMPLE=''
    __HELP_TITLE=''
    __HELP_NORMAL=''
  fi
}

# @description Check that command version is greater than expected minimal version
# display warning if command version greater than expected minimal version
# display error if command version less than expected minimal version and exit 1
# @arg $1 commandName:String command path
# @arg $2 argVersion:String command line parameters to launch to get command version
# @arg $3 minimalVersion:String expected minimal command version
# @arg $4 parseVersionCallback:Function
# @arg $5 help:String optional help message to display if command does not exist
# @exitcode 0 if command version greater or equal to expected minimal version
# @exitcode 1 if command version less than expected minimal version
# @exitcode 2 if command does not exist
Version::checkMinimal() {
  local commandName="$1"
  local argVersion="$2"
  local minimalVersion="$3"
  local parseVersionCallback=${4:-Version::parse}
  local help="${5:-}"

  Assert::commandExists "${commandName}" "${help}" || return 2

  # shellcheck disable=SC2034
  local status=0
  # shellcheck disable=SC2034
  local -a pipeStatus=()
  local version
  version="$("${commandName}" "${argVersion}" 2>&1 | ${parseVersionCallback} || Bash::handlePipelineFailure status pipeStatus)"

  Log::displayDebug "check ${commandName} version ${version} against minimal ${minimalVersion}"

  Version::compare "${version}" "${minimalVersion}" || {
    local result=$?
    if [[ "${result}" = "1" ]]; then
      Log::displayDebug "${commandName} version is ${version} greater than ${minimalVersion}, OK let's continue"
    elif [[ "${result}" = "2" ]]; then
      Log::displayError "${commandName} minimal version is ${minimalVersion}, your version is ${version}"
      return 1
    fi
    return 0
  }

}

# @description extract software version number
# @arg $1 command:String the command that will be called with --version parameter
# @arg $2 argVersion:String  allows to override default --version parameter
Version::getCommandVersionFromPlainText() {
  local command="$1"
  local argVersion="${2:---version}"
  "${command}" "${argVersion}" 2>&1 |
    Version::parse # keep only version numbers
}

# @description ensure tmpdir/bin exists and
# is added to PATH to make embed being executed automatically
# @noargs
# @exitcode 1 if cannot create tmp bin directory
# @set PATH string add tmp bin directory where to find embed binaries
# @stderr diagnostics information is displayed
Compiler::Embed::requireEmbedBinDir() {
  mkdir -p "${TMPDIR:-/tmp}/bin" || {
    Log::displayError "unable to create directory ${TMPDIR:-/tmp}/bin"
    return 1
  }
  Env::pathPrepend "${TMPDIR:-/tmp}/bin"
}

# @description ensure COMMAND_BIN_DIR env var is set
# and PATH correctly prepared
# @noargs
# @set COMMAND_BIN_DIR string the directory where to find this command
# @set PATH string add directory where to find this command binary
Compiler::Facade::requireCommandBinDir() {
  COMMAND_BIN_DIR="${CURRENT_DIR}"
  Env::pathPrepend "${COMMAND_BIN_DIR}"
}

# @description check if command specified exists or return 1
# with error and message if not
#
# @arg $1 commandName:String on which existence must be checked
# @arg $2 helpIfNotExists:String a help command to display if the command does not exist
#
# @exitcode 1 if the command specified does not exist
# @stderr diagnostic information + help if second argument is provided
Assert::commandExists() {
  local commandName="$1"
  local helpIfNotExists="$2"

  "${BASH_FRAMEWORK_COMMAND:-command}" -v "${commandName}" >/dev/null 2>/dev/null || {
    Log::displayError "${commandName} is not installed, please install it"
    if [[ -n "${helpIfNotExists}" ]]; then
      Log::displayInfo "${helpIfNotExists}"
    fi
    return 1
  }
  return 0
}

# @description check if tty (interactive mode) is active
# @noargs
# @exitcode 1 if tty not active
# @env NON_INTERACTIVE if 1 consider as not interactive even if environment is interactive
# @env INTERACTIVE if 1 consider as interactive even if environment is not interactive
Assert::tty() {
  if [[ "${NON_INTERACTIVE:-0}" = "1" ]]; then
    return 1
  fi
  if [[ "${INTERACTIVE:-0}" = "1" ]]; then
    return 0
  fi
  # check if stdout or stderr is connected to terminal
  [[ -t 1 || -t 2 ]]
}

# @description ignore exit code 141 from simple command pipes
# @example use with:
#   local resultingStatus=0
#   local -a originalPipeStatus=()
#   cmd1 | cmd2 || Bash::handlePipelineFailure resultingStatus originalPipeStatus || true
#   [[ "${resultingStatus}" = "0" ]]
# @arg $1 resultingStatusCode:&int (passed by reference) (optional) resulting status code
# @arg $2 originalStatus:int[] (passed by reference) (optional) copy of original PIPESTATUS array
# @env PIPESTATUS assuming that this function is called like in the example provided
# @see https://unix.stackexchange.com/a/709880/582856
Bash::handlePipelineFailure() {
  local -a pipeStatusBackup=("${PIPESTATUS[@]}")
  local -n handlePipelineFailure_resultingStatusCode=$1
  local -n handlePipelineFailure_originalStatus=$2
  # shellcheck disable=SC2034
  handlePipelineFailure_originalStatus=("${pipeStatusBackup[@]}")
  handlePipelineFailure_resultingStatusCode=0
  local statusCode
  for statusCode in "${pipeStatusBackup[@]}"; do
    if ((statusCode == 141)); then
      return 0
    elif ((statusCode > 0)); then
      # shellcheck disable=SC2034
      handlePipelineFailure_resultingStatusCode="${statusCode}"
      break
    fi
  done
  return "${handlePipelineFailure_resultingStatusCode}"
}

# @description check validity of .env variables
# @env CHECK_ENV int 0 to avoid checking environment
# @noargs
Engine::Config::checkEnv() {
  if [[ "${CHECK_ENV:-1}" = "0" ]]; then
    return 0
  fi
  local errorCount=0 || true
  checkNotEmpty() {
    local var="$1"
    if ! Assert::varExistsAndNotEmpty "${var}"; then
      ((++errorCount))
      return 1
    fi
  }
  checkVarAndDir() {
    local var="$1"
    local mode="${2:-}"
    local status=0
    if checkNotEmpty "${var}"; then
      if ! mkdir -p "${!var}"; then
        Log::displayError "variable ${var} - impossible to create the directory '${!var}'"
        ((errorCount++))
        return 1
      fi
      if [[ "${mode}" =~ w && ! -w "${!var}" ]]; then
        Log::displayError "variable ${var} - directory '${!var}' is not writable"
        ((status++))
        ((errorCount++))
      fi
      if [[ "${mode}" =~ r && ! -r "${!var}" ]]; then
        Log::displayError "variable ${var} - directory '${!var}' is not accessible"
        ((status++))
        ((errorCount++))
      fi
    fi

    return "${status}"
  }
  checkValidValues() {
    local var="$1"
    shift || true
    local -a validValues=("$@")
    if ! Array::contains "${!var}" "${validValues[@]}"; then
      Log::displayError "variable ${var} - value ${!var} is not part of the following values ${validValues[*]}"
      ((++errorCount))
    fi
  }

  if ! echo "${ID}" | grep -qEw 'debian|ubuntu'; then
    Log::fatal "This script is built to support only Debian or Ubuntu distributions. You are using ${ID}."
  fi

  if checkNotEmpty USERNAME && ! getent passwd "${USERNAME}" 2>/dev/null >/dev/null; then
    Log::displayError "USERNAME - user '${USERNAME}' does not exist"
    ((errorCount++))
  fi

  if [[ -n "${SSH_LOGIN:-}" ]] && ! Assert::ldapLogin "${SSH_LOGIN}"; then
    Log::displayError "SSH_LOGIN - invalid ldap login (format expected firstNameLastName) in ${BASH_DEV_ENV_ROOT_DIR}/.env file"
    ((errorCount++))
  fi

  if checkNotEmpty "GIT_USERNAME" && ! Assert::firstNameLastName "${GIT_USERNAME}"; then
    Log::displayError "GIT_USERNAME - invalid format, expected : firstName lastName"
    ((errorCount++))
  fi

  if checkNotEmpty "GIT_USER_MAIL" && ! Assert::emailAddress "${GIT_USER_MAIL}"; then
    Log::displayError "GIT_USER_MAIL - invalid email address"
    ((errorCount++))
  fi

  checkVarAndDir CONF_DIR r || true
  checkVarAndDir CONF_OVERRIDE_DIR r || true
  checkVarAndDir PROJECTS_DIR r || true
  checkVarAndDir BACKUP_DIR rw || true
  checkVarAndDir LOGS_DIR rw || true
  checkVarAndDir INSTALL_SCRIPTS_DIR r || true
  checkVarAndDir USER_HOME rw || true

  checkValidValues UPGRADE_UBUNTU_VERSION 0 lts dev
  checkValidValues AWS_AUTHENTICATOR Saml2Aws Awsume
  checkValidValues PREFERRED_SHELL BashProfile ZshProfile

  checkValidValues SHOW_FORTUNES 0 1
  checkValidValues SHOW_MOTD 0 1
  checkValidValues DOCKER_INSIDE_WSL 0 1
  checkValidValues OVERWRITE_CONFIG_FILES 0 1
  checkValidValues CHANGE_WINDOWS_FILES 0 1
  checkValidValues CAN_TALK_DURING_INSTALLATION 0 1
  checkValidValues INSTALL_NON_INTERACTIVE 0 1

  checkNotEmpty WSLCONFIG_MAX_MEMORY
  checkValidValues WSLCONFIG_SWAP 0 1

  return "${errorCount}"
}

# @description if .env does not exist, initialize it with .env.template
Engine::Config::createEnvFileFromTemplate() {
  local envFile="$1"
  local envFileTemplate="$2"

  if [[ ! -f "${envFile}" ]]; then
    echo "${envFileTemplate}" >"${envFile}"
    Log::displayError "a default env file has been created, please edit ${envFile}"
    return 1
  fi
}

# @description install or update /etc/profile.d/updateEnv.sh file
# @env CONF_DIR
# @env LDAP_LOGIN
# @env WINDOWS_PROFILE_DIR
Engine::Config::installUpdateEnv() {
  if [[ "${INSTALL_UPDATE_ENV:-1}" = "1" ]]; then
    # INSTALL_UPDATE_ENV avoids infinite loop
    return 0
  fi

  if [[ ! -f '/etc/profile.d/updateEnv.sh' || "${CONF_DIR}/etc/profile.d/updateEnv.sh" -nt "/etc/profile.d/updateEnv.sh" ]]; then
    SUDO=sudo OVERWRITE_CONFIG_FILES=1 Install::file \
      "${CONF_DIR}/etc/profile.d/updateEnv.sh" '/etc/profile.d/updateEnv.sh' \
      Install::setUserRootCallback
  fi
  if [[ "$(perl -ne 'if (/export LDAP_LOGIN=(.*)/) { print $1 }' "/etc/profile.d/updateEnv.sh")" != "${LDAP_LOGIN}" ]]; then
    sudo sed -i -e "s#export LDAP_LOGIN=.*\$#export LDAP_LOGIN=${LDAP_LOGIN}#g" "/etc/profile.d/updateEnv.sh"
  fi
  sudo sed -i -e "s#WINDOWS_PROFILE_DIR=.*\$#WINDOWS_PROFILE_DIR='${WINDOWS_PROFILE_DIR}'#" "/etc/profile.d/updateEnv.sh"

  # reload env
  set +o errexit
  # shellcheck source=/dev/null
  source "/etc/profile"
  set -o errexit
}

# @description deduce wsl host ip
# @set HOST_IP exported env containing the IP
Engine::Config::loadHostIp() {
  HOST_IP="$(/sbin/ip route | awk '/default/ { print $3 }')"

  export HOST_IP
}

# @description load /etc/os-release file
# @set NAME
# @set VERSION
# @set ID
# @set ID_LIKE
# @set PRETTY_NAME
# @set VERSION_ID
# @set HOME_URL
# @set SUPPORT_URL
# @set BUG_REPORT_URL
# @set PRIVACY_POLICY_URL
# @set VERSION_CODENAME
# @set UBUNTU_CODENAME
Engine::Config::loadOsRelease() {
  if [[ ! -f /etc/os-release ]]; then
    Log::displayError "file /etc/os-release does not exists"
    return 1
  fi
  # This will load environment variables ID, VERSION_CODENAME, ...
  set -o allexport
  source /etc/os-release
  set +o allexport
}

# @description deduce USER_HOME, USER_ID, USERGROUP_ID and USERGROUP from USERNAME
# @env USERNAME String the name of the user
# @set USER_ID String
# @set USERGROUP String
# @set USERGROUP_ID String
# @set USER_HOME String
Engine::Config::loadUserVariables() {
  # deduce user home and group
  # shellcheck disable=SC2153
  USER_ID="$(getent passwd "${USERNAME}" | cut -d: -f3)"
  USERGROUP_ID="$(getent passwd "${USERNAME}" | cut -d: -f4)"
  USERGROUP="$(getent group "${USERGROUP_ID}" | cut -d: -f1)"
  USER_HOME="$(getent passwd "${USERNAME}" | cut -d: -f6)"

  if [[ -z "${USERGROUP}" || -z "${USER_HOME}" ]]; then
    Log::displayError "USERNAME - unable to deduce USERGROUP, USER_HOME from USERNAME"
    return 1
  fi

  export USER_HOME
  export USER_ID
  export USERGROUP_ID
  export USERGROUP
}

# @description load wsl env variables
# @set BASE_MNT_C
# @set WINDOWS_DIR
# @set WINDOWS_PROFILE_DIR
# @set LOCAL_APP_DATA
# @set WINDOW_PATH
# @set WSL_EXE_BIN
# @set IPCONFIG_BIN
# @set POWERSHELL_BIN
# @env WSL_EXE_BIN
# @env IPCONFIG_BIN
# @env POWERSHELL_BIN
Engine::Config::loadWslVariables() {
  if ! Assert::wsl; then
    # skip
    return 0
  fi
  # shellcheck disable=SC1003
  BASE_MNT_C="$(mount | grep 'path=C:\\' | awk -F ' ' '{print $3}')"

  WINDOWS_DIR="$(Linux::Wsl::cachedWslpathFromWslVar SystemRoot)"
  WINDOWS_DIR="${WINDOWS_DIR:-${BASE_MNT_C}/Windows}"
  export WINDOWS_DIR

  WINDOWS_PROFILE_DIR="$(Linux::Wsl::cachedWslpathFromWslVar USERPROFILE)"
  WINDOWS_PROFILE_DIR="${WINDOWS_PROFILE_DIR:-${BASE_MNT_C}/Users/$(id -un)}"
  export WINDOWS_PROFILE_DIR

  LOCAL_APP_DATA="$(Linux::Wsl::cachedWslpathFromWslVar LOCALAPPDATA | tr -d '\n\r')"
  export LOCAL_APP_DATA

  # WINDOW_PATH
  WINDOW_PATH="$(Linux::Wsl::cachedWslvar PATH)"
  WINDOW_PATH="${WINDOW_PATH//;/:}"
  WINDOW_PATH="${WINDOW_PATH//\\//}"
  WINDOW_PATH="${WINDOW_PATH//C:/${BASE_MNT_C}}"

  deduceBin() {
    local var="$1"
    local expectedFullPath="$2"
    local expectedBin="$3"
    if [[ -z "${!var+xxx}" ]]; then
      eval "${var}=${expectedFullPath}"
      if ! command -v "${!var}" >/dev/null 2>&1; then
        eval "${var}=$(command -v "${expectedBin}" 2>/dev/null)"
      fi
    fi
    if [[ -z "${!var:-}" ]] || ! command -v "${!var}" >/dev/null 2>&1; then
      Log::fatal "variable ${var} - command ${expectedBin} not found"
    fi
    # shellcheck disable=SC2163
    export "${var}"
  }

  checkBinary() {
    local var="$1"
    if [[ -z "${var}" || ! -x "${!var}" ]]; then
      Log::displayError "variable ${var} - binary '${!var}' does not exist or not executable"
      ((errorCount++))
    fi
  }

  local errorCount=0
  # IPCONFIG_BIN - which ipconfig.exe does not work when executed as root
  deduceBin IPCONFIG_BIN "${WINDOWS_DIR}/System32/ipconfig.exe" "ipconfig.exe"
  checkBinary IPCONFIG_BIN

  deduceBin WSL_EXE_BIN "${WINDOWS_DIR}/System32/wsl.exe" "wsl.exe"
  checkBinary WSL_EXE_BIN

  deduceBin POWERSHELL_BIN "${WINDOWS_DIR}/System32/WindowsPowerShell/v1.0/powershell.exe" "powershell.exe"
  checkBinary POWERSHELL_BIN

  return "${errorCount}"
}

# @description install apt wslu if necessary providing wslvar, wslpath
Engine::Config::requireWslu() {
  if ! command -v wslvar &>/dev/null; then
    Log::displayInfo "Installing pre-requisite Wslu : wslvar, wslpath, ... commands"
    Linux::Apt::update
    Linux::Apt::install --no-install-recommends wslu

    # @see https://github.com/microsoft/WSL/issues/8843#issuecomment-1792256894
    Log::displayInfo "Fix wsl interoperability due to wsl bug"
    if [[
      ! -f /usr/lib/binfmt.d/WSLInterop.conf &&
      ! -f /etc/systemd/system/wsl-binfmt.service &&
      -f /run/systemd/generator.early/wsl-binfmt.service
    ]]; then
      sudo sh -c 'echo :WSLInterop:M::MZ::/init:PF > /usr/lib/binfmt.d/WSLInterop.conf'
      sudo ln -s /run/systemd/generator.early/wsl-binfmt.service /etc/systemd/system/wsl-binfmt.service
    fi
  fi
}

# @description prepend directories to the PATH environment variable
# @arg $@ args:String[] list of directories to prepend
# @set PATH update PATH with the directories prepended
Env::pathPrepend() {
  local arg
  for arg in "$@"; do
    if [[ -d "${arg}" && ":${PATH}:" != *":${arg}:"* ]]; then
      PATH="$(realpath "${arg}"):${PATH}"
    fi
  done
}

# @description Display given text on full line with TEST_COLOR style
# @arg $1 text:String text to display
Log::headLine() {
  local text="$1"
  local message
  message="$(UI::textLine "${text}" " ")"
  echo -e "${__TEST_COLOR}${message}${__RESET_COLOR}"
}

# @description log message to file
# @arg $1 message:String the message to display
Log::logDebug() {
  if ((BASH_FRAMEWORK_LOG_LEVEL >= __LEVEL_DEBUG)); then
    Log::logMessage "${2:-DEBUG}" "$1"
  fi
}

# @description log message to file
# @arg $1 message:String the message to display
Log::logError() {
  if ((BASH_FRAMEWORK_LOG_LEVEL >= __LEVEL_ERROR)); then
    Log::logMessage "${2:-ERROR}" "$1"
  fi
}

# @description log message to file
# @arg $1 message:String the message to display
Log::logFatal() {
  Log::logMessage "${2:-FATAL}" "$1"
}

# @description log message to file
# @arg $1 message:String the message to display
Log::logInfo() {
  if ((BASH_FRAMEWORK_LOG_LEVEL >= __LEVEL_INFO)); then
    Log::logMessage "${2:-INFO}" "$1"
  fi
}

# @description Internal: common log message
# @example text
#   [date]|[levelMsg]|message
#
# @example text
#   2020-01-19 19:20:21|ERROR  |log error
#   2020-01-19 19:20:21|SKIPPED|log skipped
#
# @arg $1 levelMsg:String message's level description (eg: STATUS, ERROR, ...)
# @arg $2 msg:String the message to display
# @env BASH_FRAMEWORK_LOG_FILE String log file to use, do nothing if empty
# @env BASH_FRAMEWORK_LOG_LEVEL int log level log only if > OFF or fatal messages
# @stderr diagnostics information is displayed
# @require Env::requireLoad
# @require Log::requireLoad
Log::logMessage() {
  local levelMsg="$1"
  local msg="$2"
  local date

  if [[ -n "${BASH_FRAMEWORK_LOG_FILE}" ]] && ((BASH_FRAMEWORK_LOG_LEVEL > __LEVEL_OFF)); then
    date="$(date '+%Y-%m-%d %H:%M:%S')"
    touch "${BASH_FRAMEWORK_LOG_FILE}"
    printf "%s|%7s|%s\n" "${date}" "${levelMsg}" "${msg}" >>"${BASH_FRAMEWORK_LOG_FILE}"
  fi
}

# @description log message to file
# @arg $1 message:String the message to display
Log::logSuccess() {
  if ((BASH_FRAMEWORK_LOG_LEVEL >= __LEVEL_INFO)); then
    Log::logMessage "${2:-SUCCESS}" "$1"
  fi
}

# @description log message to file
# @arg $1 message:String the message to display
Log::logWarning() {
  if ((BASH_FRAMEWORK_LOG_LEVEL >= __LEVEL_WARNING)); then
    Log::logMessage "${2:-WARNING}" "$1"
  fi
}

# @description To be called before logging in the log file
# @arg $1 file:string log file name
# @arg $2 maxLogFilesCount:int maximum number of log files
Log::rotate() {
  local file="$1"
  local maxLogFilesCount="${2:-5}"

  if [[ ! -f "${file}" ]]; then
    Log::displaySkipped "Log file ${file} doesn't exist yet"
    return 0
  fi
  local i
  for ((i = maxLogFilesCount - 1; i > 0; i--)); do
    Log::displayInfo "Log rotation ${file}.${i} to ${file}.$((i + 1))"
    mv "${file}."{"${i}","$((i + 1))"} &>/dev/null || true
  done
  if cp "${file}" "${file}.1" &>/dev/null; then
    echo >"${file}" # reset log file
    Log::displayInfo "Log rotation ${file} to ${file}.1"
  fi
}

# @description Retry a command several times depending on parameters
# @arg $1 maxRetries:int    $1 max retries
# @arg $2 delay:int between attempt
# @arg $3 message:String to display to describe the attempt
# @arg $@ rest of parameters, the command to run
# @exitcode 0 on success
# @exitcode 1 if max retries count reached
# @exitcode 2 if maxRetries invalid value
Retry::parameterized() {
  local maxRetries=$1
  shift || true
  local delayBetweenTries=$1
  shift || true
  local message="$1"
  shift || true
  local retriesCount=1
  if [[ "${maxRetries}" -lt 1 ]]; then
    Log::displayError "invalid maxRetry value"
    return 2
  fi

  while true; do
    Log::displayInfo "Attempt ${retriesCount}/${maxRetries}: ${message}"
    if "$@"; then
      break
    elif [[ "${retriesCount}" -lt "${maxRetries}" ]]; then
      Log::displayWarning "Command failed. Wait for ${delayBetweenTries} seconds"
      ((retriesCount++))
      sleep "${delayBetweenTries}"
    else
      Log::displayError "The command has failed after ${retriesCount} attempts."
      return 1
    fi
  done
  return 0
}

# @description trap function responsible to compute and display stats after each script execution
# @arg $1 step:String current step (msg)
# @arg $2 logFile:String
# @arg $3 statFile:String
# @arg $4 startDate:String date at which log started
Stats::computeStatsTrap() {
  local status="$?"
  local step="$1"
  local logFile="$2"
  local statFile="$3"
  local startDate="$4"
  local endDate
  endDate="$(date +%s)"
  Stats::computeFromLog "${logFile}" "${status}" "$((endDate - startDate))" >"${statFile}"
  Stats::statusLine "${statFile}" "${step}"
  return "${status}"
}

# @description compare 2 version numbers
# @arg $1 version1:String version 1
# @arg $2 version2:String version 2
# @exitcode 0 if equal
# @exitcode 1 if version1 > version2
# @exitcode 2 else
Version::compare() {
  if [[ "$1" = "$2" ]]; then
    return 0
  fi
  local IFS=.
  # shellcheck disable=2206
  local i ver1=($1) ver2=($2)
  # fill empty fields in ver1 with zeros
  for ((i = ${#ver1[@]}; i < ${#ver2[@]}; i++)); do
    ver1[i]=0
  done
  for ((i = 0; i < ${#ver1[@]}; i++)); do
    if [[ -z "${ver2[i]+unset}" ]] || [[ -z ${ver2[i]} ]]; then
      # fill empty fields in ver2 with zeros
      ver2[i]=0
    fi
    if ((10#${ver1[i]} > 10#${ver2[i]})); then
      return 1
    fi
    if ((10#${ver1[i]} < 10#${ver2[i]})); then
      return 2
    fi
  done
  return 0
}

# @description filter to keep only version number from a string
# @arg $@ files:String[] the files to filter
# @exitcode * if one of the filter command fails
# @stdin you can use stdin as alternative to files argument
# @stdout the filtered content
# shellcheck disable=SC2120
Version::parse() {
  sed -En 's/[^0-9]*(([0-9]+\.)*[0-9]+).*/\1/p' "$@" | head -n1
}

# @description ensure linux distribution is ubuntu
# @exitcode 1 if linux distribution is not ubuntu
Linux::requireUbuntu() {
  if ! Array::contains "$(Linux::getDistributorId)" "Ubuntu" "Debian"; then
    Log::fatal "this script should be executed under Ubuntu or Debian OS"
  fi
}

# @description load color theme
# @noargs
# @env BASH_FRAMEWORK_THEME String theme to use
# @env LOAD_THEME int 0 to avoid loading theme
# @exitcode 0 always successful
UI::requireTheme() {
  if [[ "${LOAD_THEME:-1}" = "1" ]]; then
    UI::theme "${BASH_FRAMEWORK_THEME-default}"
  fi
}

# @description check if an element is contained in an array
#
# @arg $1 needle:String
# @arg $@ array:String[]
# @exitcode 0 if found
# @exitcode 1 otherwise
# @example
#   Array::contains "${libPath}" "${__BASH_FRAMEWORK_IMPORTED_FILES[@]}"
Array::contains() {
  local element
  for element in "${@:2}"; do
    [[ "${element}" = "$1" ]] && return 0
  done
  return 1
}

# @description check if param is valid email address
# @warning it is a very simple check, no RFC validation
# @arg $1 emailAddress:String the full email address
# @exitcode 1 if invalid email address
Assert::emailAddress() {
  local expectedRegexp="^\S+@\S+$"

  [[ "$1" =~ ${expectedRegexp} ]]
}

# @description check if argument respects 2 or more words separated by a space
# it supports accentuated characters and names with hyphen(-)
# @arg $1 firstNameLastName:String
# @exitcode 1 if regexp not matches
# @see https://regex101.com/r/JyyfOM/1
Assert::firstNameLastName() {
  local regexp="^[^ ]+([ ][^ ]+)+$"
  [[ $1 =~ ${regexp} ]]
}

# @description check if argument respects ldap login naming convention
# only using lowercase characters a-z
# @arg $1 ldapLogin:String
# @exitcode 1 if regexp not matches
Assert::ldapLogin() {
  [[ $1 =~ ^[a-z]+$ ]]
}

# @description checks if variable name provided exists
# @arg $1 varName:String
# @exitcode 1 if variable doesn't exist
# @exitcode 2 if variable value empty
# @exitcode 3 if variable name invalid
# @see Assert::validVariableName
# @stderr diagnostics information is displayed
Assert::varExistsAndNotEmpty() {
  local varName="$1"
  if ! Assert::validVariableName "${varName}"; then
    Log::displayError "${varName} - invalid variable name"
    return 3
  fi
  if [[ -z "${!varName+unset}" ]]; then
    Log::displayError "${varName} - not defined"
    return 1
  elif [[ -z "${!varName}" ]]; then
    Log::displayError "${varName} - please provide a value"
    return 2
  fi
}

# @description determine if the script is executed under WSL
# cspell:disable
# @example text
#   uname GitBash windows (with wsl) => MINGW64_NT-10.0 ZOXFL-6619QN2 2.10.0(0.325/5/3) 2018-06-13 23:34 x86_64 Msys
#   uname GitBash windows (wo wsl)   => MINGW64_NT-10.0 frsa02-j5cbkc2 2.9.0(0.318/5/3) 2018-01-12 23:37 x86_64 Msys
#   uname wsl => Linux ZOXFL-6619QN2 4.4.0-17134-Microsoft #112-Microsoft Thu Jun 07 22:57:00 PST 2018 x86_64 x86_64 x86_64 GNU/Linux
# cspell:enable
#
# @exitcode 1 on error
Assert::wsl() {
  [[ "$(uname -o)" = "GNU/Linux" ]]
}

# @description installs file to given directory
#
# callbacks parameters `${fromFile} ${targetFile} $@`
# @arg $1 fromFile - original file to copy
# @arg $2 targetFile - target file
# @arg $3 userName:String (optional) (default: ${USERNAME}) the user name that will be used to set target files ownership
# @arg $4 userGroup:String (optional) (default: ${USERNAME}) the group name that will be used to set target files ownership
# @arg $5 successCallback:Function the callback to call when file is installed successfully, by default setUserRights callback is called
# @arg $6 failureCallback:Function the callback to call when file installation has failed, by default unableToCopyCallback callback is called
# @arg $@ callbacksParams:String[] additional parameters passed to callbacks
# @exitcode 1 if fromFile is not readable
# @exitcode 2 if backup file failure
# @exitcode 0 on success or if OVERWRITE_CONFIG_FILES=0
# @exitcode 0 on success or if CHANGE_WINDOWS_FILES=0 and target file is a windows file
# @env OVERWRITE_CONFIG_FILES Boolean (default:0) if 1 will overwrite existing directory
# @env CHANGE_WINDOWS_FILES Boolean (default:0) if 1 and target file is in windows file system, overwrite it
# @env USERNAME (default: root) the user name that will be used to set target files ownership
# @env USERGROUP (default: root) the group name that will be used to set target files ownership
# @env BASE_MNT_C String windows C drive base PATH
# @env FRAMEWORK_ROOT_DIR used to make paths relative to this directory to reduce length of messages
# @env SUDO String allows to use custom sudo prefix command
Install::file() {
  local fromFile="$1"
  local targetFile="$2"
  local userName="${3:-${USERNAME:-root}}"
  local userGroup="${4:-${USERGROUP:-root}}"
  local successCallback=${5:-Install::setUserRightsCallback}
  local failureCallback=${6:-Install::unableToCopyCallback}
  shift 6 || true

  if [[ ! -f "${fromFile}" || ! -r "${fromFile}" ]]; then
    Log::displayError "cannot read source file '${fromFile}'"
    return 1
  fi

  # skip if OVERWRITE_CONFIG_FILES is 0 and target file exists
  if [[ "${OVERWRITE_CONFIG_FILES}" = "0" && -f "${targetFile}" ]]; then
    Log::displayWarning "File '${targetFile}' exists - Skip install (because OVERWRITE_CONFIG_FILES=0 in .env file)"
    return 0
  fi

  # skip if CHANGE_WINDOWS_FILES is 0 and target dir is c drive
  if [[ "${CHANGE_WINDOWS_FILES}" = "0" && "${targetFile}" =~ ^${BASE_MNT_C} ]]; then
    Log::displayWarning "File '${targetFile}' - Skip install (because CHANGE_WINDOWS_FILES=0 in .env file)"
    return 0
  fi

  local targetDir
  targetDir="$(dirname "${targetFile}")"
  if [[ ! -d "${targetDir}" ]]; then
    ${SUDO:-} mkdir -p "${targetDir}"
    ${SUDO:-} chown "${userName}":"${userGroup}" "${targetDir}"
  fi
  local fromDir
  fromDir="$(dirname "${fromFile}")"
  local fromFilename
  fromFilename="$(basename "${fromFile}")"

  Backup::file "${targetFile}" || return 2

  if ${SUDO:-} cp "${fromFile}" "${targetFile}"; then
    ${successCallback} "${fromFile}" "${targetFile}" "$@"
    Log::displaySuccess "Installed file '${fromDir#"${FRAMEWORK_ROOT_DIR}/"}/${fromFilename}' to '${targetFile}'"
  else
    ${failureCallback} "${fromDir}" "${fromFilename}" "${targetFile}" "$@"
  fi
}

# @description install callback
#   set file with root ownership
# @arg $1 fromFile:String
# @arg $2 targetFile:String
# @exitcode 1 on any failure
# @env SUDO String allows to use custom sudo prefix command
# @see Install::file
Install::setUserRootCallback() {
  # shellcheck disable=SC2034 # $1 not used
  local fromFile="$1"
  local targetFile="$2"
  ${SUDO:-} chown root:root "${targetFile}"
}

# @description retrieve path from wslvar and then use wslpath to resolve it
# using cache (cache is refreshed every day)
# @arg $1 var:String the var to retrieve using wslvar
# @arg $@ args:String[] (optional) additional arguments to pass to wslvar
# @env WSL_TMPDIR String temp directory to store the wslpath cache (default value: TMPDIR), you can use PERSISTENT_TMPDIR instead
# @exitcode * if Linux::Wsl::originalWslpath cannot find the path or Linux::Wsl::originalWslvar cannot find the var
# @stderr diagnostics information is displayed
# @require Linux::Wsl::requireWsl
# @feature cache
Linux::Wsl::cachedWslpathFromWslVar() {
  local var="$1"
  shift || true
  local value
  value="$(Linux::Wsl::cachedWslvar "${var}" "$@")" || return 1
  Linux::Wsl::cachedWslpath "${value}" || return 1
}

# @description retrieve wslvar using cache (cache is refreshed every day)
# @arg $@ args:String[] arguments to pass to wslvar
# @env WSL_TMPDIR String temp directory to store the wslvar cache (default value: TMPDIR), you can use PERSISTENT_TMPDIR instead
# @exitcode * if Linux::Wsl::originalWslvar cannot find the variable
# @stderr diagnostics information is displayed
# @require Linux::Wsl::requireWsl
# @feature cache
Linux::Wsl::cachedWslvar() {
  local tempEnvFile
  tempEnvFile="${WSL_TMPDIR:-${PERSISTENT_TMPDIR:-/tmp}}/bash_tools_wslvar_$(id -un)"

  Cache::getPropertyValue "${tempEnvFile}" "$1" Linux::Wsl::originalWslvar "$@"
}

# @description retrieve linux distributor id
# @noargs
# @exitcode 1 if lsb_release fails or not found
# @stdout the linux distributor id
Linux::getDistributorId() {
  lsb_release -a 2>/dev/null | sed -En 's/Distributor ID:[ \t]+(.+)/\1/p'
}

# @description Display message using skip color (yellow)
# @arg $1 message:String the message to display
Log::displaySkipped() {
  if ((BASH_FRAMEWORK_DISPLAY_LEVEL >= __LEVEL_INFO)); then
    echo -e "${__SKIPPED_COLOR}SKIPPED - ${1}${__RESET_COLOR}" >&2
  fi
  Log::logSkipped "$1"
}

# @description extract stats form log
# @arg $1 logFile:String the log file to parse
# @arg $2 status:int the status of the command associated to that log file
# @arg $3 duration:int the duration  of the command associated to that log file
# @stdout output with the format provided by this example src/Stats/aggregateStats.example
# @see src/Stats/aggregateStats.example
Stats::computeFromLog() {
  local logFile="$1"
  local status="$2"
  local duration="$3"

  local logStatsAwkScript
  logStatsAwkScript="$(
    cat <<'EOF'
BEGIN {
  error=0
  warning=0
  skipped=0
  help=0
  success=0
}
{
  buffer = substr($0, 1, 20)
  if(match(buffer, /(ERROR)[ ]+- /, arr) != 0) {
    error+=1
  } else if(match(buffer, /(WARNING)[ ]+- /, arr) != 0) {
    warning+=1
  } else if(match(buffer, /(SKIPPED)[ ]+- /, arr) != 0) {
    skipped+=1
  } else if(match(buffer, /(ERROR)[ ]+- /, arr) != 0) {
    error+=1
  } else if(match(buffer, /(HELP)[ ]+- /, arr) != 0) {
    help+=1
  } else if(match(buffer, /(SUCCESS)[ ]+- /, arr) != 0) {
    success+=1
  }

}
END {
  print "error=" error
  print "warning=" warning
  print "skipped=" skipped
  print "help=" help
  print "success=" success
}
EOF
  )"

  if [[ -f "${logFile}" ]]; then
    awk --source "${logStatsAwkScript}" "${logFile}"
    echo "status=${status}"
    echo "duration=${duration}"
  else
    # not executed
    echo "status=-1"
  fi
}

# @description display message to reflect last installation status
Stats::statusLine() {
  local statFile="$1"
  local msg="$2"
  if [[ ! -f "${statFile}" ]]; then
    return 0
  fi

  (
    # shellcheck source=src/Stats/logStats.example
    source "${statFile}" || exit 1

    local color="${__TEST_ERROR_COLOR}"
    local statusMsg
    if [[ "${status}" = "0" ]]; then
      if [[ "${skipped}" = "0" ]]; then
        color="${__SUCCESS_COLOR}"
        statusMsg="SUCCESS - ${msg} successful"
      else
        color="${__SKIPPED_COLOR}"
        statusMsg="SKIPPED - ${msg} skipped"
      fi
    elif [[ "${status}" = "-1" ]]; then
      statusMsg="ABORTED - ${msg} not executed"
    else
      statusMsg="ERROR   - ${msg} in error"
    fi
    # overwrite final TEST line
    echo -e "${color}${statusMsg}${__RESET_COLOR}"
  )
}

# @description Display given text and complete the rest of the line with given character
# @arg $1 text:String text to display
# @arg $2 character:String (default:#) character to use to complete the line
UI::textLine() {
  local text="$1"
  local character="${2:-#}"
  ((textSize = ${#text}))
  ((fullWith = $(tput cols)))
  ((remainingWidth = $((fullWith - textSize))))
  echo -n "${text}"
  printf '%*s\n' "${remainingWidth}" '' | tr ' ' "${character}"
}

# @description check if argument respects this framework variable naming convention
# - if variable begins with an uppercase or underscore, following letters have to be uppercase or underscore
# - variable name can includes ':' or '_' or digits but not as first letter
# here valid variable name examples
#
# @arg $1 variableName:String
# @exitcode 1 if regexp not matches
# @see https://regex101.com/r/BUlPXS/1
Assert::validVariableName() {
  echo "$1" | LC_ALL=POSIX grep -E -q '(^[a-z][A-Za-z_0-9:]+$)|(^[A-Z_][A-Z_0-9:]+$)'
}

# @description Backup given file in the same directory appending _ followed by the current date
# @arg $1 file:String the file to backup
# @stderr messages about backup file location
# @env SUDO String allows to use custom sudo prefix command
# @exitcode 1 on copy failure
Backup::file() {
  local file="$1"
  local backupFile
  if [[ -f "${file}" ]]; then
    backupFile="${file}_$(date +"%Y-%m-%d_%H:%M:%S")"
    Log::displayInfo "Backup file '${file}' to ${backupFile}"
    ${SUDO:-} cp "${file}" "${backupFile}"
  fi
}

# @description get property value from file
# if not present compute it using propertyNotFoundCallback (if provided) and store it in property file
# @arg $1 propertyFile:String the file in which the property will be searched
# @arg $2 key:String the property key to search in property file
# @arg $3 propertyNotFoundCallback:Function (optional) a callback to call if property key is not found in property file
# @arg $@ args:String[] (optional) the arguments to pass to the propertyNotFoundCallback
# @exitcode 1 if value is not found
# @exitcode * if propertyNotFoundCallback fails
# @stdout the property value given by property file or by the propertyNotFoundCallback
Cache::getPropertyValue() {
  local value
  local propertyFile="$1"
  shift || true
  local key
  key="$(echo -E "$1" | sed -E 's#\\#/#g')"
  shift || true
  local propertyNotFoundCallback=$1
  shift || true

  if grep -E "^${key}=.*" "${propertyFile}" &>/dev/null; then
    grep -E "^${key}=" "${propertyFile}" | cut -d'=' -f2
    return 0
  elif [[ "$(type -t "${propertyNotFoundCallback}")" = "function" ]]; then
    value="$("${propertyNotFoundCallback}" "$@")" || return $?
    if [[ -n "${value}" ]]; then
      echo -E "${key}=${value}" >>"${propertyFile}"
    fi
    echo -E "${value}"
    return 0
  fi
  return 1
}

# @description install callback
#   set file with root ownership and execution bit
# @arg $1 fromFile:String
# @arg $2 targetFile:String
# @arg $3 userName:String (optional) (default: ${USERNAME}) the user name that will be used to set target files ownership
# @arg $4 userGroup:String (optional) (default: ${USERNAME}) the group name that will be used to set target files ownership
# @env USERNAME (default: root) the user name that will be used to set target files ownership
# @env USERGROUP (default: root) the group name that will be used to set target files ownership
# @env SUDO String allows to use custom sudo prefix command
# @exitcode 1 on any failure
# @see Install::file
Install::setUserRightsCallback() {
  # shellcheck disable=SC2034 # $1 not used
  local fromFile="$1"
  local targetFile="$2"
  local userName="${3:-${USERNAME:-root}}"
  local userGroup="${4:-${USERGROUP:-root}}"

  ${SUDO:-} chown "${userName}":"${userGroup}" "${targetFile}"
}

# @description install callback
#   default callback used called when file copy has failed
# @arg $1 fromFile:String
# @arg $2 targetFile:String
# @env FRAMEWORK_ROOT_DIR used to make paths relative to this directory to reduce length of messages
# @exitcode 1 always fail
# @stderr diagnostics information is displayed
# @see Install::file
Install::unableToCopyCallback() {
  local fromDir="$1"
  local fileName="$2"
  local targetFile="$3"
  Log::fatal "unable to copy file '${fromDir#"${FRAMEWORK_ROOT_DIR}/"}/${fileName}' to '${targetFile}'"
}

# @description retrieve wslpath using cache (cache is refreshed every day)
# @arg $@ args:String[] arguments to pass to wslpath
# @env WSL_TMPDIR String temp directory to store the wslpath cache (default value: TMPDIR), you can use PERSISTENT_TMPDIR instead
# @exitcode * if Linux::Wsl::originalWslpath cannot find the path
# @stderr diagnostics information is displayed
# @require Linux::Wsl::requireWsl
# @feature cache
Linux::Wsl::cachedWslpath() {
  local -a args=("$@")
  local tempEnvFile key
  tempEnvFile="${WSL_TMPDIR:-${PERSISTENT_TMPDIR:-/tmp}}/bash_tools_wslpath_$(id -un)"

  key="$(Linux::Wsl::getKeyFromWslpathOptions "$@")"
  Cache::getPropertyValue "${tempEnvFile}" "${key}" Linux::Wsl::originalWslpath "${args[@]}"
}

# @description call simply original wslvar command
# @arg $@ args:String[] args to pass to wslvar
# @exitcode * wslvar exit code
# @stdout wslvar stdout
# @require Linux::Wsl::requireWsl
Linux::Wsl::originalWslvar() {
  wslvar "$@" | sed -z '$ s/[\r\n]$//'
}

# @description log message to file
# @arg $1 message:String the message to display
Log::logSkipped() {
  if ((BASH_FRAMEWORK_LOG_LEVEL >= __LEVEL_INFO)); then
    Log::logMessage "${2:-SKIPPED}" "$1"
  fi
}

# @description ensure linux runs under wsl
# @env WSL_GARBAGE_COLLECT int 0 to disable garbage collect of cache files
# @exitcode 1 if linux does not run under wsl
Linux::Wsl::requireWsl() {
  Assert::wsl || return 1
  if [[ "${WSL_GARBAGE_COLLECT:-1}" = "1" ]]; then
    local tempEnvDir
    tempEnvDir="${WSL_TMPDIR:-${PERSISTENT_TMPDIR:-/tmp}}"
    File::garbageCollect "${tempEnvDir}/bash_tools_wslpath_$(id -un)" "1"
    tempEnvDir="${WSL_TMPDIR:-${PERSISTENT_TMPDIR:-/tmp}}"
    File::garbageCollect "${tempEnvDir}/bash_tools_wslvar_$(id -un)" "1"
  fi
}

# @description delete files older than n days in given path
# @warning use this function with caution as it will delete all files in given path without any prompt
# @arg $1 path:String the directory in which files will be deleted or the file to delete
# @arg $2 mtime:String expiration time in days (eg: 1 means 1 day) (default value: 1). Eg: +1 match files that have been accessed at least two days ago (rounding effect)
# @arg $3 maxdepth:int Descend at most levels (a non-negative integer) levels of directories below the starting-points. (default value: 1)
# @exitcode 1 if path not provided or empty
# @exitcode * find command failure code
# @stderr find output on error or diagnostics logs
# @see man find atime
File::garbageCollect() {
  local path="$1"
  local mtime="$2"
  local maxdepth="${3:-1}"

  if [[ -z "${path}" ]]; then
    return 1
  fi

  if [[ ! -e "${path}" ]]; then
    # path already removed
    return 0
  fi

  Log::displayInfo "Garbage collect files older than ${mtime} days in path ${path} with max depth ${maxdepth}"
  find "${path}" -depth -maxdepth "${maxdepth}" -type f -mtime "${mtime}" -print -delete
}

# @description Compute a cache from wslpath options
# @arg $@ args:String[] arguments passed to wslpath
# @stderr diagnostics information is displayed
# @stdout the cache key deduced from the options
# @require Linux::Wsl::requireWsl
# @feature cache
# @internal
Linux::Wsl::getKeyFromWslpathOptions() {
  local options
  options=$(getopt -o "auwm" -- "$@" 2>/dev/null) || {
    Log::displayError "invalid options specified"
    return 1
  }
  local key="wslpath"
  eval set -- "${options}"
  while true; do
    case "$1" in
      -a | -u | -w | -m)
        key="${key}$1"
        ;;
      --)
        shift || true
        break
        ;;
      *)
        shift || true
        Log::displayWarning "Unknown key $1"
        ;;
    esac
    shift || true
  done
  echo -E "${key}_$1"
}

# @description call simply original wslpath command
# @arg $@ args:String[] args to pass to wslpath
# @exitcode * wslpath exit code
# @stdout wslpath stdout
# @require Linux::Wsl::requireWsl
Linux::Wsl::originalWslpath() {
  wslpath "$@"
}

# FUNCTIONS

# @require Compiler::Embed::requireEmbedBinDir

declare -gx embed_function_GithubUpgradeRelease="${PERSISTENT_TMPDIR:-/tmp}/bin/7e7392a9744245e7d19bfb0d2e55a432/githubUpgradeRelease"
declare -gx encoded_binary_file_GithubUpgradeRelease="IyEvdXNyL2Jpbi9lbnYgYmFzaAojIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjCiMgR0VORVJBVEVEIEZBQ0FERSBGUk9NIGh0dHBzOi8vZ2l0aHViLmNvbS9mY2hhc3RhbmV0L2Jhc2gtZGV2LWVudi90cmVlL21hc3Rlci92ZW5kb3IvYmFzaC10b29scy1mcmFtZXdvcmsvc3JjL0NvbXBpbGVyL0VtYmVkL2VtYmVkRnJhbWV3b3JrRnVuY3Rpb24uYmluRmlsZS50cGwKIyBETyBOT1QgRURJVCBJVAojIEBnZW5lcmF0ZWQKIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIwojIHNoZWxsY2hlY2sgZGlzYWJsZT1TQzIyODgsU0MyMDM0CiMgQklOX0ZJTEU9JHtCSU5fRklMRX0KIyBGQUNBREUKCiMgZW5zdXJlIHRoYXQgbm8gdXNlciBhbGlhc2VzIGNvdWxkIGludGVyZmVyZSB3aXRoCiMgY29tbWFuZHMgdXNlZCBpbiB0aGlzIHNjcmlwdAp1bmFsaWFzIC1hIHx8IHRydWUKc2hvcHQgLXUgZXhwYW5kX2FsaWFzZXMKCiMgc2hlbGxjaGVjayBkaXNhYmxlPVNDMjAzNAooKGZhaWx1cmVzID0gMCkpIHx8IHRydWUKCiMgQmFzaCB3aWxsIHJlbWVtYmVyICYgcmV0dXJuIHRoZSBoaWdoZXN0IGV4aXQgY29kZSBpbiBhIGNoYWluIG9mIHBpcGVzLgojIFRoaXMgd2F5IHlvdSBjYW4gY2F0Y2ggdGhlIGVycm9yIGluc2lkZSBwaXBlcywgZS5nLiBteXNxbGR1bXAgfCBnemlwCnNldCAtbyBwaXBlZmFpbApzZXQgLW8gZXJyZXhpdAoKIyBDb21tYW5kIFN1YnN0aXR1dGlvbiBjYW4gaW5oZXJpdCBlcnJleGl0IG9wdGlvbiBzaW5jZSBiYXNoIHY0LjQKc2hvcHQgLXMgaW5oZXJpdF9lcnJleGl0IHx8IHRydWUKCiMgaWYgc2V0LCBhbmQgam9iIGNvbnRyb2wgaXMgbm90IGFjdGl2ZSwgdGhlIHNoZWxsIHJ1bnMgdGhlIGxhc3QgY29tbWFuZAojIG9mIGEgcGlwZWxpbmUgbm90IGV4ZWN1dGVkIGluIHRoZSBiYWNrZ3JvdW5kIGluIHRoZSBjdXJyZW50IHNoZWxsCiMgZW52aXJvbm1lbnQuCnNob3B0IC1zIGxhc3RwaXBlCgojIGEgbG9nIGlzIGdlbmVyYXRlZCB3aGVuIGEgY29tbWFuZCBmYWlscwpzZXQgLW8gZXJydHJhY2UKCiMgdXNlIG51bGxnbG9iIHNvIHRoYXQgKGZpbGUqLnBocCkgd2lsbCByZXR1cm4gYW4gZW1wdHkgYXJyYXkgaWYgbm8gZmlsZQojIG1hdGNoZXMgdGhlIHdpbGRjYXJkCnNob3B0IC1zIG51bGxnbG9iCgojIGVuc3VyZSByZWdleHAgYXJlIGludGVycHJldGVkIHdpdGhvdXQgYWNjZW50dWF0ZWQgY2hhcmFjdGVycwpleHBvcnQgTENfQUxMPVBPU0lYCgpleHBvcnQgVEVSTT14dGVybS0yNTZjb2xvcgoKIyBhdm9pZCBpbnRlcmFjdGl2ZSBpbnN0YWxsCmV4cG9ydCBERUJJQU5fRlJPTlRFTkQ9bm9uaW50ZXJhY3RpdmUKZXhwb3J0IERFQkNPTkZfTk9OSU5URVJBQ1RJVkVfU0VFTj10cnVlCgojIHN0b3JlIGNvbW1hbmQgYXJndW1lbnRzIGZvciBsYXRlciB1c2FnZQojIHNoZWxsY2hlY2sgZGlzYWJsZT1TQzIwMzQKZGVjbGFyZSAtYSBCQVNIX0ZSQU1FV09SS19BUkdWPSgiJEAiKQojIHNoZWxsY2hlY2sgZGlzYWJsZT1TQzIwMzQKZGVjbGFyZSAtYSBPUklHSU5BTF9CQVNIX0ZSQU1FV09SS19BUkdWPSgiJEAiKQoKIyBAc2VlIGh0dHBzOi8vdW5peC5zdGFja2V4Y2hhbmdlLmNvbS9hLzM4Njg1NgojIHNoZWxsY2hlY2sgZGlzYWJsZT1TQzIzMTcKaW50ZXJydXB0TWFuYWdlbWVudCgpIHsKICAjIHJlc3RvcmUgU0lHSU5UIGhhbmRsZXIKICB0cmFwIC0gSU5UCiAgIyBlbnN1cmUgdGhhdCBDdHJsLUMgaXMgdHJhcHBlZCBieSB0aGlzIHNjcmlwdCBhbmQgbm90IGJ5IHN1YiBwcm9jZXNzCiAgIyByZXBvcnQgdG8gdGhlIHBhcmVudCB0aGF0IHdlIGhhdmUgaW5kZWVkIGJlZW4gaW50ZXJydXB0ZWQKICBraWxsIC1zIElOVCAiJCQiCn0KdHJhcCBpbnRlcnJ1cHRNYW5hZ2VtZW50IElOVApTQ1JJUFRfTkFNRT0kezAjIyovfQpSRUFMX1NDUklQVF9GSUxFPSIkKHJlYWRsaW5rIC1lICIkKHJlYWxwYXRoICIke0JBU0hfU09VUkNFWzBdfSIpIikiCmlmIFtbIC1uICIke0VNQkVEX0NVUlJFTlRfRElSfSIgXV07IHRoZW4KICBDVVJSRU5UX0RJUj0iJHtFTUJFRF9DVVJSRU5UX0RJUn0iCmVsc2UKICBDVVJSRU5UX0RJUj0iJChjZCAiJChyZWFkbGluayAtZSAiJHtSRUFMX1NDUklQVF9GSUxFJS8qfSIpIiAmJiBwd2QgLVApIgpmaQoKIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjCiMgVGVtcCBkaXIgbWFuYWdlbWVudAojIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMKCktFRVBfVEVNUF9GSUxFUz0iJHtLRUVQX1RFTVBfRklMRVM6LTB9IgpleHBvcnQgS0VFUF9URU1QX0ZJTEVTCgojIFBFUlNJU1RFTlRfVE1QRElSIGlzIG5vdCBkZWxldGVkIGJ5IHRyYXBzClBFUlNJU1RFTlRfVE1QRElSPSIke1RNUERJUjotL3RtcH0vYmFzaC1mcmFtZXdvcmsiCmV4cG9ydCBQRVJTSVNURU5UX1RNUERJUgpta2RpciAtcCAiJHtQRVJTSVNURU5UX1RNUERJUn0iCgojIHNoZWxsY2hlY2sgZGlzYWJsZT1TQzIwMzQKVE1QRElSPSIkKG1rdGVtcCAtZCAtcCAiJHtQRVJTSVNURU5UX1RNUERJUjotL3RtcH0iIC10IGJhc2gtZnJhbWV3b3JrLSQkLVhYWFhYWCkiCmV4cG9ydCBUTVBESVIKCiMgdGVtcCBkaXIgY2xlYW5pbmcKIyBzaGVsbGNoZWNrIGRpc2FibGU9U0MyMzE3CmNsZWFuT25FeGl0KCkgewogIGlmIFtbICIke0tFRVBfVEVNUF9GSUxFUzotMH0iID0gIjEiIF1dOyB0aGVuCiAgICBMb2c6OmRpc3BsYXlJbmZvICJLRUVQX1RFTVBfRklMRVM9MSB0ZW1wIGZpbGVzIGtlcHQgaGVyZSAnJHtUTVBESVJ9JyIKICBlbGlmIFtbIC1uICIke1RNUERJUit4eHh9IiBdXTsgdGhlbgogICAgTG9nOjpkaXNwbGF5RGVidWcgIktFRVBfVEVNUF9GSUxFUz0wIHJlbW92aW5nIHRlbXAgZmlsZXMgJyR7VE1QRElSfSciCiAgICBybSAtUmYgIiR7VE1QRElSOi0vdG1wL2Zha2V9IiA+L2Rldi9udWxsIDI+JjEKICBmaQp9CnRyYXAgY2xlYW5PbkV4aXQgRVhJVCBIVVAgUVVJVCBBQlJUIFRFUk0KCiMgQGRlc2NyaXB0aW9uIGNoZWNrcyBpZiBmdW5jdGlvbiBuYW1lIHByb3ZpZGVkIGV4aXN0cwojIEBhcmcgJDEgZnVuY3Rpb25OYW1lOlN0cmluZwojIEBleGl0Y29kZSAxIGlmIGZ1bmN0aW9uIG5hbWUgZG9lc24ndCBleGlzdApBc3NlcnQ6OmZ1bmN0aW9uRXhpc3RzKCkgewogIGRlY2xhcmUgLUYgIiQxIiA+L2Rldi9udWxsCn0KCmVudkZpbGVUZW1wbGF0ZT0iJCgKICBjYXQgPDwnRU9GJwojIHNoZWxsY2hlY2sgZGlzYWJsZT1TQzIwMzQKIyB3c2wgdXNlcm5hbWUKVVNFUk5BTUU9IndzbCIKVVNFUkdST1VQPSJ3c2wiClVTRVJfSE9NRT0iL2hvbWUvd3NsIgoKIyB5b3VyIGxvZ2luIHRvIGNvbm5lY3QgdG8gc3NoIHNlcnZlcnMgaWYgYW55ClNTSF9MT0dJTj0iIgoKIyB5b3VyIGdpdCBmdWxsIG5hbWUgJ0ZpcnN0TmFtZSBMYXN0TmFtZScKR0lUX1VTRVJOQU1FPSIiCiMgZW1haWwgdXNlZCBmb3IgZ2l0ICdsZGFwQGRvbWFpbi5jb20nCkdJVF9VU0VSX01BSUw9IiIKCiMgaG9zdG5hbWUgb2YgdGhlIGRpc3RybwpESVNUUk9fSE9TVE5BTUU9IndzbEhvc3QiCgojIGNvbmYgZmlsZXMgdGhhdCB3aWxsIGJlIHVzZWQgdG8gY29uZmlndXJlIHRoZSBkaWZmZXJlbnQgdG9vbHMKQ09ORl9ESVI9IiR7QkFTSF9ERVZfRU5WX1JPT1RfRElSfS9jb25mIgoKIyBjb25mIGZpbGVzIHRoYXQgd2lsbCBiZSB1c2VkIHRvIGNvbmZpZ3VyZSB0aGUgZGlmZmVyZW50IHRvb2xzCiMgc29tZSB0b29scyBjb25maWd1cmF0aW9uIHdpbGwgdXNlIENPTkZfRElSIGFzIHRlbXBsYXRlIGFuZAojIGNvcHkgZmlsZXMgaW50byB0aGlzIGRpcmVjdG9yeQpDT05GX09WRVJSSURFX0RJUj0iJHtCQVNIX0RFVl9FTlZfUk9PVF9ESVJ9L2NvbmYub3ZlcnJpZGUiCgojIHdoZXJlIHRvIGluc3RhbGwgYmFzaC10b29scywgLi4uCiMgc2hlbGxjaGVjayBkaXNhYmxlPVNDMjE1MwpQUk9KRUNUU19ESVI9IiR7VVNFUl9IT01FfS9wcm9qZWN0cyIKCiMgd2hlcmUgb3ZlcnJpZGRlbiBjb25maWcgZmlsZXMgd2lsbCBiZSBiYWNrZWQgdXAKQkFDS1VQX0RJUj0iJHtCQVNIX0RFVl9FTlZfUk9PVF9ESVJ9L2JhY2t1cCIKIyBsb2dzIENPTkZfRElSCkxPR1NfRElSPSIke0JBU0hfREVWX0VOVl9ST09UX0RJUn0vbG9ncyIKIyBpbnN0YWxsU2NyaXB0cyBkaXIKSU5TVEFMTF9TQ1JJUFRTX0RJUj0iJHtCQVNIX0RFVl9FTlZfUk9PVF9ESVJ9L2luc3RhbGxTY3JpcHRzIgoKIyAwICAgPT4gbm8gdXBncmFkZSBhdCBhbGwKIyBsdHMgPT4gVVBHUkFERSB0byBsYXRlc3QgdWJ1bnR1IGx0cyB2ZXJzaW9uCiMgZGV2ID0+IFVQR1JBREUgdG8gbGF0ZXN0IHVidW50dSBkZXYgdmVyc2lvbgojIFVzZSBpZiB5b3Uga25vdyB3aGF0IHlvdSBhcmUgZG9pbmcsCiMgY291bGQgY2F1c2Ugc29tZSBwYWNrYWdlcyB0byBub3QgYmVpbmcgYXZhaWxhYmxlIHlldApVUEdSQURFX1VCVU5UVV9WRVJTSU9OPTAKCiMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KIyBQUk9GSUxFUyBvcHRpb25zCgojIENob29zZSB5b3VyIEFXUyBhdXRoZW50aWNhdG9yIHRvb2wKIyBwb3NzaWJsZSBjaG9pY2VzOiBTYW1sMkF3cywgQXdzdW1lCkFXU19BVVRIRU5USUNBVE9SPSJTYW1sMkF3cyIKCiMgQ2hvb3NlIHlvdXIgcHJlZmVycmVkIHNoZWxsCiMgcG9zc2libGUgY2hvaWNlczogQmFzaFByb2ZpbGUgKExlZ2FjeSBleHBlcmllbmNlKSwgWnNoUHJvZmlsZSAoUmVjb21tZW5kZWQgZXhwZXJpZW5jZSkKUFJFRkVSUkVEX1NIRUxMPSJCYXNoUHJvZmlsZSIKCiMgRGlzcGxheSBGb3J0dW5lIHRvb2x0aXAgYXQgYmFzaC96c2ggc2Vzc2lvbiBvcGVuClNIT1dfRk9SVFVORVM9MQoKIyBEaXNwbGF5IE1PVEQgYXQgYmFzaC96c2ggc2Vzc2lvbiBvcGVuClNIT1dfTU9URD0xCgojIEluc3RhbGwgRG9ja2VyIGluc2lkZSB3c2wKRE9DS0VSX0lOU0lERV9XU0w9MQoKIyBDb25maWd1cmF0aW9uIGZpbGVzIGFyZSBvdmVyd3JpdHRlbiBldmVuIGlmIGV4aXN0cwojICEhISEgRmlyc3QgdGltZSBpbml0aWFsaXphdGlvbjogbGV0IHRoaXMgdmFsdWUgdG8gMSAhISEhCiMgVmFsdWUgMDoKIyAtIElmIHRhcmdldCBjb25maWd1cmF0aW9uIGZpbGUgZXhpc3RzLCBkaXNwbGF5cyBhIG1lc3NhZ2UgYW5kIGRvIG5vdCBvdmVyd3JpdGUgdGhlIGZpbGUKIyAtIElmIHRhcmdldCBjb25maWd1cmF0aW9uIGZpbGUgZG9lc24ndCBleGlzdCwgaW5zdGFsbHMgdGhlIGZpbGUKIyBWYWx1ZSAxCiMgLSBpbnN0YWxsIG9yIG92ZXJ3cml0ZSB0aGUgZmlsZSB3aXRob3V0IGNoZWNraW5nIGV4aXN0ZW5jZQpPVkVSV1JJVEVfQ09ORklHX0ZJTEVTPTEKCiMgV2luZG93cyBmaWxlcyBjYW4gYmUgb3ZlcnJpZGRlbiBpZiAxCiMgaWYgMAojIC0gc2tpcCBjaGFuZ2VzIHRvICVVU0VSUFJPRklMRSUvLndzbGNvbmZpZwojIC0gc2tpcCBjb3B5aW5nIGZvbnRzCkNIQU5HRV9XSU5ET1dTX0ZJTEVTPTEKCiMgSW5kaWNhdGUgdGhhdCBpbnN0YWxsIHNjcmlwdCBjYW4gd2FybiB5b3UgdXNpbmcgc3BlYWtlciB3aGVuIHlvdXIgaW5wdXQgaXMgbmVlZGVkCkNBTl9UQUxLX0RVUklOR19JTlNUQUxMQVRJT049MQoKIyBpZiAxIGluc3RhbGwgc2NyaXB0IHdpbGwgc2tpcCBhbGwgaW50ZXJhY3RpdmUgYWN0aXZpdHkgKHNhbWwyYXdzLCAuLi4pLAojIHNvIGRlcGVuZGVudCBpbnN0YWxsYXRpb24gd2lsbCBiZSBza2lwcGVkIGFzIHdlbGwKSU5TVEFMTF9OT05fSU5URVJBQ1RJVkU9MAoKIyBkaXNwbGF5IGVsYXBzZWQgdGltZSBzaW5jZSBsYXN0IGxvZwpESVNQTEFZX0RVUkFUSU9OPTEKCiMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KIyBXU0xDT05GSUcgLSB0aGVzZSBwYXJhbWV0ZXJzIHdpbGwgaGVscCB0byBhdXRvbWF0aWNhbGx5CiMgY29uZmlndXJlICVVU0VSUFJPRklMRSUvLndzbGNvbmZpZyBmaWxlCiMgQWRqdXN0IHRoZXNlIHZhbHVlcyB0byB5b3VyIG5lZWRzCiMgQHNlZSBodHRwczovL2RvY3MubWljcm9zb2Z0LmNvbS9lbi11cy93aW5kb3dzL3dzbC93c2wtY29uZmlnCiMgUmVjb21tZW5kZWQgNTAlIG9mIHRvdGFsIG1lbW9yeQpXU0xDT05GSUdfTUFYX01FTU9SWT04R0IKIyBwZXJzb25hbGx5IEkgcHJlZmVyIHJ1biBvdXQgb2YgbWVtb3J5IGluc3RlYWQgb2YgYmVnaW5uaW5nIHN3YXBwaW5nCiMgU28gSSBrbm93IGltbWVkaWF0ZWx5IGlmIHNvbWUgcHJvY2Vzc2VzIGhhdmUgdG8gYmUgc3RvcHBlZApXU0xDT05GSUdfU1dBUD0wCgojIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tCiMgSGFja3MKIyBvbiBzb21lIGNvbmZpZ3VyYXRpb25zIHdlIGhhdmUgdG8gZm9yY2UgcGF0aCBvZiBzb21lIHdpbmRvd3MgY29tbWFuZHMKI1BPV0VSU0hFTExfQklOPS9tbnQvYy9XaW5kb3dzL1N5c3RlbTMyL1dpbmRvd3NQb3dlclNoZWxsL3YxLjAvcG93ZXJzaGVsbC5leGUKI0lQQ09ORklHX0JJTj0vbW50L2MvV2luZG93cy9zeXN0ZW0zMi9pcGNvbmZpZy5leGUKI1dTTF9FWEVfQklOPS9tbnQvYy9XaW5kb3dzL3N5c3RlbTMyL3dzbC5leGUKCiMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KIyBEaXN0cm8KIyBPbmx5IG5lY2Vzc2FyeSB3aGVuIHVzaW5nIHRoZSBzY3JpcHQgZGlzdHJvCiMgdG8gY3JlYXRlIG9yIHVwZGF0ZSBhIHdzbCBkaXN0cmlidXRpb24KCiMgVGhlIG5hbWUgb2YgdGhlIGRpc3RybyBkaXNwbGF5ZWQgaW4gYHdzbCAtbCAtdmAgY29tbWFuZApESVNUUk9fTkFNRT0iVWJ1bnR1VGVzdCIKIyB3aGVyZSB0byBkb3dubG9hZCB0aGUgZGlzdHJpYnV0aW9uCkRJU1RST19VUkw9Imh0dHBzOi8vYWthLm1zL3dzbHVidW50dTIwMDQiCiMgUHJvZmlsZSB0byB1c2Ugd2l0aCBpbnN0YWxsIGNvbW1hbmQKRElTVFJPX0lOU1RBTExfUFJPRklMRT0iZGVmYXVsdCIKIyBUaGUgcGF0aCB3aGVyZSBiYXNoLWRldi1lbnYgcHJvamVjdCB3aWxsIGJlIGNvcGllZCBpbnRvIHRhcmdldCBkaXN0cm8KRElTVFJPX0JBU0hfREVWX0VOVl9UQVJHRVRfRElSPSIke0JBU0hfREVWX0VOVl9ST09UX0RJUn0iCkVPRgopIgoKIyBAZGVzY3JpcHRpb24gbG9hZCAuZW52IGZpbGUKIyBAYXJnICQxIGVudkZpbGU6U3RyaW5nIHRoZSBmaWxlIHRvIGxvYWQKRW5naW5lOjpDb25maWc6OmxvYWRDb25maWcoKSB7CiAgaWYgW1sgIiR7QkFTSF9ERVZfRU5WX0NPTkZJR19MT0FERUQ6LX0iID0gIjEiIF1dOyB0aGVuCiAgICByZXR1cm4gMAogIGZpCiAgbG9jYWwgZW52RmlsZT0iJHtCQVNIX0RFVl9FTlZfUk9PVF9ESVJ9Ly5lbnYiCiAgRW5naW5lOjpDb25maWc6OmNyZWF0ZUVudkZpbGVGcm9tVGVtcGxhdGUgXAogICAgIiR7ZW52RmlsZX0iICIke2VudkZpbGVUZW1wbGF0ZX0iIHx8IGV4aXQgMQogIHNldCAtbyBhbGxleHBvcnQKICAjIHNoZWxsY2hlY2sgc291cmNlPS8uZW52LnRlbXBsYXRlCiAgc291cmNlIDwoZWNobyAiJHtlbnZGaWxlVGVtcGxhdGV9IikKICAjIHNoZWxsY2hlY2sgc291cmNlPS8uZW52CiAgc291cmNlICIke0JBU0hfREVWX0VOVl9ST09UX0RJUn0vLmVudiIKICBzZXQgK28gYWxsZXhwb3J0CgogICMgbG9hZCBlbnZpcm9ubWVudCB2YXJpYWJsZXMgSUQsIFZFUlNJT05fQ09ERU5BTUUKICBFbmdpbmU6OkNvbmZpZzo6bG9hZE9zUmVsZWFzZQoKICBpZiAhIEVuZ2luZTo6Q29uZmlnOjpjaGVja0VudjsgdGhlbgogICAgTG9nOjpkaXNwbGF5RXJyb3IgIm9uZSBvciBtb3JlIHZhcmlhYmxlcyBhcmUgaW52YWxpZCwgY2hlY2sgYWJvdmUgbG9ncyBhbmQgZml4ICcke2VudkZpbGV9JyBmaWxlIGFjY29yZGluZ2x5IgogICAgcmV0dXJuIDEKICBmaQoKICBFbmdpbmU6OkNvbmZpZzo6bG9hZFVzZXJWYXJpYWJsZXMKICBFbmdpbmU6OkNvbmZpZzo6bG9hZEhvc3RJcAoKICBFbmdpbmU6OkNvbmZpZzo6cmVxdWlyZVdzbHUKCiAgI0xpbnV4OjpXc2w6OmluaXRFbnYKICBFbmdpbmU6OkNvbmZpZzo6bG9hZFdzbFZhcmlhYmxlcwoKICBFbmdpbmU6OkNvbmZpZzo6aW5zdGFsbFVwZGF0ZUVudiAiJHtDT05GX0RJUn0iICIke0xEQVBfTE9HSU59IiAiJHtXSU5ET1dTX1BST0ZJTEVfRElSfSIKICBMb2c6OnJlcXVpcmVMb2FkCgogIGV4cG9ydCBCQVNIX0RFVl9FTlZfQ09ORklHX0xPQURFRD0xCn0KCiMgQGRlc2NyaXB0aW9uIHVwZ3JhZGUgZ2l2ZW4gYmluYXJ5IHRvIGxhdGVzdCBnaXRodWIgcmVsZWFzZSB1c2luZyByZXRyeQojCiMgcmVsZWFzZVVybCBhcmd1bWVudCA6IHRoZSBwbGFjZWhvbGRlciBAbGF0ZXN0VmVyc2lvbkAgd2lsbCBiZSByZXBsYWNlZCBieSB0aGUgbGF0ZXN0IHJlbGVhc2UgdmVyc2lvbgojIEBhcmcgJDEgdGFyZ2V0RmlsZTpTdHJpbmcgdGFyZ2V0IGJpbmFyeSBmaWxlIChlZzogL3Vzci9sb2NhbC9iaW4va2luZCkKIyBAYXJnICQyIHJlbGVhc2VVcmw6U3RyaW5nICAgIGdpdGh1YiByZWxlYXNlIHVybCAoZWc6IGh0dHBzOi8vZ2l0aHViLmNvbS9rdWJlcm5ldGVzLXNpZ3Mva2luZC9yZWxlYXNlcy9kb3dubG9hZC9AbGF0ZXN0VmVyc2lvbkAva2luZC1saW51eC1hbWQ2NCkKIyBAYXJnICQzIHZlcnNpb25DYWxsYmFjazpGdW5jdGlvbiBmdW5jdGlvbiBjYWxsZWQgdG8gZ2V0IHNvZnR3YXJlIHZlcnNpb24gKGRlZmF1bHQ6IFZlcnNpb246OmdldENvbW1hbmRWZXJzaW9uRnJvbVBsYWluVGV4dCB3aWxsIGNhbGwgc29mdHdhcmUgd2l0aCBhcmd1bWVudCAtLXZlcnNpb24pCiMgQGFyZyAkNCBpbnN0YWxsQ2FsbGJhY2s6RnVuY3Rpb24gZnVuY3Rpb24gY2FsbGVkIHRvIGluc3RhbGwgdGhlIGZpbGUgcmV0cmlldmVkIG9uIGdpdGh1YiAoZGVmYXVsdCBjb3B5IGFzIGlzIGFuZCBzZXQgZXhlY3V0aW9uIGJpdCkKIyBAc3Rkb3V0IGxvZyBtZXNzYWdlcyBhYm91dCByZXRyeSwgaW5zdGFsbCwgdXBncmFkZQpHaXRodWI6OnVwZ3JhZGVSZWxlYXNlKCkgewogIGxvY2FsIHRhcmdldEZpbGU9IiQxIgogIGxvY2FsIHJlbGVhc2VVcmw9IiQyIgogIGxvY2FsIGFyZ1ZlcnNpb249IiR7MzotLS12ZXJzaW9ufSIKICBsb2NhbCB2ZXJzaW9uQ2FsbGJhY2s9IiR7NDotVmVyc2lvbjo6Z2V0Q29tbWFuZFZlcnNpb25Gcm9tUGxhaW5UZXh0fSIKICAjIHNoZWxsY2hlY2sgZGlzYWJsZT1TQzIwMzQKICBsb2NhbCBpbnN0YWxsQ2FsbGJhY2s9IiR7NTotfSIKICBsb2NhbCBsYXRlc3RWZXJzaW9uCiAgbG9jYWwgcmVwbwoKICByZXBvPSIkKEdpdGh1Yjo6ZXh0cmFjdFJlcG9Gcm9tR2l0aHViVXJsICIke3JlbGVhc2VVcmx9IikiCiAgR2l0aHViOjpnZXRMYXRlc3RSZWxlYXNlICIke3JlcG99IiBsYXRlc3RWZXJzaW9uIHx8CiAgICBMb2c6OmZhdGFsICJSZXBvICR7cmVwb30gbGF0ZXN0IHZlcnNpb24gbm90IGZvdW5kIgogIExvZzo6ZGlzcGxheUluZm8gIlJlcG8gJHtyZXBvfSBsYXRlc3QgdmVyc2lvbiBmb3VuZCBpcyAke2xhdGVzdFZlcnNpb259IgoKICBsb2NhbCBjdXJyZW50VmVyc2lvbj0ibm90IGV4aXN0aW5nIgogIGlmIFtbIC1mICIke3RhcmdldEZpbGV9IiBdXTsgdGhlbgogICAgY3VycmVudFZlcnNpb249IiQoJHt2ZXJzaW9uQ2FsbGJhY2t9ICIke3RhcmdldEZpbGV9IiAiJHthcmdWZXJzaW9ufSIgMj4mMSB8fCB0cnVlKSIKICBmaQogIGlmIFtbICIke2N1cnJlbnRWZXJzaW9ufSIgPSAiJHtsYXRlc3RWZXJzaW9ufSIgXV07IHRoZW4KICAgIExvZzo6ZGlzcGxheUluZm8gIiR7dGFyZ2V0RmlsZX0gdmVyc2lvbiAke2xhdGVzdFZlcnNpb259IGFscmVhZHkgaW5zdGFsbGVkIgogIGVsc2UKICAgIGlmIFtbIC16ICIke2N1cnJlbnRWZXJzaW9ufSIgXV07IHRoZW4KICAgICAgTG9nOjpkaXNwbGF5SW5mbyAiSW5zdGFsbGluZyAke3RhcmdldEZpbGV9IHdpdGggdmVyc2lvbiAke2xhdGVzdFZlcnNpb259IgogICAgZWxzZQogICAgICBMb2c6OmRpc3BsYXlJbmZvICJVcGdyYWRpbmcgJHt0YXJnZXRGaWxlfSBmcm9tIHZlcnNpb24gJHtjdXJyZW50VmVyc2lvbn0gdG8gJHtsYXRlc3RWZXJzaW9ufSIKICAgIGZpCiAgICBsb2NhbCB1cmwKICAgIHVybD0iJChlY2hvICIke3JlbGVhc2VVcmx9IiB8IHNlZCAtRSAicy9AbGF0ZXN0VmVyc2lvbkAvJHtsYXRlc3RWZXJzaW9ufS9nIikiCiAgICBMb2c6OmRpc3BsYXlJbmZvICJVc2luZyB1cmwgJHt1cmx9IgogICAgbmV3U29mdHdhcmU9JChta3RlbXAgLXAgIiR7VE1QRElSOi0vdG1wfSIgLXQgZ2l0aHViLm5ld1NvZnR3YXJlLlhYWFgpCiAgICBSZXRyeTo6ZGVmYXVsdCBjdXJsIFwKICAgICAgLUwgXAogICAgICAtbyAiJHtuZXdTb2Z0d2FyZX0iIFwKICAgICAgLS1mYWlsIFwKICAgICAgIiR7dXJsfSIKCiAgICBHaXRodWI6OmRlZmF1bHRJbnN0YWxsICIke25ld1NvZnR3YXJlfSIgIiR7dGFyZ2V0RmlsZX0iICIke2xhdGVzdFZlcnNpb259IiAiJHtpbnN0YWxsQ2FsbGJhY2t9IgogIGZpCn0KCiMgQGRlc2NyaXB0aW9uIExvZyBuYW1lc3BhY2UgcHJvdmlkZXMgMiBraW5kIG9mIGZ1bmN0aW9ucwojIC0gTG9nOjpkaXNwbGF5KiBhbGxvd3MgdG8gZGlzcGxheSBnaXZlbiBtZXNzYWdlIHdpdGgKIyAgIGdpdmVuIGRpc3BsYXkgbGV2ZWwKIyAtIExvZzo6bG9nKiBhbGxvd3MgdG8gbG9nIGdpdmVuIG1lc3NhZ2Ugd2l0aAojICAgZ2l2ZW4gbG9nIGxldmVsCiMgTG9nOjpkaXNwbGF5KiBmdW5jdGlvbnMgYXV0b21hdGljYWxseSBsb2cgdGhlIG1lc3NhZ2UgdG9vCiMgQHNlZSBFbnY6OnJlcXVpcmVMb2FkIHRvIGxvYWQgdGhlIGRpc3BsYXkgYW5kIGxvZyBsZXZlbCBmcm9tIC5lbnYgZmlsZQoKIyBAZGVzY3JpcHRpb24gbG9nIGxldmVsIG9mZgpleHBvcnQgX19MRVZFTF9PRkY9MAojIEBkZXNjcmlwdGlvbiBsb2cgbGV2ZWwgZXJyb3IKZXhwb3J0IF9fTEVWRUxfRVJST1I9MQojIEBkZXNjcmlwdGlvbiBsb2cgbGV2ZWwgd2FybmluZwpleHBvcnQgX19MRVZFTF9XQVJOSU5HPTIKIyBAZGVzY3JpcHRpb24gbG9nIGxldmVsIGluZm8KZXhwb3J0IF9fTEVWRUxfSU5GTz0zCiMgQGRlc2NyaXB0aW9uIGxvZyBsZXZlbCBzdWNjZXNzCmV4cG9ydCBfX0xFVkVMX1NVQ0NFU1M9MwojIEBkZXNjcmlwdGlvbiBsb2cgbGV2ZWwgZGVidWcKZXhwb3J0IF9fTEVWRUxfREVCVUc9NAoKIyBAZGVzY3JpcHRpb24gdmVyYm9zZSBsZXZlbCBvZmYKZXhwb3J0IF9fVkVSQk9TRV9MRVZFTF9PRkY9MAojIEBkZXNjcmlwdGlvbiB2ZXJib3NlIGxldmVsIGluZm8KZXhwb3J0IF9fVkVSQk9TRV9MRVZFTF9JTkZPPTEKIyBAZGVzY3JpcHRpb24gdmVyYm9zZSBsZXZlbCBpbmZvCmV4cG9ydCBfX1ZFUkJPU0VfTEVWRUxfREVCVUc9MgojIEBkZXNjcmlwdGlvbiB2ZXJib3NlIGxldmVsIGluZm8KZXhwb3J0IF9fVkVSQk9TRV9MRVZFTF9UUkFDRT0zCgojIEBkZXNjcmlwdGlvbiBEaXNwbGF5IG1lc3NhZ2UgdXNpbmcgZGVidWcgY29sb3IgKGdyZXkpCiMgQGFyZyAkMSBtZXNzYWdlOlN0cmluZyB0aGUgbWVzc2FnZSB0byBkaXNwbGF5CkxvZzo6ZGlzcGxheURlYnVnKCkgewogIGlmICgoQkFTSF9GUkFNRVdPUktfRElTUExBWV9MRVZFTCA+PSBfX0xFVkVMX0RFQlVHKSk7IHRoZW4KICAgIGVjaG8gLWUgIiR7X19ERUJVR19DT0xPUn1ERUJVRyAgIC0gJHsxfSR7X19SRVNFVF9DT0xPUn0iID4mMgogIGZpCiAgTG9nOjpsb2dEZWJ1ZyAiJDEiCn0KCkZJUlNUX0xPR19EQVRFPSIkKGRhdGUgJyslcyUzTicpIgpMT0dfTEFTVF9MT0dfREFURT0iJHtGSVJTVF9MT0dfREFURX0iCkxPR19MQVNUX0xPR19EQVRFX0lOSVQ9MQoKIyBAZGVzY3JpcHRpb24gRGlzcGxheSBtZXNzYWdlIHVzaW5nIGluZm8gY29sb3IgKGJnIGxpZ2h0IGJsdWUvZmcgd2hpdGUpCiMgQGFyZyAkMSBtZXNzYWdlOlN0cmluZyB0aGUgbWVzc2FnZSB0byBkaXNwbGF5CiMgQGVudiBESVNQTEFZX0RVUkFUSU9OIGludCAoZGVmYXVsdCAwKSBpZiAxIGRpc3BsYXkgZWxhcHNlZCB0aW1lIGluZm9ybWF0aW9uIGJldHdlZW4gMiBpbmZvIGxvZ3MKTG9nOjpkaXNwbGF5SW5mbygpIHsKICBsb2NhbCB0eXBlPSIkezI6LUlORk99IgogIGlmICgoQkFTSF9GUkFNRVdPUktfRElTUExBWV9MRVZFTCA+PSBfX0xFVkVMX0lORk8pKTsgdGhlbgogICAgbG9jYWwgZHVyYXRpb25Nc2c9IiIKICAgIGlmICgoRElTUExBWV9EVVJBVElPTiA9PSAxKSk7IHRoZW4KICAgICAgbG9jYWwgZHVyYXRpb24KICAgICAgbG9jYWwgLWkgY3VycmVudExvZ0RhdGUKICAgICAgY3VycmVudExvZ0RhdGU9IiQoZGF0ZSAnKyVzJTNOJykiCiAgICAgIGlmICgoTE9HX0xBU1RfTE9HX0RBVEVfSU5JVCA9PSAxKSk7IHRoZW4KICAgICAgICBMT0dfTEFTVF9MT0dfREFURV9JTklUPTAKICAgICAgICBkdXJhdGlvbj0iUmVmIgogICAgICBlbHNlCiAgICAgICAgZHVyYXRpb249IiQoKCAoY3VycmVudExvZ0RhdGUgLSBGSVJTVF9MT0dfREFURSkgLzEwMDAgKSlzLyskKCggKGN1cnJlbnRMb2dEYXRlIC0gTE9HX0xBU1RfTE9HX0RBVEUpIC8xMDAwICkpcyIKICAgICAgZmkKICAgICAgTE9HX0xBU1RfTE9HX0RBVEU9IiR7Y3VycmVudExvZ0RhdGV9IgogICAgICBkdXJhdGlvbk1zZz0iJChkYXRlICcrJUg6JU06JVMuJTNOJykoJHtkdXJhdGlvbn0pIC0gIgogICAgZmkKICAgIGVjaG8gLWUgIiR7X19JTkZPX0NPTE9SfSR7dHlwZX0gICAgLSAke2R1cmF0aW9uTXNnfSR7MX0ke19fUkVTRVRfQ09MT1J9IiA+JjIKICBmaQogIExvZzo6bG9nSW5mbyAiJDEiICIke3R5cGV9Igp9CgojIEBkZXNjcmlwdGlvbiBlbnN1cmUgQ09NTUFORF9CSU5fRElSIGVudiB2YXIgaXMgc2V0CiMgYW5kIFBBVEggY29ycmVjdGx5IHByZXBhcmVkCiMgQG5vYXJncwojIEBzZXQgQ09NTUFORF9CSU5fRElSIHN0cmluZyB0aGUgZGlyZWN0b3J5IHdoZXJlIHRvIGZpbmQgdGhpcyBjb21tYW5kCiMgQHNldCBQQVRIIHN0cmluZyBhZGQgZGlyZWN0b3J5IHdoZXJlIHRvIGZpbmQgdGhpcyBjb21tYW5kIGJpbmFyeQpDb21waWxlcjo6RmFjYWRlOjpyZXF1aXJlQ29tbWFuZEJpbkRpcigpIHsKICBDT01NQU5EX0JJTl9ESVI9IiR7Q1VSUkVOVF9ESVJ9IgogIEVudjo6cGF0aFByZXBlbmQgIiR7Q09NTUFORF9CSU5fRElSfSIKfQoKIyBAZGVzY3JpcHRpb24gY2hlY2sgdmFsaWRpdHkgb2YgLmVudiB2YXJpYWJsZXMKIyBAZW52IENIRUNLX0VOViBpbnQgMCB0byBhdm9pZCBjaGVja2luZyBlbnZpcm9ubWVudAojIEBub2FyZ3MKRW5naW5lOjpDb25maWc6OmNoZWNrRW52KCkgewogIGlmIFtbICIke0NIRUNLX0VOVjotMX0iID0gIjAiIF1dOyB0aGVuCiAgICByZXR1cm4gMAogIGZpCiAgbG9jYWwgZXJyb3JDb3VudD0wIHx8IHRydWUKICBjaGVja05vdEVtcHR5KCkgewogICAgbG9jYWwgdmFyPSIkMSIKICAgIGlmICEgQXNzZXJ0Ojp2YXJFeGlzdHNBbmROb3RFbXB0eSAiJHt2YXJ9IjsgdGhlbgogICAgICAoKCsrZXJyb3JDb3VudCkpCiAgICAgIHJldHVybiAxCiAgICBmaQogIH0KICBjaGVja1ZhckFuZERpcigpIHsKICAgIGxvY2FsIHZhcj0iJDEiCiAgICBsb2NhbCBtb2RlPSIkezI6LX0iCiAgICBsb2NhbCBzdGF0dXM9MAogICAgaWYgY2hlY2tOb3RFbXB0eSAiJHt2YXJ9IjsgdGhlbgogICAgICBpZiAhIG1rZGlyIC1wICIkeyF2YXJ9IjsgdGhlbgogICAgICAgIExvZzo6ZGlzcGxheUVycm9yICJ2YXJpYWJsZSAke3Zhcn0gLSBpbXBvc3NpYmxlIHRvIGNyZWF0ZSB0aGUgZGlyZWN0b3J5ICckeyF2YXJ9JyIKICAgICAgICAoKGVycm9yQ291bnQrKykpCiAgICAgICAgcmV0dXJuIDEKICAgICAgZmkKICAgICAgaWYgW1sgIiR7bW9kZX0iID1+IHcgJiYgISAtdyAiJHshdmFyfSIgXV07IHRoZW4KICAgICAgICBMb2c6OmRpc3BsYXlFcnJvciAidmFyaWFibGUgJHt2YXJ9IC0gZGlyZWN0b3J5ICckeyF2YXJ9JyBpcyBub3Qgd3JpdGFibGUiCiAgICAgICAgKChzdGF0dXMrKykpCiAgICAgICAgKChlcnJvckNvdW50KyspKQogICAgICBmaQogICAgICBpZiBbWyAiJHttb2RlfSIgPX4gciAmJiAhIC1yICIkeyF2YXJ9IiBdXTsgdGhlbgogICAgICAgIExvZzo6ZGlzcGxheUVycm9yICJ2YXJpYWJsZSAke3Zhcn0gLSBkaXJlY3RvcnkgJyR7IXZhcn0nIGlzIG5vdCBhY2Nlc3NpYmxlIgogICAgICAgICgoc3RhdHVzKyspKQogICAgICAgICgoZXJyb3JDb3VudCsrKSkKICAgICAgZmkKICAgIGZpCgogICAgcmV0dXJuICIke3N0YXR1c30iCiAgfQogIGNoZWNrVmFsaWRWYWx1ZXMoKSB7CiAgICBsb2NhbCB2YXI9IiQxIgogICAgc2hpZnQgfHwgdHJ1ZQogICAgbG9jYWwgLWEgdmFsaWRWYWx1ZXM9KCIkQCIpCiAgICBpZiAhIEFycmF5Ojpjb250YWlucyAiJHshdmFyfSIgIiR7dmFsaWRWYWx1ZXNbQF19IjsgdGhlbgogICAgICBMb2c6OmRpc3BsYXlFcnJvciAidmFyaWFibGUgJHt2YXJ9IC0gdmFsdWUgJHshdmFyfSBpcyBub3QgcGFydCBvZiB0aGUgZm9sbG93aW5nIHZhbHVlcyAke3ZhbGlkVmFsdWVzWypdfSIKICAgICAgKCgrK2Vycm9yQ291bnQpKQogICAgZmkKICB9CgogIGlmICEgZWNobyAiJHtJRH0iIHwgZ3JlcCAtcUV3ICdkZWJpYW58dWJ1bnR1JzsgdGhlbgogICAgTG9nOjpmYXRhbCAiVGhpcyBzY3JpcHQgaXMgYnVpbHQgdG8gc3VwcG9ydCBvbmx5IERlYmlhbiBvciBVYnVudHUgZGlzdHJpYnV0aW9ucy4gWW91IGFyZSB1c2luZyAke0lEfS4iCiAgZmkKCiAgaWYgY2hlY2tOb3RFbXB0eSBVU0VSTkFNRSAmJiAhIGdldGVudCBwYXNzd2QgIiR7VVNFUk5BTUV9IiAyPi9kZXYvbnVsbCA+L2Rldi9udWxsOyB0aGVuCiAgICBMb2c6OmRpc3BsYXlFcnJvciAiVVNFUk5BTUUgLSB1c2VyICcke1VTRVJOQU1FfScgZG9lcyBub3QgZXhpc3QiCiAgICAoKGVycm9yQ291bnQrKykpCiAgZmkKCiAgaWYgW1sgLW4gIiR7U1NIX0xPR0lOOi19IiBdXSAmJiAhIEFzc2VydDo6bGRhcExvZ2luICIke1NTSF9MT0dJTn0iOyB0aGVuCiAgICBMb2c6OmRpc3BsYXlFcnJvciAiU1NIX0xPR0lOIC0gaW52YWxpZCBsZGFwIGxvZ2luIChmb3JtYXQgZXhwZWN0ZWQgZmlyc3ROYW1lTGFzdE5hbWUpIGluICR7QkFTSF9ERVZfRU5WX1JPT1RfRElSfS8uZW52IGZpbGUiCiAgICAoKGVycm9yQ291bnQrKykpCiAgZmkKCiAgaWYgY2hlY2tOb3RFbXB0eSAiR0lUX1VTRVJOQU1FIiAmJiAhIEFzc2VydDo6Zmlyc3ROYW1lTGFzdE5hbWUgIiR7R0lUX1VTRVJOQU1FfSI7IHRoZW4KICAgIExvZzo6ZGlzcGxheUVycm9yICJHSVRfVVNFUk5BTUUgLSBpbnZhbGlkIGZvcm1hdCwgZXhwZWN0ZWQgOiBmaXJzdE5hbWUgbGFzdE5hbWUiCiAgICAoKGVycm9yQ291bnQrKykpCiAgZmkKCiAgaWYgY2hlY2tOb3RFbXB0eSAiR0lUX1VTRVJfTUFJTCIgJiYgISBBc3NlcnQ6OmVtYWlsQWRkcmVzcyAiJHtHSVRfVVNFUl9NQUlMfSI7IHRoZW4KICAgIExvZzo6ZGlzcGxheUVycm9yICJHSVRfVVNFUl9NQUlMIC0gaW52YWxpZCBlbWFpbCBhZGRyZXNzIgogICAgKChlcnJvckNvdW50KyspKQogIGZpCgogIGNoZWNrVmFyQW5kRGlyIENPTkZfRElSIHIgfHwgdHJ1ZQogIGNoZWNrVmFyQW5kRGlyIENPTkZfT1ZFUlJJREVfRElSIHIgfHwgdHJ1ZQogIGNoZWNrVmFyQW5kRGlyIFBST0pFQ1RTX0RJUiByIHx8IHRydWUKICBjaGVja1ZhckFuZERpciBCQUNLVVBfRElSIHJ3IHx8IHRydWUKICBjaGVja1ZhckFuZERpciBMT0dTX0RJUiBydyB8fCB0cnVlCiAgY2hlY2tWYXJBbmREaXIgSU5TVEFMTF9TQ1JJUFRTX0RJUiByIHx8IHRydWUKICBjaGVja1ZhckFuZERpciBVU0VSX0hPTUUgcncgfHwgdHJ1ZQoKICBjaGVja1ZhbGlkVmFsdWVzIFVQR1JBREVfVUJVTlRVX1ZFUlNJT04gMCBsdHMgZGV2CiAgY2hlY2tWYWxpZFZhbHVlcyBBV1NfQVVUSEVOVElDQVRPUiBTYW1sMkF3cyBBd3N1bWUKICBjaGVja1ZhbGlkVmFsdWVzIFBSRUZFUlJFRF9TSEVMTCBCYXNoUHJvZmlsZSBac2hQcm9maWxlCgogIGNoZWNrVmFsaWRWYWx1ZXMgU0hPV19GT1JUVU5FUyAwIDEKICBjaGVja1ZhbGlkVmFsdWVzIFNIT1dfTU9URCAwIDEKICBjaGVja1ZhbGlkVmFsdWVzIERPQ0tFUl9JTlNJREVfV1NMIDAgMQogIGNoZWNrVmFsaWRWYWx1ZXMgT1ZFUldSSVRFX0NPTkZJR19GSUxFUyAwIDEKICBjaGVja1ZhbGlkVmFsdWVzIENIQU5HRV9XSU5ET1dTX0ZJTEVTIDAgMQogIGNoZWNrVmFsaWRWYWx1ZXMgQ0FOX1RBTEtfRFVSSU5HX0lOU1RBTExBVElPTiAwIDEKICBjaGVja1ZhbGlkVmFsdWVzIElOU1RBTExfTk9OX0lOVEVSQUNUSVZFIDAgMQoKICBjaGVja05vdEVtcHR5IFdTTENPTkZJR19NQVhfTUVNT1JZCiAgY2hlY2tWYWxpZFZhbHVlcyBXU0xDT05GSUdfU1dBUCAwIDEKCiAgcmV0dXJuICIke2Vycm9yQ291bnR9Igp9CgojIEBkZXNjcmlwdGlvbiBpZiAuZW52IGRvZXMgbm90IGV4aXN0LCBpbml0aWFsaXplIGl0IHdpdGggLmVudi50ZW1wbGF0ZQpFbmdpbmU6OkNvbmZpZzo6Y3JlYXRlRW52RmlsZUZyb21UZW1wbGF0ZSgpIHsKICBsb2NhbCBlbnZGaWxlPSIkMSIKICBsb2NhbCBlbnZGaWxlVGVtcGxhdGU9IiQyIgoKICBpZiBbWyAhIC1mICIke2VudkZpbGV9IiBdXTsgdGhlbgogICAgZWNobyAiJHtlbnZGaWxlVGVtcGxhdGV9IiA+IiR7ZW52RmlsZX0iCiAgICBMb2c6OmRpc3BsYXlFcnJvciAiYSBkZWZhdWx0IGVudiBmaWxlIGhhcyBiZWVuIGNyZWF0ZWQsIHBsZWFzZSBlZGl0ICR7ZW52RmlsZX0iCiAgICByZXR1cm4gMQogIGZpCn0KCiMgQGRlc2NyaXB0aW9uIGluc3RhbGwgb3IgdXBkYXRlIC9ldGMvcHJvZmlsZS5kL3VwZGF0ZUVudi5zaCBmaWxlCiMgQGVudiBDT05GX0RJUgojIEBlbnYgTERBUF9MT0dJTgojIEBlbnYgV0lORE9XU19QUk9GSUxFX0RJUgpFbmdpbmU6OkNvbmZpZzo6aW5zdGFsbFVwZGF0ZUVudigpIHsKICBpZiBbWyAiJHtJTlNUQUxMX1VQREFURV9FTlY6LTF9IiA9ICIxIiBdXTsgdGhlbgogICAgIyBJTlNUQUxMX1VQREFURV9FTlYgYXZvaWRzIGluZmluaXRlIGxvb3AKICAgIHJldHVybiAwCiAgZmkKCiAgaWYgW1sgISAtZiAnL2V0Yy9wcm9maWxlLmQvdXBkYXRlRW52LnNoJyB8fCAiJHtDT05GX0RJUn0vZXRjL3Byb2ZpbGUuZC91cGRhdGVFbnYuc2giIC1udCAiL2V0Yy9wcm9maWxlLmQvdXBkYXRlRW52LnNoIiBdXTsgdGhlbgogICAgU1VETz1zdWRvIE9WRVJXUklURV9DT05GSUdfRklMRVM9MSBJbnN0YWxsOjpmaWxlIFwKICAgICAgIiR7Q09ORl9ESVJ9L2V0Yy9wcm9maWxlLmQvdXBkYXRlRW52LnNoIiAnL2V0Yy9wcm9maWxlLmQvdXBkYXRlRW52LnNoJyBcCiAgICAgIEluc3RhbGw6OnNldFVzZXJSb290Q2FsbGJhY2sKICBmaQogIGlmIFtbICIkKHBlcmwgLW5lICdpZiAoL2V4cG9ydCBMREFQX0xPR0lOPSguKikvKSB7IHByaW50ICQxIH0nICIvZXRjL3Byb2ZpbGUuZC91cGRhdGVFbnYuc2giKSIgIT0gIiR7TERBUF9MT0dJTn0iIF1dOyB0aGVuCiAgICBzdWRvIHNlZCAtaSAtZSAicyNleHBvcnQgTERBUF9MT0dJTj0uKlwkI2V4cG9ydCBMREFQX0xPR0lOPSR7TERBUF9MT0dJTn0jZyIgIi9ldGMvcHJvZmlsZS5kL3VwZGF0ZUVudi5zaCIKICBmaQogIHN1ZG8gc2VkIC1pIC1lICJzI1dJTkRPV1NfUFJPRklMRV9ESVI9LipcJCNXSU5ET1dTX1BST0ZJTEVfRElSPScke1dJTkRPV1NfUFJPRklMRV9ESVJ9JyMiICIvZXRjL3Byb2ZpbGUuZC91cGRhdGVFbnYuc2giCgogICMgcmVsb2FkIGVudgogIHNldCArbyBlcnJleGl0CiAgIyBzaGVsbGNoZWNrIHNvdXJjZT0vZGV2L251bGwKICBzb3VyY2UgIi9ldGMvcHJvZmlsZSIKICBzZXQgLW8gZXJyZXhpdAp9CgojIEBkZXNjcmlwdGlvbiBkZWR1Y2Ugd3NsIGhvc3QgaXAKIyBAc2V0IEhPU1RfSVAgZXhwb3J0ZWQgZW52IGNvbnRhaW5pbmcgdGhlIElQCkVuZ2luZTo6Q29uZmlnOjpsb2FkSG9zdElwKCkgewogIEhPU1RfSVA9IiQoL3NiaW4vaXAgcm91dGUgfCBhd2sgJy9kZWZhdWx0LyB7IHByaW50ICQzIH0nKSIKCiAgZXhwb3J0IEhPU1RfSVAKfQoKIyBAZGVzY3JpcHRpb24gbG9hZCAvZXRjL29zLXJlbGVhc2UgZmlsZQojIEBzZXQgTkFNRQojIEBzZXQgVkVSU0lPTgojIEBzZXQgSUQKIyBAc2V0IElEX0xJS0UKIyBAc2V0IFBSRVRUWV9OQU1FCiMgQHNldCBWRVJTSU9OX0lECiMgQHNldCBIT01FX1VSTAojIEBzZXQgU1VQUE9SVF9VUkwKIyBAc2V0IEJVR19SRVBPUlRfVVJMCiMgQHNldCBQUklWQUNZX1BPTElDWV9VUkwKIyBAc2V0IFZFUlNJT05fQ09ERU5BTUUKIyBAc2V0IFVCVU5UVV9DT0RFTkFNRQpFbmdpbmU6OkNvbmZpZzo6bG9hZE9zUmVsZWFzZSgpIHsKICBpZiBbWyAhIC1mIC9ldGMvb3MtcmVsZWFzZSBdXTsgdGhlbgogICAgTG9nOjpkaXNwbGF5RXJyb3IgImZpbGUgL2V0Yy9vcy1yZWxlYXNlIGRvZXMgbm90IGV4aXN0cyIKICAgIHJldHVybiAxCiAgZmkKICAjIFRoaXMgd2lsbCBsb2FkIGVudmlyb25tZW50IHZhcmlhYmxlcyBJRCwgVkVSU0lPTl9DT0RFTkFNRSwgLi4uCiAgc2V0IC1vIGFsbGV4cG9ydAogIHNvdXJjZSAvZXRjL29zLXJlbGVhc2UKICBzZXQgK28gYWxsZXhwb3J0Cn0KCiMgQGRlc2NyaXB0aW9uIGRlZHVjZSBVU0VSX0hPTUUsIFVTRVJfSUQsIFVTRVJHUk9VUF9JRCBhbmQgVVNFUkdST1VQIGZyb20gVVNFUk5BTUUKIyBAZW52IFVTRVJOQU1FIFN0cmluZyB0aGUgbmFtZSBvZiB0aGUgdXNlcgojIEBzZXQgVVNFUl9JRCBTdHJpbmcKIyBAc2V0IFVTRVJHUk9VUCBTdHJpbmcKIyBAc2V0IFVTRVJHUk9VUF9JRCBTdHJpbmcKIyBAc2V0IFVTRVJfSE9NRSBTdHJpbmcKRW5naW5lOjpDb25maWc6OmxvYWRVc2VyVmFyaWFibGVzKCkgewogICMgZGVkdWNlIHVzZXIgaG9tZSBhbmQgZ3JvdXAKICAjIHNoZWxsY2hlY2sgZGlzYWJsZT1TQzIxNTMKICBVU0VSX0lEPSIkKGdldGVudCBwYXNzd2QgIiR7VVNFUk5BTUV9IiB8IGN1dCAtZDogLWYzKSIKICBVU0VSR1JPVVBfSUQ9IiQoZ2V0ZW50IHBhc3N3ZCAiJHtVU0VSTkFNRX0iIHwgY3V0IC1kOiAtZjQpIgogIFVTRVJHUk9VUD0iJChnZXRlbnQgZ3JvdXAgIiR7VVNFUkdST1VQX0lEfSIgfCBjdXQgLWQ6IC1mMSkiCiAgVVNFUl9IT01FPSIkKGdldGVudCBwYXNzd2QgIiR7VVNFUk5BTUV9IiB8IGN1dCAtZDogLWY2KSIKCiAgaWYgW1sgLXogIiR7VVNFUkdST1VQfSIgfHwgLXogIiR7VVNFUl9IT01FfSIgXV07IHRoZW4KICAgIExvZzo6ZGlzcGxheUVycm9yICJVU0VSTkFNRSAtIHVuYWJsZSB0byBkZWR1Y2UgVVNFUkdST1VQLCBVU0VSX0hPTUUgZnJvbSBVU0VSTkFNRSIKICAgIHJldHVybiAxCiAgZmkKCiAgZXhwb3J0IFVTRVJfSE9NRQogIGV4cG9ydCBVU0VSX0lECiAgZXhwb3J0IFVTRVJHUk9VUF9JRAogIGV4cG9ydCBVU0VSR1JPVVAKfQoKIyBAZGVzY3JpcHRpb24gbG9hZCB3c2wgZW52IHZhcmlhYmxlcwojIEBzZXQgQkFTRV9NTlRfQwojIEBzZXQgV0lORE9XU19ESVIKIyBAc2V0IFdJTkRPV1NfUFJPRklMRV9ESVIKIyBAc2V0IExPQ0FMX0FQUF9EQVRBCiMgQHNldCBXSU5ET1dfUEFUSAojIEBzZXQgV1NMX0VYRV9CSU4KIyBAc2V0IElQQ09ORklHX0JJTgojIEBzZXQgUE9XRVJTSEVMTF9CSU4KIyBAZW52IFdTTF9FWEVfQklOCiMgQGVudiBJUENPTkZJR19CSU4KIyBAZW52IFBPV0VSU0hFTExfQklOCkVuZ2luZTo6Q29uZmlnOjpsb2FkV3NsVmFyaWFibGVzKCkgewogIGlmICEgQXNzZXJ0Ojp3c2w7IHRoZW4KICAgICMgc2tpcAogICAgcmV0dXJuIDAKICBmaQogICMgc2hlbGxjaGVjayBkaXNhYmxlPVNDMTAwMwogIEJBU0VfTU5UX0M9IiQobW91bnQgfCBncmVwICdwYXRoPUM6XFwnIHwgYXdrIC1GICcgJyAne3ByaW50ICQzfScpIgoKICBXSU5ET1dTX0RJUj0iJChMaW51eDo6V3NsOjpjYWNoZWRXc2xwYXRoRnJvbVdzbFZhciBTeXN0ZW1Sb290KSIKICBXSU5ET1dTX0RJUj0iJHtXSU5ET1dTX0RJUjotJHtCQVNFX01OVF9DfS9XaW5kb3dzfSIKICBleHBvcnQgV0lORE9XU19ESVIKCiAgV0lORE9XU19QUk9GSUxFX0RJUj0iJChMaW51eDo6V3NsOjpjYWNoZWRXc2xwYXRoRnJvbVdzbFZhciBVU0VSUFJPRklMRSkiCiAgV0lORE9XU19QUk9GSUxFX0RJUj0iJHtXSU5ET1dTX1BST0ZJTEVfRElSOi0ke0JBU0VfTU5UX0N9L1VzZXJzLyQoaWQgLXVuKX0iCiAgZXhwb3J0IFdJTkRPV1NfUFJPRklMRV9ESVIKCiAgTE9DQUxfQVBQX0RBVEE9IiQoTGludXg6OldzbDo6Y2FjaGVkV3NscGF0aEZyb21Xc2xWYXIgTE9DQUxBUFBEQVRBIHwgdHIgLWQgJ1xuXHInKSIKICBleHBvcnQgTE9DQUxfQVBQX0RBVEEKCiAgIyBXSU5ET1dfUEFUSAogIFdJTkRPV19QQVRIPSIkKExpbnV4OjpXc2w6OmNhY2hlZFdzbHZhciBQQVRIKSIKICBXSU5ET1dfUEFUSD0iJHtXSU5ET1dfUEFUSC8vOy86fSIKICBXSU5ET1dfUEFUSD0iJHtXSU5ET1dfUEFUSC8vXFwvL30iCiAgV0lORE9XX1BBVEg9IiR7V0lORE9XX1BBVEgvL0M6LyR7QkFTRV9NTlRfQ319IgoKICBkZWR1Y2VCaW4oKSB7CiAgICBsb2NhbCB2YXI9IiQxIgogICAgbG9jYWwgZXhwZWN0ZWRGdWxsUGF0aD0iJDIiCiAgICBsb2NhbCBleHBlY3RlZEJpbj0iJDMiCiAgICBpZiBbWyAteiAiJHshdmFyK3h4eH0iIF1dOyB0aGVuCiAgICAgIGV2YWwgIiR7dmFyfT0ke2V4cGVjdGVkRnVsbFBhdGh9IgogICAgICBpZiAhIGNvbW1hbmQgLXYgIiR7IXZhcn0iID4vZGV2L251bGwgMj4mMTsgdGhlbgogICAgICAgIGV2YWwgIiR7dmFyfT0kKGNvbW1hbmQgLXYgIiR7ZXhwZWN0ZWRCaW59IiAyPi9kZXYvbnVsbCkiCiAgICAgIGZpCiAgICBmaQogICAgaWYgW1sgLXogIiR7IXZhcjotfSIgXV0gfHwgISBjb21tYW5kIC12ICIkeyF2YXJ9IiA+L2Rldi9udWxsIDI+JjE7IHRoZW4KICAgICAgTG9nOjpmYXRhbCAidmFyaWFibGUgJHt2YXJ9IC0gY29tbWFuZCAke2V4cGVjdGVkQmlufSBub3QgZm91bmQiCiAgICBmaQogICAgIyBzaGVsbGNoZWNrIGRpc2FibGU9U0MyMTYzCiAgICBleHBvcnQgIiR7dmFyfSIKICB9CgogIGNoZWNrQmluYXJ5KCkgewogICAgbG9jYWwgdmFyPSIkMSIKICAgIGlmIFtbIC16ICIke3Zhcn0iIHx8ICEgLXggIiR7IXZhcn0iIF1dOyB0aGVuCiAgICAgIExvZzo6ZGlzcGxheUVycm9yICJ2YXJpYWJsZSAke3Zhcn0gLSBiaW5hcnkgJyR7IXZhcn0nIGRvZXMgbm90IGV4aXN0IG9yIG5vdCBleGVjdXRhYmxlIgogICAgICAoKGVycm9yQ291bnQrKykpCiAgICBmaQogIH0KCiAgbG9jYWwgZXJyb3JDb3VudD0wCiAgIyBJUENPTkZJR19CSU4gLSB3aGljaCBpcGNvbmZpZy5leGUgZG9lcyBub3Qgd29yayB3aGVuIGV4ZWN1dGVkIGFzIHJvb3QKICBkZWR1Y2VCaW4gSVBDT05GSUdfQklOICIke1dJTkRPV1NfRElSfS9TeXN0ZW0zMi9pcGNvbmZpZy5leGUiICJpcGNvbmZpZy5leGUiCiAgY2hlY2tCaW5hcnkgSVBDT05GSUdfQklOCgogIGRlZHVjZUJpbiBXU0xfRVhFX0JJTiAiJHtXSU5ET1dTX0RJUn0vU3lzdGVtMzIvd3NsLmV4ZSIgIndzbC5leGUiCiAgY2hlY2tCaW5hcnkgV1NMX0VYRV9CSU4KCiAgZGVkdWNlQmluIFBPV0VSU0hFTExfQklOICIke1dJTkRPV1NfRElSfS9TeXN0ZW0zMi9XaW5kb3dzUG93ZXJTaGVsbC92MS4wL3Bvd2Vyc2hlbGwuZXhlIiAicG93ZXJzaGVsbC5leGUiCiAgY2hlY2tCaW5hcnkgUE9XRVJTSEVMTF9CSU4KCiAgcmV0dXJuICIke2Vycm9yQ291bnR9Igp9CgojIEBkZXNjcmlwdGlvbiBpbnN0YWxsIGFwdCB3c2x1IGlmIG5lY2Vzc2FyeSBwcm92aWRpbmcgd3NsdmFyLCB3c2xwYXRoCkVuZ2luZTo6Q29uZmlnOjpyZXF1aXJlV3NsdSgpIHsKICBpZiAhIGNvbW1hbmQgLXYgd3NsdmFyICY+L2Rldi9udWxsOyB0aGVuCiAgICBMb2c6OmRpc3BsYXlJbmZvICJJbnN0YWxsaW5nIHByZS1yZXF1aXNpdGUgV3NsdSA6IHdzbHZhciwgd3NscGF0aCwgLi4uIGNvbW1hbmRzIgogICAgTGludXg6OkFwdDo6dXBkYXRlCiAgICBMaW51eDo6QXB0OjppbnN0YWxsIC0tbm8taW5zdGFsbC1yZWNvbW1lbmRzIHdzbHUKCiAgICAjIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL21pY3Jvc29mdC9XU0wvaXNzdWVzLzg4NDMjaXNzdWVjb21tZW50LTE3OTIyNTY4OTQKICAgIExvZzo6ZGlzcGxheUluZm8gIkZpeCB3c2wgaW50ZXJvcGVyYWJpbGl0eSBkdWUgdG8gd3NsIGJ1ZyIKICAgIGlmIFtbCiAgICAgICEgLWYgL3Vzci9saWIvYmluZm10LmQvV1NMSW50ZXJvcC5jb25mICYmCiAgICAgICEgLWYgL2V0Yy9zeXN0ZW1kL3N5c3RlbS93c2wtYmluZm10LnNlcnZpY2UgJiYKICAgICAgLWYgL3J1bi9zeXN0ZW1kL2dlbmVyYXRvci5lYXJseS93c2wtYmluZm10LnNlcnZpY2UKICAgIF1dOyB0aGVuCiAgICAgIHN1ZG8gc2ggLWMgJ2VjaG8gOldTTEludGVyb3A6TTo6TVo6Oi9pbml0OlBGID4gL3Vzci9saWIvYmluZm10LmQvV1NMSW50ZXJvcC5jb25mJwogICAgICBzdWRvIGxuIC1zIC9ydW4vc3lzdGVtZC9nZW5lcmF0b3IuZWFybHkvd3NsLWJpbmZtdC5zZXJ2aWNlIC9ldGMvc3lzdGVtZC9zeXN0ZW0vd3NsLWJpbmZtdC5zZXJ2aWNlCiAgICBmaQogIGZpCn0KCiMgQGRlc2NyaXB0aW9uIHByZXBlbmQgZGlyZWN0b3JpZXMgdG8gdGhlIFBBVEggZW52aXJvbm1lbnQgdmFyaWFibGUKIyBAYXJnICRAIGFyZ3M6U3RyaW5nW10gbGlzdCBvZiBkaXJlY3RvcmllcyB0byBwcmVwZW5kCiMgQHNldCBQQVRIIHVwZGF0ZSBQQVRIIHdpdGggdGhlIGRpcmVjdG9yaWVzIHByZXBlbmRlZApFbnY6OnBhdGhQcmVwZW5kKCkgewogIGxvY2FsIGFyZwogIGZvciBhcmcgaW4gIiRAIjsgZG8KICAgIGlmIFtbIC1kICIke2FyZ30iICYmICI6JHtQQVRIfToiICE9ICoiOiR7YXJnfToiKiBdXTsgdGhlbgogICAgICBQQVRIPSIkKHJlYWxwYXRoICIke2FyZ30iKToke1BBVEh9IgogICAgZmkKICBkb25lCn0KCiMgQGRlc2NyaXB0aW9uIGludGVybWVkaWF0ZSBjYWxsYmFjayB0aGF0IGlzIHVzZWQgYnkgR2l0aHViOjp1cGdyYWRlUmVsZWFzZQojIG9yIEdpdGh1Yjo6aW5zdGFsbFJlbGVhc2UKIyBpZiBpbnN0YWxsQ2FsbGJhY2sgaXMgbm90IHNldCwgaXQgYWxsb3dzIHRvOgojICAgLSBjb3B5IHRoZSBkb3dubG9hZGVkIGZpbGUgdG8gdGhlIHJpZ2h0IHRhcmdldCBmaWxlCiMgICAtIGFuZCBzZXQgdGhlIGV4ZWN1dGlvbiBiaXQKIyBlbHNlCiMgICBpbnN0YWxsQ2FsbGJhY2sgaXMgY2FsbGVkIHdpdGggbmV3U29mdHdhcmUsIHRhcmdldEZpbGUsIHZlcnNpb24gYXJndW1lbnRzCiMgZmkKIyBAd2FybmluZyBkbyBub3QgdXNlIHRoaXMgZnVuY3Rpb24gYXMgY2FsbGJhY2sgZm9yIEdpdGh1Yjo6dXBncmFkZVJlbGVhc2Ugb3IgR2l0aHViOjppbnN0YWxsUmVsZWFzZSwgYXMgaXQgd291bGQgcmVzdWx0IHRvIGFuIGluZmluaXRlIGxvb3AKIyBAYXJnICQxIG5ld1NvZnR3YXJlOlN0cmluZyB0aGUgZG93bmxvYWRlZCBzb2Z0d2FyZSBmaWxlCiMgQGFyZyAkMiB0YXJnZXRGaWxlOlN0cmluZyB3aGVyZSB3ZSB3YW50IHRvIGNvcHkgdGhlIGZpbGUKIyBAYXJnICQzIHZlcnNpb246U3RyaW5nIHRoZSB2ZXJzaW9uIHRoYXQgaGFzIGJlZW4gZG93bmxvYWRlZAojIEBhcmcgJDQgaW5zdGFsbENhbGxiYWNrOkZ1bmN0aW9uIChvcHRpb25hbCkgdGhlIGNhbGxiYWNrIHRvIGNhbGwgd2l0aCAzIGZpcnN0IGFyZ3VtZW50cwojIEBlbnYgU1VETyBTdHJpbmcgYWxsb3dzIHRvIHVzZSBjdXN0b20gc3VkbyBwcmVmaXggY29tbWFuZAojIEBleGl0Y29kZSAqIG9uIGZhaWx1cmUKIyBAc2VlIEdpdGh1Yjo6dXBncmFkZVJlbGVhc2UKIyBAc2VlIEdpdGh1Yjo6aW5zdGFsbFJlbGVhc2UKIyBAaW50ZXJuYWwKR2l0aHViOjpkZWZhdWx0SW5zdGFsbCgpIHsKICBsb2NhbCBuZXdTb2Z0d2FyZT0iJDEiCiAgbG9jYWwgdGFyZ2V0RmlsZT0iJDIiCiAgbG9jYWwgdmVyc2lvbj0iJDMiCiAgbG9jYWwgaW5zdGFsbENhbGxiYWNrPSQ0CiAgIyBzaGVsbGNoZWNrIGRpc2FibGU9U0MyMDg2CiAgbWtkaXIgLXAgIiQoZGlybmFtZSAiJHt0YXJnZXRGaWxlfSIpIgogIGlmIFtbICIkKHR5cGUgLXQgIiR7aW5zdGFsbENhbGxiYWNrfSIpIiA9ICJmdW5jdGlvbiIgXV07IHRoZW4KICAgICR7aW5zdGFsbENhbGxiYWNrfSAiJHtuZXdTb2Z0d2FyZX0iICIke3RhcmdldEZpbGV9IiAiJHt2ZXJzaW9ufSIKICBlbHNlCiAgICAke1NVRE86LX0gbXYgIiR7bmV3U29mdHdhcmV9IiAiJHt0YXJnZXRGaWxlfSIKICAgICR7U1VETzotfSBjaG1vZCAreCAiJHt0YXJnZXRGaWxlfSIKICAgIGhhc2ggLXIKICAgICR7U1VETzotfSBybSAtZiAiJHtuZXdTb2Z0d2FyZX0iIHx8IHRydWUKICBmaQp9CgojIEBkZXNjcmlwdGlvbiBnaXRodWIgcmVwb3NpdG9yeSBlZzoga3ViZXJuZXRlcy1zaWdzL2tpbmQKIyBAYXJnICQxIGdpdGh1YlVybDpTdHJpbmcgZWc6IGh0dHBzOi8vZ2l0aHViLmNvbS9rdWJlcm5ldGVzLXNpZ3Mva2luZC9yZWxlYXNlcy9kb3dubG9hZC9AbGF0ZXN0VmVyc2lvbkAva2luZC1saW51eC1hbWQ2NAojIEBleGl0Y29kZSAxIGlmIG5vIG1hdGNoaW5nIHJlcG8gZm91bmQgaW4gcHJvdmlkZWQgdXJsLCAwIG90aGVyd2lzZQojIEBzdGRvdXQgdGhlIHJlcG8gaW4gdGhlIGZvcm0gb3duZXIvcmVwbwpHaXRodWI6OmV4dHJhY3RSZXBvRnJvbUdpdGh1YlVybCgpIHsKICBsb2NhbCBnaXRodWJVcmw9IiQxIgogIGxvY2FsIHJlc3VsdAogIHJlc3VsdD0iJChzZWQgLW4gLUUgJ3MjXmh0dHBzOi8vZ2l0aHViLmNvbS8oW14vXSsvW14vXSspLy4qJCNcMSNwJyA8PDwiJHtnaXRodWJVcmx9IikiCiAgaWYgW1sgLXogIiR7cmVzdWx0fSIgXV07IHRoZW4KICAgIHJldHVybiAxCiAgZmkKICBlY2hvICIke3Jlc3VsdH0iCn0KCiMgQGRlc2NyaXB0aW9uIFJldHJpZXZlIHRoZSBsYXRlc3QgdmVyc2lvbiBudW1iZXIgb2YgYSBnaXRodWIgcmVsZWFzZSB1c2luZyBHaXRodWIgQVBJIHVzaW5nIHJldHJ5CiMgcmVwbyBhcmcgd2l0aCBmY2hhc3RhbmV0L2Jhc2gtdG9vbHMgdmFsdWUgd291bGQgbWF0Y2ggaHR0cHM6Ly9naXRodWIuY29tL2ZjaGFzdGFuZXQvYmFzaC10b29scwojIEBhcmcgJDEgcmVwbzpTdHJpbmcgcmVwb3NpdG9yeSBpbiB0aGUgZm9ybWF0IGZjaGFzdGFuZXQvYmFzaC10b29scwojIEBhcmcgJDIgcmVzdWx0UmVmOiZTdHJpbmcgcmVmZXJlbmNlIHRvIGEgdmFyaWFibGUgdGhhdCB3aWxsIGNvbnRhaW4gdGhlIHJlc3VsdCBvZiB0aGUgY29tbWFuZAojIEBzdGRvdXQgbG9nIG1lc3NhZ2VzIGFib3V0IHJldHJ5CkdpdGh1Yjo6Z2V0TGF0ZXN0UmVsZWFzZSgpIHsKICBsb2NhbCByZXBvPSIkMSIKICAjIHdlIG5lZWQgdG8gcGFzcyB0aGUgcmVzdWx0IHRocm91Z2ggYSByZWZlcmVuY2UgaW5zdGVhZCBvZiBvdXRwdXQgZGlyZWN0bHkKICAjIGJlY2F1c2UgcmV0cnkgY2FuIG91dHB1dCB0b28KICBsb2NhbCAtbiByZXN1bHRSZWY9JDIKICByZXN1bHRSZWY9IiIKICBsb2NhbCByZXN1bHRGaWxlCiAgcmVzdWx0RmlsZT0iJChta3RlbXAgLXAgIiR7VE1QRElSOi0vdG1wfSIgLXQgZ2l0aHViTGF0ZXN0UmVsZWFzZS5YWFhYKSIKICAjIEdldCBsYXRlc3QgcmVsZWFzZSBmcm9tIEdpdEh1YiBhcGkKICBpZiBSZXRyeTo6ZGVmYXVsdCBjdXJsIFwKICAgIC1MIFwKICAgIC1vICIke3Jlc3VsdEZpbGV9IiBcCiAgICAtLWZhaWwgXAogICAgLS1zaWxlbnQgXAogICAgImh0dHBzOi8vYXBpLmdpdGh1Yi5jb20vcmVwb3MvJHtyZXBvfS9yZWxlYXNlcy9sYXRlc3QiOyB0aGVuCiAgICAjIHNoZWxsY2hlY2sgZGlzYWJsZT1TQzIwMzQKICAgIHJlc3VsdFJlZj0iJChWZXJzaW9uOjpnaXRodWJBcGlFeHRyYWN0VmVyc2lvbiA8IiR7cmVzdWx0RmlsZX0iKSIKICAgIHJldHVybiAwCiAgZmkKICAjIGRpc3BsYXkgY3VybCByZXN1bHQgaW4gY2FzZSBvZiBmYWlsdXJlCiAgY2F0ID4mMiAiJHtyZXN1bHRGaWxlfSIKICBybSAtZiAiJHtyZXN1bHRGaWxlfSIKfQoKIyBAZGVzY3JpcHRpb24gRGlzcGxheSBtZXNzYWdlIHVzaW5nIGVycm9yIGNvbG9yIChyZWQpCiMgQGFyZyAkMSBtZXNzYWdlOlN0cmluZyB0aGUgbWVzc2FnZSB0byBkaXNwbGF5CkxvZzo6ZGlzcGxheUVycm9yKCkgewogIGlmICgoQkFTSF9GUkFNRVdPUktfRElTUExBWV9MRVZFTCA+PSBfX0xFVkVMX0VSUk9SKSk7IHRoZW4KICAgIGVjaG8gLWUgIiR7X19FUlJPUl9DT0xPUn1FUlJPUiAgIC0gJHsxfSR7X19SRVNFVF9DT0xPUn0iID4mMgogIGZpCiAgTG9nOjpsb2dFcnJvciAiJDEiCn0KCiMgQGRlc2NyaXB0aW9uIERpc3BsYXkgbWVzc2FnZSB1c2luZyBlcnJvciBjb2xvciAocmVkKSBhbmQgZXhpdCBpbW1lZGlhdGVseSB3aXRoIGVycm9yIHN0YXR1cyAxCiMgQGFyZyAkMSBtZXNzYWdlOlN0cmluZyB0aGUgbWVzc2FnZSB0byBkaXNwbGF5CkxvZzo6ZmF0YWwoKSB7CiAgZWNobyAtZSAiJHtfX0VSUk9SX0NPTE9SfUZBVEFMICAgLSAkezF9JHtfX1JFU0VUX0NPTE9SfSIgPiYyCiAgTG9nOjpsb2dGYXRhbCAiJDEiCiAgZXhpdCAxCn0KCiMgQGRlc2NyaXB0aW9uIGxvZyBtZXNzYWdlIHRvIGZpbGUKIyBAYXJnICQxIG1lc3NhZ2U6U3RyaW5nIHRoZSBtZXNzYWdlIHRvIGRpc3BsYXkKTG9nOjpsb2dEZWJ1ZygpIHsKICBpZiAoKEJBU0hfRlJBTUVXT1JLX0xPR19MRVZFTCA+PSBfX0xFVkVMX0RFQlVHKSk7IHRoZW4KICAgIExvZzo6bG9nTWVzc2FnZSAiJHsyOi1ERUJVR30iICIkMSIKICBmaQp9CgojIEBkZXNjcmlwdGlvbiBsb2cgbWVzc2FnZSB0byBmaWxlCiMgQGFyZyAkMSBtZXNzYWdlOlN0cmluZyB0aGUgbWVzc2FnZSB0byBkaXNwbGF5CkxvZzo6bG9nSW5mbygpIHsKICBpZiAoKEJBU0hfRlJBTUVXT1JLX0xPR19MRVZFTCA+PSBfX0xFVkVMX0lORk8pKTsgdGhlbgogICAgTG9nOjpsb2dNZXNzYWdlICIkezI6LUlORk99IiAiJDEiCiAgZmkKfQoKIyBAZGVzY3JpcHRpb24gYWN0aXZhdGUgb3Igbm90IExvZzo6ZGlzcGxheSogYW5kIExvZzo6bG9nKiBmdW5jdGlvbnMKIyBiYXNlZCBvbiBCQVNIX0ZSQU1FV09SS19ESVNQTEFZX0xFVkVMIGFuZCBCQVNIX0ZSQU1FV09SS19MT0dfTEVWRUwKIyBlbnZpcm9ubWVudCB2YXJpYWJsZXMgbG9hZGVkIGJ5IEVudjo6cmVxdWlyZUxvYWQKIyB0cnkgdG8gY3JlYXRlIGxvZyBmaWxlIGFuZCByb3RhdGUgaXQgaWYgbmVjZXNzYXJ5CiMgQG5vYXJncwojIEBzZXQgQkFTSF9GUkFNRVdPUktfTE9HX0xFVkVMIGludCB0byBPRkYgbGV2ZWwgaWYgQkFTSF9GUkFNRVdPUktfTE9HX0ZJTEUgaXMgZW1wdHkgb3Igbm90IHdyaXRhYmxlCiMgQGVudiBCQVNIX0ZSQU1FV09SS19ESVNQTEFZX0xFVkVMIGludAojIEBlbnYgQkFTSF9GUkFNRVdPUktfTE9HX0xFVkVMIGludAojIEBlbnYgQkFTSF9GUkFNRVdPUktfTE9HX0ZJTEUgU3RyaW5nCiMgQGVudiBCQVNIX0ZSQU1FV09SS19MT0dfRklMRV9NQVhfUk9UQVRJT04gaW50IGRvIGxvZyByb3RhdGlvbiBpZiA+IDAKIyBAZXhpdGNvZGUgMCBhbHdheXMgc3VjY2Vzc2Z1bAojIEBzdGRlcnIgZGlhZ25vc3RpY3MgaW5mb3JtYXRpb24gYWJvdXQgbG9nIGZpbGUgaXMgZGlzcGxheWVkCiMgQHJlcXVpcmUgRW52OjpyZXF1aXJlTG9hZAojIEByZXF1aXJlIFVJOjpyZXF1aXJlVGhlbWUKTG9nOjpyZXF1aXJlTG9hZCgpIHsKICBpZiBbWyAteiAiJHtCQVNIX0ZSQU1FV09SS19MT0dfRklMRTotfSIgXV07IHRoZW4KICAgIEJBU0hfRlJBTUVXT1JLX0xPR19MRVZFTD0ke19fTEVWRUxfT0ZGfQogICAgZXhwb3J0IEJBU0hfRlJBTUVXT1JLX0xPR19MRVZFTAogIGZpCgogIGlmICgoQkFTSF9GUkFNRVdPUktfTE9HX0xFVkVMID4gX19MRVZFTF9PRkYpKTsgdGhlbgogICAgaWYgW1sgISAtZiAiJHtCQVNIX0ZSQU1FV09SS19MT0dfRklMRX0iIF1dOyB0aGVuCiAgICAgIGlmCiAgICAgICAgISBta2RpciAtcCAiJChkaXJuYW1lICIke0JBU0hfRlJBTUVXT1JLX0xPR19GSUxFfSIpIiAyPi9kZXYvbnVsbCB8fAogICAgICAgICAgISB0b3VjaCAtLW5vLWNyZWF0ZSAiJHtCQVNIX0ZSQU1FV09SS19MT0dfRklMRX0iIDI+L2Rldi9udWxsCiAgICAgIHRoZW4KICAgICAgICBCQVNIX0ZSQU1FV09SS19MT0dfTEVWRUw9JHtfX0xFVkVMX09GRn0KICAgICAgICBlY2hvIC1lICIke19fRVJST1JfQ09MT1J9RVJST1IgICAtIEZpbGUgJHtCQVNIX0ZSQU1FV09SS19MT0dfRklMRX0gaXMgbm90IHdyaXRhYmxlJHtfX1JFU0VUX0NPTE9SfSIgPiYyCiAgICAgIGZpCiAgICBlbGlmIFtbICEgLXcgIiR7QkFTSF9GUkFNRVdPUktfTE9HX0ZJTEV9IiBdXTsgdGhlbgogICAgICBCQVNIX0ZSQU1FV09SS19MT0dfTEVWRUw9JHtfX0xFVkVMX09GRn0KICAgICAgZWNobyAtZSAiJHtfX0VSUk9SX0NPTE9SfUVSUk9SICAgLSBGaWxlICR7QkFTSF9GUkFNRVdPUktfTE9HX0ZJTEV9IGlzIG5vdCB3cml0YWJsZSR7X19SRVNFVF9DT0xPUn0iID4mMgogICAgZmkKCiAgZmkKCiAgaWYgKChCQVNIX0ZSQU1FV09SS19MT0dfTEVWRUwgPiBfX0xFVkVMX09GRikpOyB0aGVuCiAgICAjIHdpbGwgYWx3YXlzIGJlIGNyZWF0ZWQgZXZlbiBpZiBub3QgaW4gaW5mbyBsZXZlbAogICAgTG9nOjpsb2dNZXNzYWdlICJJTkZPIiAiTG9nZ2luZyB0byBmaWxlICR7QkFTSF9GUkFNRVdPUktfTE9HX0ZJTEV9IC0gTG9nIGxldmVsICR7QkFTSF9GUkFNRVdPUktfTE9HX0xFVkVMfSIKICAgIGlmICgoQkFTSF9GUkFNRVdPUktfTE9HX0ZJTEVfTUFYX1JPVEFUSU9OID4gMCkpOyB0aGVuCiAgICAgIExvZzo6cm90YXRlICIke0JBU0hfRlJBTUVXT1JLX0xPR19GSUxFfSIgIiR7QkFTSF9GUkFNRVdPUktfTE9HX0ZJTEVfTUFYX1JPVEFUSU9OfSIKICAgIGZpCiAgZmkKfQoKIyBAZGVzY3JpcHRpb24gUmV0cnkgYSBjb21tYW5kIDUgdGltZXMgd2l0aCBhIGRlbGF5IG9mIDE1IHNlY29uZHMgYmV0d2VlbiBlYWNoIGF0dGVtcHQKIyBAYXJnICRAIGNvbW1hbmQ6U3RyaW5nW10gdGhlIGNvbW1hbmQgdG8gcnVuCiMgQGV4aXRjb2RlIDAgb24gc3VjY2VzcwojIEBleGl0Y29kZSAxIGlmIG1heCByZXRyaWVzIGNvdW50IHJlYWNoZWQKUmV0cnk6OmRlZmF1bHQoKSB7CiAgUmV0cnk6OnBhcmFtZXRlcml6ZWQgNSAxNSAiIiAiJEAiCn0KCiMgQGRlc2NyaXB0aW9uIGV4dHJhY3Qgc29mdHdhcmUgdmVyc2lvbiBudW1iZXIKIyBAYXJnICQxIGNvbW1hbmQ6U3RyaW5nIHRoZSBjb21tYW5kIHRoYXQgd2lsbCBiZSBjYWxsZWQgd2l0aCAtLXZlcnNpb24gcGFyYW1ldGVyCiMgQGFyZyAkMiBhcmdWZXJzaW9uOlN0cmluZyAgYWxsb3dzIHRvIG92ZXJyaWRlIGRlZmF1bHQgLS12ZXJzaW9uIHBhcmFtZXRlcgpWZXJzaW9uOjpnZXRDb21tYW5kVmVyc2lvbkZyb21QbGFpblRleHQoKSB7CiAgbG9jYWwgY29tbWFuZD0iJDEiCiAgbG9jYWwgYXJnVmVyc2lvbj0iJHsyOi0tLXZlcnNpb259IgogICIke2NvbW1hbmR9IiAiJHthcmdWZXJzaW9ufSIgMj4mMSB8CiAgICBWZXJzaW9uOjpwYXJzZSAjIGtlZXAgb25seSB2ZXJzaW9uIG51bWJlcnMKfQoKIyBAZGVzY3JpcHRpb24gY2hlY2sgaWYgYW4gZWxlbWVudCBpcyBjb250YWluZWQgaW4gYW4gYXJyYXkKIwojIEBhcmcgJDEgbmVlZGxlOlN0cmluZwojIEBhcmcgJEAgYXJyYXk6U3RyaW5nW10KIyBAZXhpdGNvZGUgMCBpZiBmb3VuZAojIEBleGl0Y29kZSAxIG90aGVyd2lzZQojIEBleGFtcGxlCiMgICBBcnJheTo6Y29udGFpbnMgIiR7bGliUGF0aH0iICIke19fQkFTSF9GUkFNRVdPUktfSU1QT1JURURfRklMRVNbQF19IgpBcnJheTo6Y29udGFpbnMoKSB7CiAgbG9jYWwgZWxlbWVudAogIGZvciBlbGVtZW50IGluICIke0A6Mn0iOyBkbwogICAgW1sgIiR7ZWxlbWVudH0iID0gIiQxIiBdXSAmJiByZXR1cm4gMAogIGRvbmUKICByZXR1cm4gMQp9CgojIEBkZXNjcmlwdGlvbiBjaGVjayBpZiBwYXJhbSBpcyB2YWxpZCBlbWFpbCBhZGRyZXNzCiMgQHdhcm5pbmcgaXQgaXMgYSB2ZXJ5IHNpbXBsZSBjaGVjaywgbm8gUkZDIHZhbGlkYXRpb24KIyBAYXJnICQxIGVtYWlsQWRkcmVzczpTdHJpbmcgdGhlIGZ1bGwgZW1haWwgYWRkcmVzcwojIEBleGl0Y29kZSAxIGlmIGludmFsaWQgZW1haWwgYWRkcmVzcwpBc3NlcnQ6OmVtYWlsQWRkcmVzcygpIHsKICBsb2NhbCBleHBlY3RlZFJlZ2V4cD0iXlxTK0BcUyskIgoKICBbWyAiJDEiID1+ICR7ZXhwZWN0ZWRSZWdleHB9IF1dCn0KCiMgQGRlc2NyaXB0aW9uIGNoZWNrIGlmIGFyZ3VtZW50IHJlc3BlY3RzIDIgb3IgbW9yZSB3b3JkcyBzZXBhcmF0ZWQgYnkgYSBzcGFjZQojIGl0IHN1cHBvcnRzIGFjY2VudHVhdGVkIGNoYXJhY3RlcnMgYW5kIG5hbWVzIHdpdGggaHlwaGVuKC0pCiMgQGFyZyAkMSBmaXJzdE5hbWVMYXN0TmFtZTpTdHJpbmcKIyBAZXhpdGNvZGUgMSBpZiByZWdleHAgbm90IG1hdGNoZXMKIyBAc2VlIGh0dHBzOi8vcmVnZXgxMDEuY29tL3IvSnl5Zk9NLzEKQXNzZXJ0OjpmaXJzdE5hbWVMYXN0TmFtZSgpIHsKICBsb2NhbCByZWdleHA9Il5bXiBdKyhbIF1bXiBdKykrJCIKICBbWyAkMSA9fiAke3JlZ2V4cH0gXV0KfQoKIyBAZGVzY3JpcHRpb24gY2hlY2sgaWYgYXJndW1lbnQgcmVzcGVjdHMgbGRhcCBsb2dpbiBuYW1pbmcgY29udmVudGlvbgojIG9ubHkgdXNpbmcgbG93ZXJjYXNlIGNoYXJhY3RlcnMgYS16CiMgQGFyZyAkMSBsZGFwTG9naW46U3RyaW5nCiMgQGV4aXRjb2RlIDEgaWYgcmVnZXhwIG5vdCBtYXRjaGVzCkFzc2VydDo6bGRhcExvZ2luKCkgewogIFtbICQxID1+IF5bYS16XSskIF1dCn0KCiMgQGRlc2NyaXB0aW9uIGNoZWNrcyBpZiB2YXJpYWJsZSBuYW1lIHByb3ZpZGVkIGV4aXN0cwojIEBhcmcgJDEgdmFyTmFtZTpTdHJpbmcKIyBAZXhpdGNvZGUgMSBpZiB2YXJpYWJsZSBkb2Vzbid0IGV4aXN0CiMgQGV4aXRjb2RlIDIgaWYgdmFyaWFibGUgdmFsdWUgZW1wdHkKIyBAZXhpdGNvZGUgMyBpZiB2YXJpYWJsZSBuYW1lIGludmFsaWQKIyBAc2VlIEFzc2VydDo6dmFsaWRWYXJpYWJsZU5hbWUKIyBAc3RkZXJyIGRpYWdub3N0aWNzIGluZm9ybWF0aW9uIGlzIGRpc3BsYXllZApBc3NlcnQ6OnZhckV4aXN0c0FuZE5vdEVtcHR5KCkgewogIGxvY2FsIHZhck5hbWU9IiQxIgogIGlmICEgQXNzZXJ0Ojp2YWxpZFZhcmlhYmxlTmFtZSAiJHt2YXJOYW1lfSI7IHRoZW4KICAgIExvZzo6ZGlzcGxheUVycm9yICIke3Zhck5hbWV9IC0gaW52YWxpZCB2YXJpYWJsZSBuYW1lIgogICAgcmV0dXJuIDMKICBmaQogIGlmIFtbIC16ICIkeyF2YXJOYW1lK3Vuc2V0fSIgXV07IHRoZW4KICAgIExvZzo6ZGlzcGxheUVycm9yICIke3Zhck5hbWV9IC0gbm90IGRlZmluZWQiCiAgICByZXR1cm4gMQogIGVsaWYgW1sgLXogIiR7IXZhck5hbWV9IiBdXTsgdGhlbgogICAgTG9nOjpkaXNwbGF5RXJyb3IgIiR7dmFyTmFtZX0gLSBwbGVhc2UgcHJvdmlkZSBhIHZhbHVlIgogICAgcmV0dXJuIDIKICBmaQp9CgojIEBkZXNjcmlwdGlvbiBkZXRlcm1pbmUgaWYgdGhlIHNjcmlwdCBpcyBleGVjdXRlZCB1bmRlciBXU0wKIyBjc3BlbGw6ZGlzYWJsZQojIEBleGFtcGxlIHRleHQKIyAgIHVuYW1lIEdpdEJhc2ggd2luZG93cyAod2l0aCB3c2wpID0+IE1JTkdXNjRfTlQtMTAuMCBaT1hGTC02NjE5UU4yIDIuMTAuMCgwLjMyNS81LzMpIDIwMTgtMDYtMTMgMjM6MzQgeDg2XzY0IE1zeXMKIyAgIHVuYW1lIEdpdEJhc2ggd2luZG93cyAod28gd3NsKSAgID0+IE1JTkdXNjRfTlQtMTAuMCBmcnNhMDItajVjYmtjMiAyLjkuMCgwLjMxOC81LzMpIDIwMTgtMDEtMTIgMjM6MzcgeDg2XzY0IE1zeXMKIyAgIHVuYW1lIHdzbCA9PiBMaW51eCBaT1hGTC02NjE5UU4yIDQuNC4wLTE3MTM0LU1pY3Jvc29mdCAjMTEyLU1pY3Jvc29mdCBUaHUgSnVuIDA3IDIyOjU3OjAwIFBTVCAyMDE4IHg4Nl82NCB4ODZfNjQgeDg2XzY0IEdOVS9MaW51eAojIGNzcGVsbDplbmFibGUKIwojIEBleGl0Y29kZSAxIG9uIGVycm9yCkFzc2VydDo6d3NsKCkgewogIFtbICIkKHVuYW1lIC1vKSIgPSAiR05VL0xpbnV4IiBdXQp9CgojIEBkZXNjcmlwdGlvbiBpbnN0YWxscyBmaWxlIHRvIGdpdmVuIGRpcmVjdG9yeQojCiMgY2FsbGJhY2tzIHBhcmFtZXRlcnMgYCR7ZnJvbUZpbGV9ICR7dGFyZ2V0RmlsZX0gJEBgCiMgQGFyZyAkMSBmcm9tRmlsZSAtIG9yaWdpbmFsIGZpbGUgdG8gY29weQojIEBhcmcgJDIgdGFyZ2V0RmlsZSAtIHRhcmdldCBmaWxlCiMgQGFyZyAkMyB1c2VyTmFtZTpTdHJpbmcgKG9wdGlvbmFsKSAoZGVmYXVsdDogJHtVU0VSTkFNRX0pIHRoZSB1c2VyIG5hbWUgdGhhdCB3aWxsIGJlIHVzZWQgdG8gc2V0IHRhcmdldCBmaWxlcyBvd25lcnNoaXAKIyBAYXJnICQ0IHVzZXJHcm91cDpTdHJpbmcgKG9wdGlvbmFsKSAoZGVmYXVsdDogJHtVU0VSTkFNRX0pIHRoZSBncm91cCBuYW1lIHRoYXQgd2lsbCBiZSB1c2VkIHRvIHNldCB0YXJnZXQgZmlsZXMgb3duZXJzaGlwCiMgQGFyZyAkNSBzdWNjZXNzQ2FsbGJhY2s6RnVuY3Rpb24gdGhlIGNhbGxiYWNrIHRvIGNhbGwgd2hlbiBmaWxlIGlzIGluc3RhbGxlZCBzdWNjZXNzZnVsbHksIGJ5IGRlZmF1bHQgc2V0VXNlclJpZ2h0cyBjYWxsYmFjayBpcyBjYWxsZWQKIyBAYXJnICQ2IGZhaWx1cmVDYWxsYmFjazpGdW5jdGlvbiB0aGUgY2FsbGJhY2sgdG8gY2FsbCB3aGVuIGZpbGUgaW5zdGFsbGF0aW9uIGhhcyBmYWlsZWQsIGJ5IGRlZmF1bHQgdW5hYmxlVG9Db3B5Q2FsbGJhY2sgY2FsbGJhY2sgaXMgY2FsbGVkCiMgQGFyZyAkQCBjYWxsYmFja3NQYXJhbXM6U3RyaW5nW10gYWRkaXRpb25hbCBwYXJhbWV0ZXJzIHBhc3NlZCB0byBjYWxsYmFja3MKIyBAZXhpdGNvZGUgMSBpZiBmcm9tRmlsZSBpcyBub3QgcmVhZGFibGUKIyBAZXhpdGNvZGUgMiBpZiBiYWNrdXAgZmlsZSBmYWlsdXJlCiMgQGV4aXRjb2RlIDAgb24gc3VjY2VzcyBvciBpZiBPVkVSV1JJVEVfQ09ORklHX0ZJTEVTPTAKIyBAZXhpdGNvZGUgMCBvbiBzdWNjZXNzIG9yIGlmIENIQU5HRV9XSU5ET1dTX0ZJTEVTPTAgYW5kIHRhcmdldCBmaWxlIGlzIGEgd2luZG93cyBmaWxlCiMgQGVudiBPVkVSV1JJVEVfQ09ORklHX0ZJTEVTIEJvb2xlYW4gKGRlZmF1bHQ6MCkgaWYgMSB3aWxsIG92ZXJ3cml0ZSBleGlzdGluZyBkaXJlY3RvcnkKIyBAZW52IENIQU5HRV9XSU5ET1dTX0ZJTEVTIEJvb2xlYW4gKGRlZmF1bHQ6MCkgaWYgMSBhbmQgdGFyZ2V0IGZpbGUgaXMgaW4gd2luZG93cyBmaWxlIHN5c3RlbSwgb3ZlcndyaXRlIGl0CiMgQGVudiBVU0VSTkFNRSAoZGVmYXVsdDogcm9vdCkgdGhlIHVzZXIgbmFtZSB0aGF0IHdpbGwgYmUgdXNlZCB0byBzZXQgdGFyZ2V0IGZpbGVzIG93bmVyc2hpcAojIEBlbnYgVVNFUkdST1VQIChkZWZhdWx0OiByb290KSB0aGUgZ3JvdXAgbmFtZSB0aGF0IHdpbGwgYmUgdXNlZCB0byBzZXQgdGFyZ2V0IGZpbGVzIG93bmVyc2hpcAojIEBlbnYgQkFTRV9NTlRfQyBTdHJpbmcgd2luZG93cyBDIGRyaXZlIGJhc2UgUEFUSAojIEBlbnYgRlJBTUVXT1JLX1JPT1RfRElSIHVzZWQgdG8gbWFrZSBwYXRocyByZWxhdGl2ZSB0byB0aGlzIGRpcmVjdG9yeSB0byByZWR1Y2UgbGVuZ3RoIG9mIG1lc3NhZ2VzCiMgQGVudiBTVURPIFN0cmluZyBhbGxvd3MgdG8gdXNlIGN1c3RvbSBzdWRvIHByZWZpeCBjb21tYW5kCkluc3RhbGw6OmZpbGUoKSB7CiAgbG9jYWwgZnJvbUZpbGU9IiQxIgogIGxvY2FsIHRhcmdldEZpbGU9IiQyIgogIGxvY2FsIHVzZXJOYW1lPSIkezM6LSR7VVNFUk5BTUU6LXJvb3R9fSIKICBsb2NhbCB1c2VyR3JvdXA9IiR7NDotJHtVU0VSR1JPVVA6LXJvb3R9fSIKICBsb2NhbCBzdWNjZXNzQ2FsbGJhY2s9JHs1Oi1JbnN0YWxsOjpzZXRVc2VyUmlnaHRzQ2FsbGJhY2t9CiAgbG9jYWwgZmFpbHVyZUNhbGxiYWNrPSR7NjotSW5zdGFsbDo6dW5hYmxlVG9Db3B5Q2FsbGJhY2t9CiAgc2hpZnQgNiB8fCB0cnVlCgogIGlmIFtbICEgLWYgIiR7ZnJvbUZpbGV9IiB8fCAhIC1yICIke2Zyb21GaWxlfSIgXV07IHRoZW4KICAgIExvZzo6ZGlzcGxheUVycm9yICJjYW5ub3QgcmVhZCBzb3VyY2UgZmlsZSAnJHtmcm9tRmlsZX0nIgogICAgcmV0dXJuIDEKICBmaQoKICAjIHNraXAgaWYgT1ZFUldSSVRFX0NPTkZJR19GSUxFUyBpcyAwIGFuZCB0YXJnZXQgZmlsZSBleGlzdHMKICBpZiBbWyAiJHtPVkVSV1JJVEVfQ09ORklHX0ZJTEVTfSIgPSAiMCIgJiYgLWYgIiR7dGFyZ2V0RmlsZX0iIF1dOyB0aGVuCiAgICBMb2c6OmRpc3BsYXlXYXJuaW5nICJGaWxlICcke3RhcmdldEZpbGV9JyBleGlzdHMgLSBTa2lwIGluc3RhbGwgKGJlY2F1c2UgT1ZFUldSSVRFX0NPTkZJR19GSUxFUz0wIGluIC5lbnYgZmlsZSkiCiAgICByZXR1cm4gMAogIGZpCgogICMgc2tpcCBpZiBDSEFOR0VfV0lORE9XU19GSUxFUyBpcyAwIGFuZCB0YXJnZXQgZGlyIGlzIGMgZHJpdmUKICBpZiBbWyAiJHtDSEFOR0VfV0lORE9XU19GSUxFU30iID0gIjAiICYmICIke3RhcmdldEZpbGV9IiA9fiBeJHtCQVNFX01OVF9DfSBdXTsgdGhlbgogICAgTG9nOjpkaXNwbGF5V2FybmluZyAiRmlsZSAnJHt0YXJnZXRGaWxlfScgLSBTa2lwIGluc3RhbGwgKGJlY2F1c2UgQ0hBTkdFX1dJTkRPV1NfRklMRVM9MCBpbiAuZW52IGZpbGUpIgogICAgcmV0dXJuIDAKICBmaQoKICBsb2NhbCB0YXJnZXREaXIKICB0YXJnZXREaXI9IiQoZGlybmFtZSAiJHt0YXJnZXRGaWxlfSIpIgogIGlmIFtbICEgLWQgIiR7dGFyZ2V0RGlyfSIgXV07IHRoZW4KICAgICR7U1VETzotfSBta2RpciAtcCAiJHt0YXJnZXREaXJ9IgogICAgJHtTVURPOi19IGNob3duICIke3VzZXJOYW1lfSI6IiR7dXNlckdyb3VwfSIgIiR7dGFyZ2V0RGlyfSIKICBmaQogIGxvY2FsIGZyb21EaXIKICBmcm9tRGlyPSIkKGRpcm5hbWUgIiR7ZnJvbUZpbGV9IikiCiAgbG9jYWwgZnJvbUZpbGVuYW1lCiAgZnJvbUZpbGVuYW1lPSIkKGJhc2VuYW1lICIke2Zyb21GaWxlfSIpIgoKICBCYWNrdXA6OmZpbGUgIiR7dGFyZ2V0RmlsZX0iIHx8IHJldHVybiAyCgogIGlmICR7U1VETzotfSBjcCAiJHtmcm9tRmlsZX0iICIke3RhcmdldEZpbGV9IjsgdGhlbgogICAgJHtzdWNjZXNzQ2FsbGJhY2t9ICIke2Zyb21GaWxlfSIgIiR7dGFyZ2V0RmlsZX0iICIkQCIKICAgIExvZzo6ZGlzcGxheVN1Y2Nlc3MgIkluc3RhbGxlZCBmaWxlICcke2Zyb21EaXIjIiR7RlJBTUVXT1JLX1JPT1RfRElSfS8ifS8ke2Zyb21GaWxlbmFtZX0nIHRvICcke3RhcmdldEZpbGV9JyIKICBlbHNlCiAgICAke2ZhaWx1cmVDYWxsYmFja30gIiR7ZnJvbURpcn0iICIke2Zyb21GaWxlbmFtZX0iICIke3RhcmdldEZpbGV9IiAiJEAiCiAgZmkKfQoKIyBAZGVzY3JpcHRpb24gaW5zdGFsbCBjYWxsYmFjawojICAgc2V0IGZpbGUgd2l0aCByb290IG93bmVyc2hpcAojIEBhcmcgJDEgZnJvbUZpbGU6U3RyaW5nCiMgQGFyZyAkMiB0YXJnZXRGaWxlOlN0cmluZwojIEBleGl0Y29kZSAxIG9uIGFueSBmYWlsdXJlCiMgQGVudiBTVURPIFN0cmluZyBhbGxvd3MgdG8gdXNlIGN1c3RvbSBzdWRvIHByZWZpeCBjb21tYW5kCiMgQHNlZSBJbnN0YWxsOjpmaWxlCkluc3RhbGw6OnNldFVzZXJSb290Q2FsbGJhY2soKSB7CiAgIyBzaGVsbGNoZWNrIGRpc2FibGU9U0MyMDM0ICMgJDEgbm90IHVzZWQKICBsb2NhbCBmcm9tRmlsZT0iJDEiCiAgbG9jYWwgdGFyZ2V0RmlsZT0iJDIiCiAgJHtTVURPOi19IGNob3duIHJvb3Q6cm9vdCAiJHt0YXJnZXRGaWxlfSIKfQoKIyBAZGVzY3JpcHRpb24gYXB0LWdldCBpbnN0YWxsCiMgQGFyZyAkQCBzb2Z0d2FyZXM6U3RyaW5nW10gbGlzdCBvZiBzb2Z0d2FyZXMgdG8gaW5zdGFsbAojIEBmZWF0dXJlIFJldHJ5OjpkZWZhdWx0CiMgTGludXg6OnJlcXVpcmVTdWRvQ29tbWFuZAojIEByZXF1aXJlIExpbnV4OjpyZXF1aXJlVWJ1bnR1CiMgQHN0ZG91dCBkaWFnbm9zdGljcyBsb2dzCkxpbnV4OjpBcHQ6Omluc3RhbGwoKSB7CiAgTG9nOjpkaXNwbGF5SW5mbyAiQXB0IGluc3RhbGwgJCoiCiAgUmV0cnk6OmRlZmF1bHQgc3VkbyBhcHQtZ2V0IGluc3RhbGwgLXkgLXEgIiRAIgp9CgojIEBkZXNjcmlwdGlvbiB1cGRhdGUgYXB0IHBhY2thZ2VzIGxpc3QKIyBAZmVhdHVyZSBSZXRyeTo6ZGVmYXVsdAojIExpbnV4OjpyZXF1aXJlU3Vkb0NvbW1hbmQKIyBAcmVxdWlyZSBMaW51eDo6cmVxdWlyZVVidW50dQojIEBzdGRvdXQgZGlhZ25vc3RpY3MgbG9ncwpMaW51eDo6QXB0Ojp1cGRhdGUoKSB7CiAgTG9nOjpkaXNwbGF5SW5mbyAiQXB0IHVwZGF0ZSAuLi4iCiAgUmV0cnk6OmRlZmF1bHQgc3VkbyBhcHQtZ2V0IHVwZGF0ZSAteSAtLWZpeC1taXNzaW5nIC1vIEFjcXVpcmU6OkZvcmNlSVB2ND10cnVlCn0KCiMgQGRlc2NyaXB0aW9uIHJldHJpZXZlIHBhdGggZnJvbSB3c2x2YXIgYW5kIHRoZW4gdXNlIHdzbHBhdGggdG8gcmVzb2x2ZSBpdAojIHVzaW5nIGNhY2hlIChjYWNoZSBpcyByZWZyZXNoZWQgZXZlcnkgZGF5KQojIEBhcmcgJDEgdmFyOlN0cmluZyB0aGUgdmFyIHRvIHJldHJpZXZlIHVzaW5nIHdzbHZhcgojIEBhcmcgJEAgYXJnczpTdHJpbmdbXSAob3B0aW9uYWwpIGFkZGl0aW9uYWwgYXJndW1lbnRzIHRvIHBhc3MgdG8gd3NsdmFyCiMgQGVudiBXU0xfVE1QRElSIFN0cmluZyB0ZW1wIGRpcmVjdG9yeSB0byBzdG9yZSB0aGUgd3NscGF0aCBjYWNoZSAoZGVmYXVsdCB2YWx1ZTogVE1QRElSKSwgeW91IGNhbiB1c2UgUEVSU0lTVEVOVF9UTVBESVIgaW5zdGVhZAojIEBleGl0Y29kZSAqIGlmIExpbnV4OjpXc2w6Om9yaWdpbmFsV3NscGF0aCBjYW5ub3QgZmluZCB0aGUgcGF0aCBvciBMaW51eDo6V3NsOjpvcmlnaW5hbFdzbHZhciBjYW5ub3QgZmluZCB0aGUgdmFyCiMgQHN0ZGVyciBkaWFnbm9zdGljcyBpbmZvcm1hdGlvbiBpcyBkaXNwbGF5ZWQKIyBAcmVxdWlyZSBMaW51eDo6V3NsOjpyZXF1aXJlV3NsCiMgQGZlYXR1cmUgY2FjaGUKTGludXg6OldzbDo6Y2FjaGVkV3NscGF0aEZyb21Xc2xWYXIoKSB7CiAgbG9jYWwgdmFyPSIkMSIKICBzaGlmdCB8fCB0cnVlCiAgbG9jYWwgdmFsdWUKICB2YWx1ZT0iJChMaW51eDo6V3NsOjpjYWNoZWRXc2x2YXIgIiR7dmFyfSIgIiRAIikiIHx8IHJldHVybiAxCiAgTGludXg6OldzbDo6Y2FjaGVkV3NscGF0aCAiJHt2YWx1ZX0iIHx8IHJldHVybiAxCn0KCiMgQGRlc2NyaXB0aW9uIHJldHJpZXZlIHdzbHZhciB1c2luZyBjYWNoZSAoY2FjaGUgaXMgcmVmcmVzaGVkIGV2ZXJ5IGRheSkKIyBAYXJnICRAIGFyZ3M6U3RyaW5nW10gYXJndW1lbnRzIHRvIHBhc3MgdG8gd3NsdmFyCiMgQGVudiBXU0xfVE1QRElSIFN0cmluZyB0ZW1wIGRpcmVjdG9yeSB0byBzdG9yZSB0aGUgd3NsdmFyIGNhY2hlIChkZWZhdWx0IHZhbHVlOiBUTVBESVIpLCB5b3UgY2FuIHVzZSBQRVJTSVNURU5UX1RNUERJUiBpbnN0ZWFkCiMgQGV4aXRjb2RlICogaWYgTGludXg6OldzbDo6b3JpZ2luYWxXc2x2YXIgY2Fubm90IGZpbmQgdGhlIHZhcmlhYmxlCiMgQHN0ZGVyciBkaWFnbm9zdGljcyBpbmZvcm1hdGlvbiBpcyBkaXNwbGF5ZWQKIyBAcmVxdWlyZSBMaW51eDo6V3NsOjpyZXF1aXJlV3NsCiMgQGZlYXR1cmUgY2FjaGUKTGludXg6OldzbDo6Y2FjaGVkV3NsdmFyKCkgewogIGxvY2FsIHRlbXBFbnZGaWxlCiAgdGVtcEVudkZpbGU9IiR7V1NMX1RNUERJUjotJHtQRVJTSVNURU5UX1RNUERJUjotL3RtcH19L2Jhc2hfdG9vbHNfd3NsdmFyXyQoaWQgLXVuKSIKCiAgQ2FjaGU6OmdldFByb3BlcnR5VmFsdWUgIiR7dGVtcEVudkZpbGV9IiAiJDEiIExpbnV4OjpXc2w6Om9yaWdpbmFsV3NsdmFyICIkQCIKfQoKIyBAZGVzY3JpcHRpb24gbG9nIG1lc3NhZ2UgdG8gZmlsZQojIEBhcmcgJDEgbWVzc2FnZTpTdHJpbmcgdGhlIG1lc3NhZ2UgdG8gZGlzcGxheQpMb2c6OmxvZ0Vycm9yKCkgewogIGlmICgoQkFTSF9GUkFNRVdPUktfTE9HX0xFVkVMID49IF9fTEVWRUxfRVJST1IpKTsgdGhlbgogICAgTG9nOjpsb2dNZXNzYWdlICIkezI6LUVSUk9SfSIgIiQxIgogIGZpCn0KCiMgQGRlc2NyaXB0aW9uIGxvZyBtZXNzYWdlIHRvIGZpbGUKIyBAYXJnICQxIG1lc3NhZ2U6U3RyaW5nIHRoZSBtZXNzYWdlIHRvIGRpc3BsYXkKTG9nOjpsb2dGYXRhbCgpIHsKICBMb2c6OmxvZ01lc3NhZ2UgIiR7MjotRkFUQUx9IiAiJDEiCn0KCiMgQGRlc2NyaXB0aW9uIEludGVybmFsOiBjb21tb24gbG9nIG1lc3NhZ2UKIyBAZXhhbXBsZSB0ZXh0CiMgICBbZGF0ZV18W2xldmVsTXNnXXxtZXNzYWdlCiMKIyBAZXhhbXBsZSB0ZXh0CiMgICAyMDIwLTAxLTE5IDE5OjIwOjIxfEVSUk9SICB8bG9nIGVycm9yCiMgICAyMDIwLTAxLTE5IDE5OjIwOjIxfFNLSVBQRUR8bG9nIHNraXBwZWQKIwojIEBhcmcgJDEgbGV2ZWxNc2c6U3RyaW5nIG1lc3NhZ2UncyBsZXZlbCBkZXNjcmlwdGlvbiAoZWc6IFNUQVRVUywgRVJST1IsIC4uLikKIyBAYXJnICQyIG1zZzpTdHJpbmcgdGhlIG1lc3NhZ2UgdG8gZGlzcGxheQojIEBlbnYgQkFTSF9GUkFNRVdPUktfTE9HX0ZJTEUgU3RyaW5nIGxvZyBmaWxlIHRvIHVzZSwgZG8gbm90aGluZyBpZiBlbXB0eQojIEBlbnYgQkFTSF9GUkFNRVdPUktfTE9HX0xFVkVMIGludCBsb2cgbGV2ZWwgbG9nIG9ubHkgaWYgPiBPRkYgb3IgZmF0YWwgbWVzc2FnZXMKIyBAc3RkZXJyIGRpYWdub3N0aWNzIGluZm9ybWF0aW9uIGlzIGRpc3BsYXllZAojIEByZXF1aXJlIEVudjo6cmVxdWlyZUxvYWQKIyBAcmVxdWlyZSBMb2c6OnJlcXVpcmVMb2FkCkxvZzo6bG9nTWVzc2FnZSgpIHsKICBsb2NhbCBsZXZlbE1zZz0iJDEiCiAgbG9jYWwgbXNnPSIkMiIKICBsb2NhbCBkYXRlCgogIGlmIFtbIC1uICIke0JBU0hfRlJBTUVXT1JLX0xPR19GSUxFfSIgXV0gJiYgKChCQVNIX0ZSQU1FV09SS19MT0dfTEVWRUwgPiBfX0xFVkVMX09GRikpOyB0aGVuCiAgICBkYXRlPSIkKGRhdGUgJyslWS0lbS0lZCAlSDolTTolUycpIgogICAgdG91Y2ggIiR7QkFTSF9GUkFNRVdPUktfTE9HX0ZJTEV9IgogICAgcHJpbnRmICIlc3wlN3N8JXNcbiIgIiR7ZGF0ZX0iICIke2xldmVsTXNnfSIgIiR7bXNnfSIgPj4iJHtCQVNIX0ZSQU1FV09SS19MT0dfRklMRX0iCiAgZmkKfQoKIyBAZGVzY3JpcHRpb24gVG8gYmUgY2FsbGVkIGJlZm9yZSBsb2dnaW5nIGluIHRoZSBsb2cgZmlsZQojIEBhcmcgJDEgZmlsZTpzdHJpbmcgbG9nIGZpbGUgbmFtZQojIEBhcmcgJDIgbWF4TG9nRmlsZXNDb3VudDppbnQgbWF4aW11bSBudW1iZXIgb2YgbG9nIGZpbGVzCkxvZzo6cm90YXRlKCkgewogIGxvY2FsIGZpbGU9IiQxIgogIGxvY2FsIG1heExvZ0ZpbGVzQ291bnQ9IiR7MjotNX0iCgogIGlmIFtbICEgLWYgIiR7ZmlsZX0iIF1dOyB0aGVuCiAgICBMb2c6OmRpc3BsYXlTa2lwcGVkICJMb2cgZmlsZSAke2ZpbGV9IGRvZXNuJ3QgZXhpc3QgeWV0IgogICAgcmV0dXJuIDAKICBmaQogIGxvY2FsIGkKICBmb3IgKChpID0gbWF4TG9nRmlsZXNDb3VudCAtIDE7IGkgPiAwOyBpLS0pKTsgZG8KICAgIExvZzo6ZGlzcGxheUluZm8gIkxvZyByb3RhdGlvbiAke2ZpbGV9LiR7aX0gdG8gJHtmaWxlfS4kKChpICsgMSkpIgogICAgbXYgIiR7ZmlsZX0uInsiJHtpfSIsIiQoKGkgKyAxKSkifSAmPi9kZXYvbnVsbCB8fCB0cnVlCiAgZG9uZQogIGlmIGNwICIke2ZpbGV9IiAiJHtmaWxlfS4xIiAmPi9kZXYvbnVsbDsgdGhlbgogICAgZWNobyA+IiR7ZmlsZX0iICMgcmVzZXQgbG9nIGZpbGUKICAgIExvZzo6ZGlzcGxheUluZm8gIkxvZyByb3RhdGlvbiAke2ZpbGV9IHRvICR7ZmlsZX0uMSIKICBmaQp9CgojIEBkZXNjcmlwdGlvbiBSZXRyeSBhIGNvbW1hbmQgc2V2ZXJhbCB0aW1lcyBkZXBlbmRpbmcgb24gcGFyYW1ldGVycwojIEBhcmcgJDEgbWF4UmV0cmllczppbnQgICAgJDEgbWF4IHJldHJpZXMKIyBAYXJnICQyIGRlbGF5OmludCBiZXR3ZWVuIGF0dGVtcHQKIyBAYXJnICQzIG1lc3NhZ2U6U3RyaW5nIHRvIGRpc3BsYXkgdG8gZGVzY3JpYmUgdGhlIGF0dGVtcHQKIyBAYXJnICRAIHJlc3Qgb2YgcGFyYW1ldGVycywgdGhlIGNvbW1hbmQgdG8gcnVuCiMgQGV4aXRjb2RlIDAgb24gc3VjY2VzcwojIEBleGl0Y29kZSAxIGlmIG1heCByZXRyaWVzIGNvdW50IHJlYWNoZWQKIyBAZXhpdGNvZGUgMiBpZiBtYXhSZXRyaWVzIGludmFsaWQgdmFsdWUKUmV0cnk6OnBhcmFtZXRlcml6ZWQoKSB7CiAgbG9jYWwgbWF4UmV0cmllcz0kMQogIHNoaWZ0IHx8IHRydWUKICBsb2NhbCBkZWxheUJldHdlZW5Ucmllcz0kMQogIHNoaWZ0IHx8IHRydWUKICBsb2NhbCBtZXNzYWdlPSIkMSIKICBzaGlmdCB8fCB0cnVlCiAgbG9jYWwgcmV0cmllc0NvdW50PTEKICBpZiBbWyAiJHttYXhSZXRyaWVzfSIgLWx0IDEgXV07IHRoZW4KICAgIExvZzo6ZGlzcGxheUVycm9yICJpbnZhbGlkIG1heFJldHJ5IHZhbHVlIgogICAgcmV0dXJuIDIKICBmaQoKICB3aGlsZSB0cnVlOyBkbwogICAgTG9nOjpkaXNwbGF5SW5mbyAiQXR0ZW1wdCAke3JldHJpZXNDb3VudH0vJHttYXhSZXRyaWVzfTogJHttZXNzYWdlfSIKICAgIGlmICIkQCI7IHRoZW4KICAgICAgYnJlYWsKICAgIGVsaWYgW1sgIiR7cmV0cmllc0NvdW50fSIgLWx0ICIke21heFJldHJpZXN9IiBdXTsgdGhlbgogICAgICBMb2c6OmRpc3BsYXlXYXJuaW5nICJDb21tYW5kIGZhaWxlZC4gV2FpdCBmb3IgJHtkZWxheUJldHdlZW5Ucmllc30gc2Vjb25kcyIKICAgICAgKChyZXRyaWVzQ291bnQrKykpCiAgICAgIHNsZWVwICIke2RlbGF5QmV0d2VlblRyaWVzfSIKICAgIGVsc2UKICAgICAgTG9nOjpkaXNwbGF5RXJyb3IgIlRoZSBjb21tYW5kIGhhcyBmYWlsZWQgYWZ0ZXIgJHtyZXRyaWVzQ291bnR9IGF0dGVtcHRzLiIKICAgICAgcmV0dXJuIDEKICAgIGZpCiAgZG9uZQogIHJldHVybiAwCn0KCiMgQGRlc2NyaXB0aW9uIGV4dHJhY3QgdmVyc2lvbiBudW1iZXIgZnJvbSBnaXRodWIgYXBpCiMgQG5vYXJncwojIEBzdGRpbiBqc29uIHJlc3VsdCBvZiBnaXRodWIgQVBJCiMgQGV4aXRjb2RlIDEgaWYganEgb3IgVmVyc2lvbjo6cGFyc2UgZmFpbHMKIyBAc3Rkb3V0IHRoZSB2ZXJzaW9uIHBhcnNlZAojIEByZXF1aXJlIExpbnV4OjpyZXF1aXJlSnFDb21tYW5kClZlcnNpb246OmdpdGh1YkFwaUV4dHJhY3RWZXJzaW9uKCkgewogIGpxIC1yICIudGFnX25hbWUiCn0KCiMgQGRlc2NyaXB0aW9uIGZpbHRlciB0byBrZWVwIG9ubHkgdmVyc2lvbiBudW1iZXIgZnJvbSBhIHN0cmluZwojIEBhcmcgJEAgZmlsZXM6U3RyaW5nW10gdGhlIGZpbGVzIHRvIGZpbHRlcgojIEBleGl0Y29kZSAqIGlmIG9uZSBvZiB0aGUgZmlsdGVyIGNvbW1hbmQgZmFpbHMKIyBAc3RkaW4geW91IGNhbiB1c2Ugc3RkaW4gYXMgYWx0ZXJuYXRpdmUgdG8gZmlsZXMgYXJndW1lbnQKIyBAc3Rkb3V0IHRoZSBmaWx0ZXJlZCBjb250ZW50CiMgc2hlbGxjaGVjayBkaXNhYmxlPVNDMjEyMApWZXJzaW9uOjpwYXJzZSgpIHsKICBzZWQgLUVuICdzL1teMC05XSooKFswLTldK1wuKSpbMC05XSspLiovXDEvcCcgIiRAIiB8IGhlYWQgLW4xCn0KCiMgQGRlc2NyaXB0aW9uIGVuc3VyZSBlbnYgZmlsZXMgYXJlIGxvYWRlZAojIEBhcmcgJEAgbGlzdCBvZiBkZWZhdWx0IGZpbGVzIHRvIGxvYWQgYXQgdGhlIGVuZAojIEBleGl0Y29kZSAxIGlmIG9uZSBvZiBlbnYgZmlsZXMgZmFpbHMgdG8gbG9hZAojIEBzdGRlcnIgZGlhZ25vc3RpY3MgaW5mb3JtYXRpb24gaXMgZGlzcGxheWVkCiMgc2hlbGxjaGVjayBkaXNhYmxlPVNDMjEyMApFbnY6OnJlcXVpcmVMb2FkKCkgewogIGxvY2FsIC1hIGRlZmF1bHRGaWxlcz0oIiRAIikKICAjIGdldCBsaXN0IG9mIHBvc3NpYmxlIGNvbmZpZyBmaWxlcwogIGxvY2FsIC1hIGNvbmZpZ0ZpbGVzPSgpCiAgaWYgW1sgLW4gIiR7QkFTSF9GUkFNRVdPUktfRU5WX0ZJTEVTWzBdKzF9IiBdXTsgdGhlbgogICAgIyBCQVNIX0ZSQU1FV09SS19FTlZfRklMRVMgaXMgYW4gYXJyYXkKICAgIGNvbmZpZ0ZpbGVzKz0oIiR7QkFTSF9GUkFNRVdPUktfRU5WX0ZJTEVTW0BdfSIpCiAgZmkKICBpZiBbWyAtZiAiJChwd2QpLy5mcmFtZXdvcmstY29uZmlnIiBdXTsgdGhlbgogICAgY29uZmlnRmlsZXMrPSgiJChwd2QpLy5mcmFtZXdvcmstY29uZmlnIikKICBmaQogIGlmIFtbIC1mICIke0ZSQU1FV09SS19ST09UX0RJUn0vLmZyYW1ld29yay1jb25maWciIF1dOyB0aGVuCiAgICBjb25maWdGaWxlcys9KCIke0ZSQU1FV09SS19ST09UX0RJUn0vLmZyYW1ld29yay1jb25maWciKQogIGZpCiAgY29uZmlnRmlsZXMrPSgiJHtvcHRpb25FbnZGaWxlc1tAXX0iKQogIGNvbmZpZ0ZpbGVzKz0oIiR7ZGVmYXVsdEZpbGVzW0BdfSIpCgogIGZvciBmaWxlIGluICIke2NvbmZpZ0ZpbGVzW0BdfSI7IGRvCiAgICAjIHNoZWxsY2hlY2sgc291cmNlPS8uZnJhbWV3b3JrLWNvbmZpZwogICAgQ1VSUkVOVF9MT0FERURfRU5WX0ZJTEU9IiR7ZmlsZX0iIHNvdXJjZSAiJHtmaWxlfSIgfHwgewogICAgICBMb2c6OmRpc3BsYXlFcnJvciAid2hpbGUgbG9hZGluZyBjb25maWcgZmlsZTogJHtmaWxlfSIKICAgICAgcmV0dXJuIDEKICAgIH0KICBkb25lCn0KCiMgQGRlc2NyaXB0aW9uIGxvYWQgY29sb3IgdGhlbWUKIyBAbm9hcmdzCiMgQGVudiBCQVNIX0ZSQU1FV09SS19USEVNRSBTdHJpbmcgdGhlbWUgdG8gdXNlCiMgQGVudiBMT0FEX1RIRU1FIGludCAwIHRvIGF2b2lkIGxvYWRpbmcgdGhlbWUKIyBAZXhpdGNvZGUgMCBhbHdheXMgc3VjY2Vzc2Z1bApVSTo6cmVxdWlyZVRoZW1lKCkgewogIGlmIFtbICIke0xPQURfVEhFTUU6LTF9IiA9ICIxIiBdXTsgdGhlbgogICAgVUk6OnRoZW1lICIke0JBU0hfRlJBTUVXT1JLX1RIRU1FLWRlZmF1bHR9IgogIGZpCn0KCiMgQGRlc2NyaXB0aW9uIGNoZWNrIGlmIGFyZ3VtZW50IHJlc3BlY3RzIHRoaXMgZnJhbWV3b3JrIHZhcmlhYmxlIG5hbWluZyBjb252ZW50aW9uCiMgLSBpZiB2YXJpYWJsZSBiZWdpbnMgd2l0aCBhbiB1cHBlcmNhc2Ugb3IgdW5kZXJzY29yZSwgZm9sbG93aW5nIGxldHRlcnMgaGF2ZSB0byBiZSB1cHBlcmNhc2Ugb3IgdW5kZXJzY29yZQojIC0gdmFyaWFibGUgbmFtZSBjYW4gaW5jbHVkZXMgJzonIG9yICdfJyBvciBkaWdpdHMgYnV0IG5vdCBhcyBmaXJzdCBsZXR0ZXIKIyBoZXJlIHZhbGlkIHZhcmlhYmxlIG5hbWUgZXhhbXBsZXMKIwojIEBhcmcgJDEgdmFyaWFibGVOYW1lOlN0cmluZwojIEBleGl0Y29kZSAxIGlmIHJlZ2V4cCBub3QgbWF0Y2hlcwojIEBzZWUgaHR0cHM6Ly9yZWdleDEwMS5jb20vci9CVWxQWFMvMQpBc3NlcnQ6OnZhbGlkVmFyaWFibGVOYW1lKCkgewogIGVjaG8gIiQxIiB8IExDX0FMTD1QT1NJWCBncmVwIC1FIC1xICcoXlthLXpdW0EtWmEtel8wLTk6XSskKXwoXltBLVpfXVtBLVpfMC05Ol0rJCknCn0KCiMgQGRlc2NyaXB0aW9uIEJhY2t1cCBnaXZlbiBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeSBhcHBlbmRpbmcgXyBmb2xsb3dlZCBieSB0aGUgY3VycmVudCBkYXRlCiMgQGFyZyAkMSBmaWxlOlN0cmluZyB0aGUgZmlsZSB0byBiYWNrdXAKIyBAc3RkZXJyIG1lc3NhZ2VzIGFib3V0IGJhY2t1cCBmaWxlIGxvY2F0aW9uCiMgQGVudiBTVURPIFN0cmluZyBhbGxvd3MgdG8gdXNlIGN1c3RvbSBzdWRvIHByZWZpeCBjb21tYW5kCiMgQGV4aXRjb2RlIDEgb24gY29weSBmYWlsdXJlCkJhY2t1cDo6ZmlsZSgpIHsKICBsb2NhbCBmaWxlPSIkMSIKICBsb2NhbCBiYWNrdXBGaWxlCiAgaWYgW1sgLWYgIiR7ZmlsZX0iIF1dOyB0aGVuCiAgICBiYWNrdXBGaWxlPSIke2ZpbGV9XyQoZGF0ZSArIiVZLSVtLSVkXyVIOiVNOiVTIikiCiAgICBMb2c6OmRpc3BsYXlJbmZvICJCYWNrdXAgZmlsZSAnJHtmaWxlfScgdG8gJHtiYWNrdXBGaWxlfSIKICAgICR7U1VETzotfSBjcCAiJHtmaWxlfSIgIiR7YmFja3VwRmlsZX0iCiAgZmkKfQoKIyBAZGVzY3JpcHRpb24gZ2V0IHByb3BlcnR5IHZhbHVlIGZyb20gZmlsZQojIGlmIG5vdCBwcmVzZW50IGNvbXB1dGUgaXQgdXNpbmcgcHJvcGVydHlOb3RGb3VuZENhbGxiYWNrIChpZiBwcm92aWRlZCkgYW5kIHN0b3JlIGl0IGluIHByb3BlcnR5IGZpbGUKIyBAYXJnICQxIHByb3BlcnR5RmlsZTpTdHJpbmcgdGhlIGZpbGUgaW4gd2hpY2ggdGhlIHByb3BlcnR5IHdpbGwgYmUgc2VhcmNoZWQKIyBAYXJnICQyIGtleTpTdHJpbmcgdGhlIHByb3BlcnR5IGtleSB0byBzZWFyY2ggaW4gcHJvcGVydHkgZmlsZQojIEBhcmcgJDMgcHJvcGVydHlOb3RGb3VuZENhbGxiYWNrOkZ1bmN0aW9uIChvcHRpb25hbCkgYSBjYWxsYmFjayB0byBjYWxsIGlmIHByb3BlcnR5IGtleSBpcyBub3QgZm91bmQgaW4gcHJvcGVydHkgZmlsZQojIEBhcmcgJEAgYXJnczpTdHJpbmdbXSAob3B0aW9uYWwpIHRoZSBhcmd1bWVudHMgdG8gcGFzcyB0byB0aGUgcHJvcGVydHlOb3RGb3VuZENhbGxiYWNrCiMgQGV4aXRjb2RlIDEgaWYgdmFsdWUgaXMgbm90IGZvdW5kCiMgQGV4aXRjb2RlICogaWYgcHJvcGVydHlOb3RGb3VuZENhbGxiYWNrIGZhaWxzCiMgQHN0ZG91dCB0aGUgcHJvcGVydHkgdmFsdWUgZ2l2ZW4gYnkgcHJvcGVydHkgZmlsZSBvciBieSB0aGUgcHJvcGVydHlOb3RGb3VuZENhbGxiYWNrCkNhY2hlOjpnZXRQcm9wZXJ0eVZhbHVlKCkgewogIGxvY2FsIHZhbHVlCiAgbG9jYWwgcHJvcGVydHlGaWxlPSIkMSIKICBzaGlmdCB8fCB0cnVlCiAgbG9jYWwga2V5CiAga2V5PSIkKGVjaG8gLUUgIiQxIiB8IHNlZCAtRSAncyNcXCMvI2cnKSIKICBzaGlmdCB8fCB0cnVlCiAgbG9jYWwgcHJvcGVydHlOb3RGb3VuZENhbGxiYWNrPSQxCiAgc2hpZnQgfHwgdHJ1ZQoKICBpZiBncmVwIC1FICJeJHtrZXl9PS4qIiAiJHtwcm9wZXJ0eUZpbGV9IiAmPi9kZXYvbnVsbDsgdGhlbgogICAgZ3JlcCAtRSAiXiR7a2V5fT0iICIke3Byb3BlcnR5RmlsZX0iIHwgY3V0IC1kJz0nIC1mMgogICAgcmV0dXJuIDAKICBlbGlmIFtbICIkKHR5cGUgLXQgIiR7cHJvcGVydHlOb3RGb3VuZENhbGxiYWNrfSIpIiA9ICJmdW5jdGlvbiIgXV07IHRoZW4KICAgIHZhbHVlPSIkKCIke3Byb3BlcnR5Tm90Rm91bmRDYWxsYmFja30iICIkQCIpIiB8fCByZXR1cm4gJD8KICAgIGlmIFtbIC1uICIke3ZhbHVlfSIgXV07IHRoZW4KICAgICAgZWNobyAtRSAiJHtrZXl9PSR7dmFsdWV9IiA+PiIke3Byb3BlcnR5RmlsZX0iCiAgICBmaQogICAgZWNobyAtRSAiJHt2YWx1ZX0iCiAgICByZXR1cm4gMAogIGZpCiAgcmV0dXJuIDEKfQoKIyBAZGVzY3JpcHRpb24gaW5zdGFsbCBjYWxsYmFjawojICAgc2V0IGZpbGUgd2l0aCByb290IG93bmVyc2hpcCBhbmQgZXhlY3V0aW9uIGJpdAojIEBhcmcgJDEgZnJvbUZpbGU6U3RyaW5nCiMgQGFyZyAkMiB0YXJnZXRGaWxlOlN0cmluZwojIEBhcmcgJDMgdXNlck5hbWU6U3RyaW5nIChvcHRpb25hbCkgKGRlZmF1bHQ6ICR7VVNFUk5BTUV9KSB0aGUgdXNlciBuYW1lIHRoYXQgd2lsbCBiZSB1c2VkIHRvIHNldCB0YXJnZXQgZmlsZXMgb3duZXJzaGlwCiMgQGFyZyAkNCB1c2VyR3JvdXA6U3RyaW5nIChvcHRpb25hbCkgKGRlZmF1bHQ6ICR7VVNFUk5BTUV9KSB0aGUgZ3JvdXAgbmFtZSB0aGF0IHdpbGwgYmUgdXNlZCB0byBzZXQgdGFyZ2V0IGZpbGVzIG93bmVyc2hpcAojIEBlbnYgVVNFUk5BTUUgKGRlZmF1bHQ6IHJvb3QpIHRoZSB1c2VyIG5hbWUgdGhhdCB3aWxsIGJlIHVzZWQgdG8gc2V0IHRhcmdldCBmaWxlcyBvd25lcnNoaXAKIyBAZW52IFVTRVJHUk9VUCAoZGVmYXVsdDogcm9vdCkgdGhlIGdyb3VwIG5hbWUgdGhhdCB3aWxsIGJlIHVzZWQgdG8gc2V0IHRhcmdldCBmaWxlcyBvd25lcnNoaXAKIyBAZW52IFNVRE8gU3RyaW5nIGFsbG93cyB0byB1c2UgY3VzdG9tIHN1ZG8gcHJlZml4IGNvbW1hbmQKIyBAZXhpdGNvZGUgMSBvbiBhbnkgZmFpbHVyZQojIEBzZWUgSW5zdGFsbDo6ZmlsZQpJbnN0YWxsOjpzZXRVc2VyUmlnaHRzQ2FsbGJhY2soKSB7CiAgIyBzaGVsbGNoZWNrIGRpc2FibGU9U0MyMDM0ICMgJDEgbm90IHVzZWQKICBsb2NhbCBmcm9tRmlsZT0iJDEiCiAgbG9jYWwgdGFyZ2V0RmlsZT0iJDIiCiAgbG9jYWwgdXNlck5hbWU9IiR7MzotJHtVU0VSTkFNRTotcm9vdH19IgogIGxvY2FsIHVzZXJHcm91cD0iJHs0Oi0ke1VTRVJHUk9VUDotcm9vdH19IgoKICAke1NVRE86LX0gY2hvd24gIiR7dXNlck5hbWV9IjoiJHt1c2VyR3JvdXB9IiAiJHt0YXJnZXRGaWxlfSIKfQoKIyBAZGVzY3JpcHRpb24gaW5zdGFsbCBjYWxsYmFjawojICAgZGVmYXVsdCBjYWxsYmFjayB1c2VkIGNhbGxlZCB3aGVuIGZpbGUgY29weSBoYXMgZmFpbGVkCiMgQGFyZyAkMSBmcm9tRmlsZTpTdHJpbmcKIyBAYXJnICQyIHRhcmdldEZpbGU6U3RyaW5nCiMgQGVudiBGUkFNRVdPUktfUk9PVF9ESVIgdXNlZCB0byBtYWtlIHBhdGhzIHJlbGF0aXZlIHRvIHRoaXMgZGlyZWN0b3J5IHRvIHJlZHVjZSBsZW5ndGggb2YgbWVzc2FnZXMKIyBAZXhpdGNvZGUgMSBhbHdheXMgZmFpbAojIEBzdGRlcnIgZGlhZ25vc3RpY3MgaW5mb3JtYXRpb24gaXMgZGlzcGxheWVkCiMgQHNlZSBJbnN0YWxsOjpmaWxlCkluc3RhbGw6OnVuYWJsZVRvQ29weUNhbGxiYWNrKCkgewogIGxvY2FsIGZyb21EaXI9IiQxIgogIGxvY2FsIGZpbGVOYW1lPSIkMiIKICBsb2NhbCB0YXJnZXRGaWxlPSIkMyIKICBMb2c6OmZhdGFsICJ1bmFibGUgdG8gY29weSBmaWxlICcke2Zyb21EaXIjIiR7RlJBTUVXT1JLX1JPT1RfRElSfS8ifS8ke2ZpbGVOYW1lfScgdG8gJyR7dGFyZ2V0RmlsZX0nIgp9CgojIEBkZXNjcmlwdGlvbiByZXRyaWV2ZSB3c2xwYXRoIHVzaW5nIGNhY2hlIChjYWNoZSBpcyByZWZyZXNoZWQgZXZlcnkgZGF5KQojIEBhcmcgJEAgYXJnczpTdHJpbmdbXSBhcmd1bWVudHMgdG8gcGFzcyB0byB3c2xwYXRoCiMgQGVudiBXU0xfVE1QRElSIFN0cmluZyB0ZW1wIGRpcmVjdG9yeSB0byBzdG9yZSB0aGUgd3NscGF0aCBjYWNoZSAoZGVmYXVsdCB2YWx1ZTogVE1QRElSKSwgeW91IGNhbiB1c2UgUEVSU0lTVEVOVF9UTVBESVIgaW5zdGVhZAojIEBleGl0Y29kZSAqIGlmIExpbnV4OjpXc2w6Om9yaWdpbmFsV3NscGF0aCBjYW5ub3QgZmluZCB0aGUgcGF0aAojIEBzdGRlcnIgZGlhZ25vc3RpY3MgaW5mb3JtYXRpb24gaXMgZGlzcGxheWVkCiMgQHJlcXVpcmUgTGludXg6OldzbDo6cmVxdWlyZVdzbAojIEBmZWF0dXJlIGNhY2hlCkxpbnV4OjpXc2w6OmNhY2hlZFdzbHBhdGgoKSB7CiAgbG9jYWwgLWEgYXJncz0oIiRAIikKICBsb2NhbCB0ZW1wRW52RmlsZSBrZXkKICB0ZW1wRW52RmlsZT0iJHtXU0xfVE1QRElSOi0ke1BFUlNJU1RFTlRfVE1QRElSOi0vdG1wfX0vYmFzaF90b29sc193c2xwYXRoXyQoaWQgLXVuKSIKCiAga2V5PSIkKExpbnV4OjpXc2w6OmdldEtleUZyb21Xc2xwYXRoT3B0aW9ucyAiJEAiKSIKICBDYWNoZTo6Z2V0UHJvcGVydHlWYWx1ZSAiJHt0ZW1wRW52RmlsZX0iICIke2tleX0iIExpbnV4OjpXc2w6Om9yaWdpbmFsV3NscGF0aCAiJHthcmdzW0BdfSIKfQoKIyBAZGVzY3JpcHRpb24gY2FsbCBzaW1wbHkgb3JpZ2luYWwgd3NsdmFyIGNvbW1hbmQKIyBAYXJnICRAIGFyZ3M6U3RyaW5nW10gYXJncyB0byBwYXNzIHRvIHdzbHZhcgojIEBleGl0Y29kZSAqIHdzbHZhciBleGl0IGNvZGUKIyBAc3Rkb3V0IHdzbHZhciBzdGRvdXQKIyBAcmVxdWlyZSBMaW51eDo6V3NsOjpyZXF1aXJlV3NsCkxpbnV4OjpXc2w6Om9yaWdpbmFsV3NsdmFyKCkgewogIHdzbHZhciAiJEAiIHwgc2VkIC16ICckIHMvW1xyXG5dJC8vJwp9CgojIEBkZXNjcmlwdGlvbiBEaXNwbGF5IG1lc3NhZ2UgdXNpbmcgc2tpcCBjb2xvciAoeWVsbG93KQojIEBhcmcgJDEgbWVzc2FnZTpTdHJpbmcgdGhlIG1lc3NhZ2UgdG8gZGlzcGxheQpMb2c6OmRpc3BsYXlTa2lwcGVkKCkgewogIGlmICgoQkFTSF9GUkFNRVdPUktfRElTUExBWV9MRVZFTCA+PSBfX0xFVkVMX0lORk8pKTsgdGhlbgogICAgZWNobyAtZSAiJHtfX1NLSVBQRURfQ09MT1J9U0tJUFBFRCAtICR7MX0ke19fUkVTRVRfQ09MT1J9IiA+JjIKICBmaQogIExvZzo6bG9nU2tpcHBlZCAiJDEiCn0KCiMgQGRlc2NyaXB0aW9uIERpc3BsYXkgbWVzc2FnZSB1c2luZyBzdWNjZXNzIGNvbG9yIChiZyBncmVlbi9mZyB3aGl0ZSkKIyBAYXJnICQxIG1lc3NhZ2U6U3RyaW5nIHRoZSBtZXNzYWdlIHRvIGRpc3BsYXkKTG9nOjpkaXNwbGF5U3VjY2VzcygpIHsKICBpZiAoKEJBU0hfRlJBTUVXT1JLX0RJU1BMQVlfTEVWRUwgPj0gX19MRVZFTF9JTkZPKSk7IHRoZW4KICAgIGVjaG8gLWUgIiR7X19TVUNDRVNTX0NPTE9SfVNVQ0NFU1MgLSAkezF9JHtfX1JFU0VUX0NPTE9SfSIgPiYyCiAgZmkKICBMb2c6OmxvZ1N1Y2Nlc3MgIiQxIgp9CgojIEBkZXNjcmlwdGlvbiBEaXNwbGF5IG1lc3NhZ2UgdXNpbmcgd2FybmluZyBjb2xvciAoeWVsbG93KQojIEBhcmcgJDEgbWVzc2FnZTpTdHJpbmcgdGhlIG1lc3NhZ2UgdG8gZGlzcGxheQpMb2c6OmRpc3BsYXlXYXJuaW5nKCkgewogIGlmICgoQkFTSF9GUkFNRVdPUktfRElTUExBWV9MRVZFTCA+PSBfX0xFVkVMX1dBUk5JTkcpKTsgdGhlbgogICAgZWNobyAtZSAiJHtfX1dBUk5JTkdfQ09MT1J9V0FSTiAgICAtICR7MX0ke19fUkVTRVRfQ09MT1J9IiA+JjIKICBmaQogIExvZzo6bG9nV2FybmluZyAiJDEiCn0KCiMgQGRlc2NyaXB0aW9uIGxvYWQgY29sb3JzIHRoZW1lIGNvbnN0YW50cwojIEB3YXJuaW5nIGlmIHR0eSBub3Qgb3BlbmVkLCBub0NvbG9yIHRoZW1lIHdpbGwgYmUgY2hvc2VuCiMgQGFyZyAkMSB0aGVtZTpTdHJpbmcgdGhlIHRoZW1lIHRvIHVzZSAoZGVmYXVsdCwgbm9Db2xvcikKIyBAYXJnICRAIGFyZ3M6U3RyaW5nW10KIyBAc2V0IF9fRVJST1JfQ09MT1IgU3RyaW5nIGluZGljYXRlIGVycm9yIHN0YXR1cwojIEBzZXQgX19JTkZPX0NPTE9SIFN0cmluZyBpbmRpY2F0ZSBpbmZvIHN0YXR1cwojIEBzZXQgX19TVUNDRVNTX0NPTE9SIFN0cmluZyBpbmRpY2F0ZSBzdWNjZXNzIHN0YXR1cwojIEBzZXQgX19XQVJOSU5HX0NPTE9SIFN0cmluZyBpbmRpY2F0ZSB3YXJuaW5nIHN0YXR1cwojIEBzZXQgX19TS0lQUEVEX0NPTE9SIFN0cmluZyBpbmRpY2F0ZSBza2lwcGVkIHN0YXR1cwojIEBzZXQgX19ERUJVR19DT0xPUiBTdHJpbmcgaW5kaWNhdGUgZGVidWcgc3RhdHVzCiMgQHNldCBfX0hFTFBfQ09MT1IgU3RyaW5nIGluZGljYXRlIGhlbHAgc3RhdHVzCiMgQHNldCBfX1RFU1RfQ09MT1IgU3RyaW5nIG5vdCB1c2VkCiMgQHNldCBfX1RFU1RfRVJST1JfQ09MT1IgU3RyaW5nIG5vdCB1c2VkCiMgQHNldCBfX0hFTFBfVElUTEVfQ09MT1IgU3RyaW5nIHVzZWQgdG8gZGlzcGxheSBoZWxwIHRpdGxlIGluIGhlbHAgc3RyaW5ncwojIEBzZXQgX19IRUxQX09QVElPTl9DT0xPUiBTdHJpbmcgdXNlZCB0byBkaXNwbGF5IGhpZ2hsaWdodCBvcHRpb25zIGluIGhlbHAgc3RyaW5ncwojCiMgQHNldCBfX1JFU0VUX0NPTE9SIFN0cmluZyByZXNldCBkZWZhdWx0IGNvbG9yCiMKIyBAc2V0IF9fSEVMUF9FWEFNUExFIFN0cmluZyB0byByZW1vdmUKIyBAc2V0IF9fSEVMUF9USVRMRSBTdHJpbmcgdG8gcmVtb3ZlCiMgQHNldCBfX0hFTFBfTk9STUFMIFN0cmluZyB0byByZW1vdmUKIyBzaGVsbGNoZWNrIGRpc2FibGU9U0MyMDM0ClVJOjp0aGVtZSgpIHsKICBsb2NhbCB0aGVtZT0iJHsxLWRlZmF1bHR9IgogIGlmIFtbICEgIiR7dGhlbWV9IiA9fiAtZm9yY2UkIF1dICYmICEgQXNzZXJ0Ojp0dHk7IHRoZW4KICAgIHRoZW1lPSJub0NvbG9yIgogIGZpCiAgY2FzZSAiJHt0aGVtZX0iIGluCiAgICBkZWZhdWx0IHwgZGVmYXVsdC1mb3JjZSkKICAgICAgdGhlbWU9ImRlZmF1bHQiCiAgICAgIDs7CiAgICBub0NvbG9yKSA7OwogICAgKikKICAgICAgTG9nOjpmYXRhbCAiaW52YWxpZCB0aGVtZSBwcm92aWRlZCIKICAgICAgOzsKICBlc2FjCiAgaWYgW1sgIiR7dGhlbWV9IiA9ICJkZWZhdWx0IiBdXTsgdGhlbgogICAgQkFTSF9GUkFNRVdPUktfVEhFTUU9ImRlZmF1bHQiCiAgICAjIGNoZWNrIGNvbG9ycyBhcHBsaWNhYmxlIGh0dHBzOi8vbWlzYy5mbG9naXNvZnQuY29tL2Jhc2gvdGlwX2NvbG9yc19hbmRfZm9ybWF0dGluZwogICAgX19FUlJPUl9DT0xPUj0nXGVbMzFtJyAgICAgICAgICMgUmVkCiAgICBfX0lORk9fQ09MT1I9J1xlWzQ0bScgICAgICAgICAgIyB3aGl0ZSBvbiBsaWdodEJsdWUKICAgIF9fU1VDQ0VTU19DT0xPUj0nXGVbMzJtJyAgICAgICAjIEdyZWVuCiAgICBfX1dBUk5JTkdfQ09MT1I9J1xlWzMzbScgICAgICAgIyBZZWxsb3cKICAgIF9fU0tJUFBFRF9DT0xPUj0nXGVbMzNtJyAgICAgICAjIFllbGxvdwogICAgX19ERUJVR19DT0xPUj0nXGVbMzdtJyAgICAgICAgICMgR3JleQogICAgX19IRUxQX0NPTE9SPSdcZVs3OzQ5OzMzbScgICAgICMgQmxhY2sgb24gR29sZAogICAgX19URVNUX0NPTE9SPSdcZVsxMDBtJyAgICAgICAgICMgTGlnaHQgbWFnZW50YQogICAgX19URVNUX0VSUk9SX0NPTE9SPSdcZVs0MW0nICAgICMgd2hpdGUgb24gcmVkCiAgICBfX0hFTFBfVElUTEVfQ09MT1I9IlxlWzE7MzdtIiAgIyBCb2xkCiAgICBfX0hFTFBfT1BUSU9OX0NPTE9SPSJcZVsxOzM0bSIgIyBCbHVlCiAgICAjIEludGVybmFsOiByZXNldCBjb2xvcgogICAgX19SRVNFVF9DT0xPUj0nXGVbMG0nICMgUmVzZXQgQ29sb3IKICAgICMgc2hlbGxjaGVjayBkaXNhYmxlPVNDMjE1NSxTQzIwMzQKICAgIF9fSEVMUF9FWEFNUExFPSIkKGVjaG8gLWUgIlxlWzI7OTdtIikiCiAgICAjIHNoZWxsY2hlY2sgZGlzYWJsZT1TQzIxNTUsU0MyMDM0CiAgICBfX0hFTFBfVElUTEU9IiQoZWNobyAtZSAiXGVbMTszN20iKSIKICAgICMgc2hlbGxjaGVjayBkaXNhYmxlPVNDMjE1NSxTQzIwMzQKICAgIF9fSEVMUF9OT1JNQUw9IiQoZWNobyAtZSAiXDAzM1swbSIpIgogIGVsc2UKICAgIEJBU0hfRlJBTUVXT1JLX1RIRU1FPSJub0NvbG9yIgogICAgIyBjaGVjayBjb2xvcnMgYXBwbGljYWJsZSBodHRwczovL21pc2MuZmxvZ2lzb2Z0LmNvbS9iYXNoL3RpcF9jb2xvcnNfYW5kX2Zvcm1hdHRpbmcKICAgIF9fRVJST1JfQ09MT1I9JycKICAgIF9fSU5GT19DT0xPUj0nJwogICAgX19TVUNDRVNTX0NPTE9SPScnCiAgICBfX1dBUk5JTkdfQ09MT1I9JycKICAgIF9fU0tJUFBFRF9DT0xPUj0nJwogICAgX19ERUJVR19DT0xPUj0nJwogICAgX19IRUxQX0NPTE9SPScnCiAgICBfX1RFU1RfQ09MT1I9JycKICAgIF9fVEVTVF9FUlJPUl9DT0xPUj0nJwogICAgX19IRUxQX1RJVExFX0NPTE9SPScnCiAgICBfX0hFTFBfT1BUSU9OX0NPTE9SPScnCiAgICAjIEludGVybmFsOiByZXNldCBjb2xvcgogICAgX19SRVNFVF9DT0xPUj0nJwogICAgX19IRUxQX0VYQU1QTEU9JycKICAgIF9fSEVMUF9USVRMRT0nJwogICAgX19IRUxQX05PUk1BTD0nJwogIGZpCn0KCiMgQGRlc2NyaXB0aW9uIGVuc3VyZSBsaW51eCBkaXN0cmlidXRpb24gaXMgdWJ1bnR1CiMgQGV4aXRjb2RlIDEgaWYgbGludXggZGlzdHJpYnV0aW9uIGlzIG5vdCB1YnVudHUKTGludXg6OnJlcXVpcmVVYnVudHUoKSB7CiAgaWYgISBBcnJheTo6Y29udGFpbnMgIiQoTGludXg6OmdldERpc3RyaWJ1dG9ySWQpIiAiVWJ1bnR1IiAiRGViaWFuIjsgdGhlbgogICAgTG9nOjpmYXRhbCAidGhpcyBzY3JpcHQgc2hvdWxkIGJlIGV4ZWN1dGVkIHVuZGVyIFVidW50dSBvciBEZWJpYW4gT1MiCiAgZmkKfQoKIyBAZGVzY3JpcHRpb24gZW5zdXJlIGxpbnV4IHJ1bnMgdW5kZXIgd3NsCiMgQGVudiBXU0xfR0FSQkFHRV9DT0xMRUNUIGludCAwIHRvIGRpc2FibGUgZ2FyYmFnZSBjb2xsZWN0IG9mIGNhY2hlIGZpbGVzCiMgQGV4aXRjb2RlIDEgaWYgbGludXggZG9lcyBub3QgcnVuIHVuZGVyIHdzbApMaW51eDo6V3NsOjpyZXF1aXJlV3NsKCkgewogIEFzc2VydDo6d3NsIHx8IHJldHVybiAxCiAgaWYgW1sgIiR7V1NMX0dBUkJBR0VfQ09MTEVDVDotMX0iID0gIjEiIF1dOyB0aGVuCiAgICBsb2NhbCB0ZW1wRW52RGlyCiAgICB0ZW1wRW52RGlyPSIke1dTTF9UTVBESVI6LSR7UEVSU0lTVEVOVF9UTVBESVI6LS90bXB9fSIKICAgIEZpbGU6OmdhcmJhZ2VDb2xsZWN0ICIke3RlbXBFbnZEaXJ9L2Jhc2hfdG9vbHNfd3NscGF0aF8kKGlkIC11bikiICIxIgogICAgdGVtcEVudkRpcj0iJHtXU0xfVE1QRElSOi0ke1BFUlNJU1RFTlRfVE1QRElSOi0vdG1wfX0iCiAgICBGaWxlOjpnYXJiYWdlQ29sbGVjdCAiJHt0ZW1wRW52RGlyfS9iYXNoX3Rvb2xzX3dzbHZhcl8kKGlkIC11bikiICIxIgogIGZpCn0KCiMgQGRlc2NyaXB0aW9uIGVuc3VyZSBjb21tYW5kIGpxIGlzIGF2YWlsYWJsZQojIEBleGl0Y29kZSAxIGlmIGpxIGNvbW1hbmQgbm90IGF2YWlsYWJsZQojIEBzdGRlcnIgZGlhZ25vc3RpY3MgaW5mb3JtYXRpb24gaXMgZGlzcGxheWVkCkxpbnV4OjpyZXF1aXJlSnFDb21tYW5kKCkgewogIEFzc2VydDo6Y29tbWFuZEV4aXN0cyBqcQp9CgojIEBkZXNjcmlwdGlvbiBjaGVjayBpZiBjb21tYW5kIHNwZWNpZmllZCBleGlzdHMgb3IgcmV0dXJuIDEKIyB3aXRoIGVycm9yIGFuZCBtZXNzYWdlIGlmIG5vdAojCiMgQGFyZyAkMSBjb21tYW5kTmFtZTpTdHJpbmcgb24gd2hpY2ggZXhpc3RlbmNlIG11c3QgYmUgY2hlY2tlZAojIEBhcmcgJDIgaGVscElmTm90RXhpc3RzOlN0cmluZyBhIGhlbHAgY29tbWFuZCB0byBkaXNwbGF5IGlmIHRoZSBjb21tYW5kIGRvZXMgbm90IGV4aXN0CiMKIyBAZXhpdGNvZGUgMSBpZiB0aGUgY29tbWFuZCBzcGVjaWZpZWQgZG9lcyBub3QgZXhpc3QKIyBAc3RkZXJyIGRpYWdub3N0aWMgaW5mb3JtYXRpb24gKyBoZWxwIGlmIHNlY29uZCBhcmd1bWVudCBpcyBwcm92aWRlZApBc3NlcnQ6OmNvbW1hbmRFeGlzdHMoKSB7CiAgbG9jYWwgY29tbWFuZE5hbWU9IiQxIgogIGxvY2FsIGhlbHBJZk5vdEV4aXN0cz0iJDIiCgogICIke0JBU0hfRlJBTUVXT1JLX0NPTU1BTkQ6LWNvbW1hbmR9IiAtdiAiJHtjb21tYW5kTmFtZX0iID4vZGV2L251bGwgMj4vZGV2L251bGwgfHwgewogICAgTG9nOjpkaXNwbGF5RXJyb3IgIiR7Y29tbWFuZE5hbWV9IGlzIG5vdCBpbnN0YWxsZWQsIHBsZWFzZSBpbnN0YWxsIGl0IgogICAgaWYgW1sgLW4gIiR7aGVscElmTm90RXhpc3RzfSIgXV07IHRoZW4KICAgICAgTG9nOjpkaXNwbGF5SW5mbyAiJHtoZWxwSWZOb3RFeGlzdHN9IgogICAgZmkKICAgIHJldHVybiAxCiAgfQogIHJldHVybiAwCn0KCiMgQGRlc2NyaXB0aW9uIGNoZWNrIGlmIHR0eSAoaW50ZXJhY3RpdmUgbW9kZSkgaXMgYWN0aXZlCiMgQG5vYXJncwojIEBleGl0Y29kZSAxIGlmIHR0eSBub3QgYWN0aXZlCiMgQGVudiBOT05fSU5URVJBQ1RJVkUgaWYgMSBjb25zaWRlciBhcyBub3QgaW50ZXJhY3RpdmUgZXZlbiBpZiBlbnZpcm9ubWVudCBpcyBpbnRlcmFjdGl2ZQojIEBlbnYgSU5URVJBQ1RJVkUgaWYgMSBjb25zaWRlciBhcyBpbnRlcmFjdGl2ZSBldmVuIGlmIGVudmlyb25tZW50IGlzIG5vdCBpbnRlcmFjdGl2ZQpBc3NlcnQ6OnR0eSgpIHsKICBpZiBbWyAiJHtOT05fSU5URVJBQ1RJVkU6LTB9IiA9ICIxIiBdXTsgdGhlbgogICAgcmV0dXJuIDEKICBmaQogIGlmIFtbICIke0lOVEVSQUNUSVZFOi0wfSIgPSAiMSIgXV07IHRoZW4KICAgIHJldHVybiAwCiAgZmkKICAjIGNoZWNrIGlmIHN0ZG91dCBvciBzdGRlcnIgaXMgY29ubmVjdGVkIHRvIHRlcm1pbmFsCiAgW1sgLXQgMSB8fCAtdCAyIF1dCn0KCiMgQGRlc2NyaXB0aW9uIGRlbGV0ZSBmaWxlcyBvbGRlciB0aGFuIG4gZGF5cyBpbiBnaXZlbiBwYXRoCiMgQHdhcm5pbmcgdXNlIHRoaXMgZnVuY3Rpb24gd2l0aCBjYXV0aW9uIGFzIGl0IHdpbGwgZGVsZXRlIGFsbCBmaWxlcyBpbiBnaXZlbiBwYXRoIHdpdGhvdXQgYW55IHByb21wdAojIEBhcmcgJDEgcGF0aDpTdHJpbmcgdGhlIGRpcmVjdG9yeSBpbiB3aGljaCBmaWxlcyB3aWxsIGJlIGRlbGV0ZWQgb3IgdGhlIGZpbGUgdG8gZGVsZXRlCiMgQGFyZyAkMiBtdGltZTpTdHJpbmcgZXhwaXJhdGlvbiB0aW1lIGluIGRheXMgKGVnOiAxIG1lYW5zIDEgZGF5KSAoZGVmYXVsdCB2YWx1ZTogMSkuIEVnOiArMSBtYXRjaCBmaWxlcyB0aGF0IGhhdmUgYmVlbiBhY2Nlc3NlZCBhdCBsZWFzdCB0d28gZGF5cyBhZ28gKHJvdW5kaW5nIGVmZmVjdCkKIyBAYXJnICQzIG1heGRlcHRoOmludCBEZXNjZW5kIGF0IG1vc3QgbGV2ZWxzIChhIG5vbi1uZWdhdGl2ZSBpbnRlZ2VyKSBsZXZlbHMgb2YgZGlyZWN0b3JpZXMgYmVsb3cgdGhlIHN0YXJ0aW5nLXBvaW50cy4gKGRlZmF1bHQgdmFsdWU6IDEpCiMgQGV4aXRjb2RlIDEgaWYgcGF0aCBub3QgcHJvdmlkZWQgb3IgZW1wdHkKIyBAZXhpdGNvZGUgKiBmaW5kIGNvbW1hbmQgZmFpbHVyZSBjb2RlCiMgQHN0ZGVyciBmaW5kIG91dHB1dCBvbiBlcnJvciBvciBkaWFnbm9zdGljcyBsb2dzCiMgQHNlZSBtYW4gZmluZCBhdGltZQpGaWxlOjpnYXJiYWdlQ29sbGVjdCgpIHsKICBsb2NhbCBwYXRoPSIkMSIKICBsb2NhbCBtdGltZT0iJDIiCiAgbG9jYWwgbWF4ZGVwdGg9IiR7MzotMX0iCgogIGlmIFtbIC16ICIke3BhdGh9IiBdXTsgdGhlbgogICAgcmV0dXJuIDEKICBmaQoKICBpZiBbWyAhIC1lICIke3BhdGh9IiBdXTsgdGhlbgogICAgIyBwYXRoIGFscmVhZHkgcmVtb3ZlZAogICAgcmV0dXJuIDAKICBmaQoKICBMb2c6OmRpc3BsYXlJbmZvICJHYXJiYWdlIGNvbGxlY3QgZmlsZXMgb2xkZXIgdGhhbiAke210aW1lfSBkYXlzIGluIHBhdGggJHtwYXRofSB3aXRoIG1heCBkZXB0aCAke21heGRlcHRofSIKICBmaW5kICIke3BhdGh9IiAtZGVwdGggLW1heGRlcHRoICIke21heGRlcHRofSIgLXR5cGUgZiAtbXRpbWUgIiR7bXRpbWV9IiAtcHJpbnQgLWRlbGV0ZQp9CgojIEBkZXNjcmlwdGlvbiBDb21wdXRlIGEgY2FjaGUgZnJvbSB3c2xwYXRoIG9wdGlvbnMKIyBAYXJnICRAIGFyZ3M6U3RyaW5nW10gYXJndW1lbnRzIHBhc3NlZCB0byB3c2xwYXRoCiMgQHN0ZGVyciBkaWFnbm9zdGljcyBpbmZvcm1hdGlvbiBpcyBkaXNwbGF5ZWQKIyBAc3Rkb3V0IHRoZSBjYWNoZSBrZXkgZGVkdWNlZCBmcm9tIHRoZSBvcHRpb25zCiMgQHJlcXVpcmUgTGludXg6OldzbDo6cmVxdWlyZVdzbAojIEBmZWF0dXJlIGNhY2hlCiMgQGludGVybmFsCkxpbnV4OjpXc2w6OmdldEtleUZyb21Xc2xwYXRoT3B0aW9ucygpIHsKICBsb2NhbCBvcHRpb25zCiAgb3B0aW9ucz0kKGdldG9wdCAtbyAiYXV3bSIgLS0gIiRAIiAyPi9kZXYvbnVsbCkgfHwgewogICAgTG9nOjpkaXNwbGF5RXJyb3IgImludmFsaWQgb3B0aW9ucyBzcGVjaWZpZWQiCiAgICByZXR1cm4gMQogIH0KICBsb2NhbCBrZXk9IndzbHBhdGgiCiAgZXZhbCBzZXQgLS0gIiR7b3B0aW9uc30iCiAgd2hpbGUgdHJ1ZTsgZG8KICAgIGNhc2UgIiQxIiBpbgogICAgICAtYSB8IC11IHwgLXcgfCAtbSkKICAgICAgICBrZXk9IiR7a2V5fSQxIgogICAgICAgIDs7CiAgICAgIC0tKQogICAgICAgIHNoaWZ0IHx8IHRydWUKICAgICAgICBicmVhawogICAgICAgIDs7CiAgICAgICopCiAgICAgICAgc2hpZnQgfHwgdHJ1ZQogICAgICAgIExvZzo6ZGlzcGxheVdhcm5pbmcgIlVua25vd24ga2V5ICQxIgogICAgICAgIDs7CiAgICBlc2FjCiAgICBzaGlmdCB8fCB0cnVlCiAgZG9uZQogIGVjaG8gLUUgIiR7a2V5fV8kMSIKfQoKIyBAZGVzY3JpcHRpb24gY2FsbCBzaW1wbHkgb3JpZ2luYWwgd3NscGF0aCBjb21tYW5kCiMgQGFyZyAkQCBhcmdzOlN0cmluZ1tdIGFyZ3MgdG8gcGFzcyB0byB3c2xwYXRoCiMgQGV4aXRjb2RlICogd3NscGF0aCBleGl0IGNvZGUKIyBAc3Rkb3V0IHdzbHBhdGggc3Rkb3V0CiMgQHJlcXVpcmUgTGludXg6OldzbDo6cmVxdWlyZVdzbApMaW51eDo6V3NsOjpvcmlnaW5hbFdzbHBhdGgoKSB7CiAgd3NscGF0aCAiJEAiCn0KCiMgQGRlc2NyaXB0aW9uIHJldHJpZXZlIGxpbnV4IGRpc3RyaWJ1dG9yIGlkCiMgQG5vYXJncwojIEBleGl0Y29kZSAxIGlmIGxzYl9yZWxlYXNlIGZhaWxzIG9yIG5vdCBmb3VuZAojIEBzdGRvdXQgdGhlIGxpbnV4IGRpc3RyaWJ1dG9yIGlkCkxpbnV4OjpnZXREaXN0cmlidXRvcklkKCkgewogIGxzYl9yZWxlYXNlIC1hIDI+L2Rldi9udWxsIHwgc2VkIC1FbiAncy9EaXN0cmlidXRvciBJRDpbIFx0XSsoLispL1wxL3AnCn0KCiMgQGRlc2NyaXB0aW9uIGxvZyBtZXNzYWdlIHRvIGZpbGUKIyBAYXJnICQxIG1lc3NhZ2U6U3RyaW5nIHRoZSBtZXNzYWdlIHRvIGRpc3BsYXkKTG9nOjpsb2dTa2lwcGVkKCkgewogIGlmICgoQkFTSF9GUkFNRVdPUktfTE9HX0xFVkVMID49IF9fTEVWRUxfSU5GTykpOyB0aGVuCiAgICBMb2c6OmxvZ01lc3NhZ2UgIiR7MjotU0tJUFBFRH0iICIkMSIKICBmaQp9CgojIEBkZXNjcmlwdGlvbiBsb2cgbWVzc2FnZSB0byBmaWxlCiMgQGFyZyAkMSBtZXNzYWdlOlN0cmluZyB0aGUgbWVzc2FnZSB0byBkaXNwbGF5CkxvZzo6bG9nU3VjY2VzcygpIHsKICBpZiAoKEJBU0hfRlJBTUVXT1JLX0xPR19MRVZFTCA+PSBfX0xFVkVMX0lORk8pKTsgdGhlbgogICAgTG9nOjpsb2dNZXNzYWdlICIkezI6LVNVQ0NFU1N9IiAiJDEiCiAgZmkKfQoKIyBAZGVzY3JpcHRpb24gbG9nIG1lc3NhZ2UgdG8gZmlsZQojIEBhcmcgJDEgbWVzc2FnZTpTdHJpbmcgdGhlIG1lc3NhZ2UgdG8gZGlzcGxheQpMb2c6OmxvZ1dhcm5pbmcoKSB7CiAgaWYgKChCQVNIX0ZSQU1FV09SS19MT0dfTEVWRUwgPj0gX19MRVZFTF9XQVJOSU5HKSk7IHRoZW4KICAgIExvZzo6bG9nTWVzc2FnZSAiJHsyOi1XQVJOSU5HfSIgIiQxIgogIGZpCn0KCiMgRlVOQ1RJT05TCgpmYWNhZGVfbWFpbl9lbWJlZEZyYW1ld29ya0Z1bmN0aW9uYmluRmlsZXRwbCgpIHsKIyBSRVFVSVJFUwpFbnY6OnJlcXVpcmVMb2FkClVJOjpyZXF1aXJlVGhlbWUKTGludXg6OnJlcXVpcmVVYnVudHUKTGludXg6OldzbDo6cmVxdWlyZVdzbApMb2c6OnJlcXVpcmVMb2FkCkxpbnV4OjpyZXF1aXJlSnFDb21tYW5kCkNvbXBpbGVyOjpGYWNhZGU6OnJlcXVpcmVDb21tYW5kQmluRGlyCgppZiBBc3NlcnQ6OmZ1bmN0aW9uRXhpc3RzIGluaXRGYWNhZGU7IHRoZW4KICBpbml0RmFjYWRlCmZpCkVuZ2luZTo6Q29uZmlnOjpsb2FkQ29uZmlnCiMgQGRlc2NyaXB0aW9uIGNyZWF0ZSBzdWRvZXIgZmlsZSBhbmQgYWRkIHRyYXBzIHRvIHJlbW92ZSBpdCBhdCB0aGUgZW5kCiMgQGFyZyAkMSBzdWRvZXJGaWxlOlN0cmluZyB0aGUgZmlsZSBwYXRoIHRvIGNyZWF0ZQojIEBlbnYgVVNFUk5BTUUKIyBzaGVsbGNoZWNrIGRpc2FibGU9U0MyMzE3CmxvY2FsIHN1ZG9lckZpbGU9IiR7U1VET0VSX0ZJTEVfUFJFRklYfS9ldGMvc3Vkb2Vycy5kL2Jhc2gtZGV2LWVudi1uby1wYXNzd29yZCIKaWYgW1sgLWYgIiR7c3Vkb2VyRmlsZX0iIF1dOyB0aGVuCiAgIyBzdWRvZXJGaWxlIHByb2JhYmx5IGFscmVhZHkgbWFuYWdlZCBieSBwYXJlbnQgc2NyaXB0CiAgdHJ1ZQplbHNlCiAgY2xlYW5TdWRvZXIoKSB7CiAgICBpZiBbWyAtZiAiJHtzdWRvZXJGaWxlfSIgXV07IHRoZW4KICAgICAgJHtTVURPOi1zdWRvfSBybSAtZiAiJHtzdWRvZXJGaWxlfSIgfHwgdHJ1ZQogICAgZmkKICB9CiAgdHJhcCBjbGVhblN1ZG9lciBFWElUIEhVUCBRVUlUIEFCUlQgVEVSTQoKICBMb2c6OmRpc3BsYXlJbmZvICJDcmVhdGluZyBzdWRvZXIgZmlsZSIKICBlY2hvICIke1VTRVJOQU1FfSBBTEw9KEFMTCkgTk9QQVNTV0Q6IEFMTCIgfAogICAgJHtTVURPOi1zdWRvfSB0ZWUgIiR7c3Vkb2VyRmlsZX0iID4vZGV2L251bGwKICAke1NVRE86LXN1ZG99IGNobW9kIDA0NDAgIiR7c3Vkb2VyRmlsZX0iCmZpCgojIEByZXF1aXJlIENvbXBpbGVyOjpGYWNhZGU6OnJlcXVpcmVDb21tYW5kQmluRGlyCgojIHNoZWxsY2hlY2sgZGlzYWJsZT1TQzIxNTQsU0MyMDE2CmZ1bmN0aW9uVG9DYWxsPSdHaXRodWI6OnVwZ3JhZGVSZWxlYXNlJwoiJHtmdW5jdGlvblRvQ2FsbH0iICIkQCIKCn0KCmZhY2FkZV9tYWluX2VtYmVkRnJhbWV3b3JrRnVuY3Rpb25iaW5GaWxldHBsICIkQCIK"

Compiler::Embed::extractFileFromBase64 \
  "${embed_function_GithubUpgradeRelease}" \
  "${encoded_binary_file_GithubUpgradeRelease}"

facade_main_Dockersh() {
# REQUIRES
Linux::requireUbuntu
Env::requireLoad
UI::requireTheme
Log::requireLoad
Linux::Wsl::requireWsl
Compiler::Embed::requireEmbedBinDir
Compiler::Facade::requireCommandBinDir

if Assert::functionExists initFacade; then
  initFacade
fi
Engine::Config::loadConfig
# @description create sudoer file and add traps to remove it at the end
# @arg $1 sudoerFile:String the file path to create
# @env USERNAME
# shellcheck disable=SC2317
local sudoerFile="${SUDOER_FILE_PREFIX}/etc/sudoers.d/bash-dev-env-no-password"
if [[ -f "${sudoerFile}" ]]; then
  # sudoerFile probably already managed by parent script
  true
else
  cleanSudoer() {
    if [[ -f "${sudoerFile}" ]]; then
      ${SUDO:-sudo} rm -f "${sudoerFile}" || true
    fi
  }
  trap cleanSudoer EXIT HUP QUIT ABRT TERM

  Log::displayInfo "Creating sudoer file"
  echo "${USERNAME} ALL=(ALL) NOPASSWD: ALL" |
    ${SUDO:-sudo} tee "${sudoerFile}" >/dev/null
  ${SUDO:-sudo} chmod 0440 "${sudoerFile}"
fi

# @require Compiler::Facade::requireCommandBinDir
# ROOT_DIR_RELATIVE_TO_BIN_DIR=..
# FACADE
# IMPLEMENT InstallScripts::interface
# EMBED Github::upgradeRelease as githubUpgradeRelease

declare -a BASH_FRAMEWORK_ARGV_FILTERED=()

copyrightCallback() {
  if [[ -z "${copyrightBeginYear}" ]]; then
    copyrightBeginYear="$(date +%Y)"
  fi
  echo "Copyright (c) ${copyrightBeginYear}-now Franois Chastanet"
}

# shellcheck disable=SC2317 # if function is overridden
updateArgListInfoVerboseCallback() {
  BASH_FRAMEWORK_ARGV_FILTERED+=(--verbose)
}
# shellcheck disable=SC2317 # if function is overridden
updateArgListDebugVerboseCallback() {
  BASH_FRAMEWORK_ARGV_FILTERED+=(-vv)
}
# shellcheck disable=SC2317 # if function is overridden
updateArgListTraceVerboseCallback() {
  BASH_FRAMEWORK_ARGV_FILTERED+=(-vvv)
}
# shellcheck disable=SC2317 # if function is overridden
updateArgListEnvFileCallback() { :; }
# shellcheck disable=SC2317 # if function is overridden
updateArgListLogLevelCallback() { :; }
# shellcheck disable=SC2317 # if function is overridden
updateArgListDisplayLevelCallback() { :; }
# shellcheck disable=SC2317 # if function is overridden
updateArgListNoColorCallback() {
  BASH_FRAMEWORK_ARGV_FILTERED+=(--no-color)
}
# shellcheck disable=SC2317 # if function is overridden
updateArgListThemeCallback() { :; }
# shellcheck disable=SC2317 # if function is overridden
updateArgListQuietCallback() { :; }

# shellcheck disable=SC2317 # if function is overridden
optionHelpCallback() {
  installScriptCommand help
  exit 0
}

# shellcheck disable=SC2317 # if function is overridden
optionVersionCallback() {
  echo "${SCRIPT_NAME} version "
  exit 0
}

# shellcheck disable=SC2317 # if function is overridden
optionEnvFileCallback() {
  local envFile="$2"
  Log::displayWarning "Command ${SCRIPT_NAME} - Option --env-file is deprecated and will be removed in the future"
  if [[ ! -f "${envFile}" || ! -r "${envFile}" ]]; then
    Log::displayError "Command ${SCRIPT_NAME} - Option --env-file - File '${envFile}' doesn't exist"
    exit 1
  fi
}

# shellcheck disable=SC2317 # if function is overridden
optionInfoVerboseCallback() {
  BASH_FRAMEWORK_ARGS_VERBOSE_OPTION='--verbose'
  BASH_FRAMEWORK_ARGS_VERBOSE=${__VERBOSE_LEVEL_INFO}
  echo "BASH_FRAMEWORK_DISPLAY_LEVEL=${__LEVEL_INFO}" >> "${overrideEnvFile}"
}

# shellcheck disable=SC2317 # if function is overridden
optionDebugVerboseCallback() {
  BASH_FRAMEWORK_ARGS_VERBOSE_OPTION='-vv'
  BASH_FRAMEWORK_ARGS_VERBOSE=${__VERBOSE_LEVEL_DEBUG}
  echo "BASH_FRAMEWORK_DISPLAY_LEVEL=${__LEVEL_DEBUG}" >> "${overrideEnvFile}"
}

# shellcheck disable=SC2317 # if function is overridden
optionTraceVerboseCallback() {
  BASH_FRAMEWORK_ARGS_VERBOSE_OPTION='-vvv'
  BASH_FRAMEWORK_ARGS_VERBOSE=${__VERBOSE_LEVEL_TRACE}
  echo "BASH_FRAMEWORK_DISPLAY_LEVEL=${__LEVEL_DEBUG}" >> "${overrideEnvFile}"
}

getLevel() {
  local levelName="$1"
  case "${levelName^^}" in
    OFF)
      echo "${__LEVEL_OFF}"
      ;;
    ERR | ERROR)
      echo "${__LEVEL_ERROR}"
      ;;
    WARN | WARNING)
      echo "${__LEVEL_WARNING}"
      ;;
    INFO)
      echo "${__LEVEL_INFO}"
      ;;
    DEBUG | TRACE)
      echo "${__LEVEL_DEBUG}"
      ;;
    *)
      Log::displayError "Command ${SCRIPT_NAME} - Invalid level ${level}"
      return 1
  esac
}

getVerboseLevel() {
  local levelName="$1"
  case "${levelName^^}" in
    OFF)
      echo "${__VERBOSE_LEVEL_OFF}"
      ;;
    ERR | ERROR | WARN | WARNING | INFO)
      echo "${__VERBOSE_LEVEL_INFO}"
      ;;
    DEBUG)
      echo "${__VERBOSE_LEVEL_DEBUG}"
      ;;
    TRACE)
      echo "${__VERBOSE_LEVEL_TRACE}"
      ;;
    *)
      Log::displayError "Command ${SCRIPT_NAME} - Invalid level ${level}"
      return 1
  esac
}

# shellcheck disable=SC2317 # if function is overridden
optionDisplayLevelCallback() {
  local level="$2"
  local logLevel verboseLevel
  logLevel="$(getLevel "${level}")"
  verboseLevel="$(getVerboseLevel "${level}")"
  BASH_FRAMEWORK_ARGS_VERBOSE=${verboseLevel}
  echo "BASH_FRAMEWORK_DISPLAY_LEVEL=${logLevel}" >> "${overrideEnvFile}"
}

# shellcheck disable=SC2317 # if function is overridden
optionLogLevelCallback() {
  local level="$2"
  local logLevel verboseLevel
  logLevel="$(getLevel "${level}")"
  verboseLevel="$(getVerboseLevel "${level}")"
  BASH_FRAMEWORK_ARGS_VERBOSE=${verboseLevel}
  echo "BASH_FRAMEWORK_LOG_LEVEL=${logLevel}" >> "${overrideEnvFile}"
}

# shellcheck disable=SC2317 # if function is overridden
optionLogFileCallback() {
  local logFile="$2"
  echo "BASH_FRAMEWORK_LOG_FILE='${logFile}'" >> "${overrideEnvFile}"
}

# shellcheck disable=SC2317 # if function is overridden
optionQuietCallback() {
  echo "BASH_FRAMEWORK_QUIET_MODE=1" >> "${overrideEnvFile}"
}

# shellcheck disable=SC2317 # if function is overridden
optionNoColorCallback() {
  UI::theme "noColor"
}

# shellcheck disable=SC2317 # if function is overridden
optionThemeCallback() {
  UI::theme "$2"
}

displayConfig() {
  echo "Config"
  UI::drawLine "-"
  local var
  while read -r var; do
    printf '%-40s = %s\n' "${var}" "$(declare -p "${var}" | sed -E -e 's/^[^=]+=(.*)/\1/')"
  done < <(typeset -p | awk 'match($3, "^(BASH_FRAMEWORK_[^=]+)=", m) { print m[1] }' | sort)
  exit 0
}

optionBashFrameworkConfigCallback() {
  if [[ ! -f "$2" ]]; then
    Log::fatal "Command ${SCRIPT_NAME} - Bash framework config file '$2' does not exists"
  fi
}

defaultFrameworkConfig="$(
  cat <<'EOF'
# copied from src/_includes/.framework-config.default
# shellcheck disable=SC2034

REAL_SCRIPT_FILE="${REAL_SCRIPT_FILE:-$(readlink -e "$(realpath "${BASH_SOURCE[0]}")")}"
FRAMEWORK_ROOT_DIR="${FRAMEWORK_ROOT_DIR:-$(cd "$(readlink -e "${REAL_SCRIPT_FILE%/*}")/../.." && pwd -P)}"
FRAMEWORK_SRC_DIR="${FRAMEWORK_SRC_DIR:-${FRAMEWORK_ROOT_DIR}/src}"
FRAMEWORK_BIN_DIR="${FRAMEWORK_BIN_DIR:-${FRAMEWORK_ROOT_DIR}/bin}"
FRAMEWORK_VENDOR_DIR="${FRAMEWORK_VENDOR_DIR:-${FRAMEWORK_ROOT_DIR}/vendor}"
FRAMEWORK_VENDOR_BIN_DIR="${FRAMEWORK_VENDOR_BIN_DIR:-${FRAMEWORK_ROOT_DIR}/vendor/bin}"

# describe the functions that will be skipped from being imported
FRAMEWORK_FUNCTIONS_IGNORE_REGEXP="${FRAMEWORK_FUNCTIONS_IGNORE_REGEXP:-^(Namespace::functions|Functions::myFunction|Namespace::requireSomething|Acquire::ForceIPv4)$}"
# describe the files that do not contain function to be imported
NON_FRAMEWORK_FILES_REGEXP="${NON_FRAMEWORK_FILES_REGEXP:-(^bin/|.framework-config|.bats$|/testsData/|^manualTests/|/_.sh$|/ZZZ.sh$|/__all.sh$|^src/_binaries|^src/_includes|^src/batsHeaders.sh$|^src/_standalone)}"
# describe the files that are allowed to not have an associated bats file
BATS_FILE_NOT_NEEDED_REGEXP="${BATS_FILE_NOT_NEEDED_REGEXP:-(^bin/|.framework-config|.bats$|/testsData/|^manualTests/|/_.sh$|/ZZZ.sh$|/__all.sh$|^src/batsHeaders.sh$|^src/_includes)}"
# describe the files that are allowed to not have a function matching the filename
FRAMEWORK_FILES_FUNCTION_MATCHING_IGNORE_REGEXP="${FRAMEWORK_FILES_FUNCTION_MATCHING_IGNORE_REGEXP:-^bin/|^\.framework-config$|\.tpl$|/testsData/|^manualTests/|\.bats$}"
# Source directories
if [[ ! -v FRAMEWORK_SRC_DIRS ]]; then
  FRAMEWORK_SRC_DIRS=(
    "${FRAMEWORK_ROOT_DIR}/src"
  )
fi

# export here all the variables that will be used in your templates
export REPOSITORY_URL="${REPOSITORY_URL:-https://github.com/fchastanet/bash-tools-framework}"

BASH_FRAMEWORK_THEME="${BASH_FRAMEWORK_THEME:-default}"
BASH_FRAMEWORK_LOG_LEVEL="${BASH_FRAMEWORK_LOG_LEVEL:-0}"
BASH_FRAMEWORK_DISPLAY_LEVEL="${BASH_FRAMEWORK_DISPLAY_LEVEL:-3}"
BASH_FRAMEWORK_LOG_FILE="${BASH_FRAMEWORK_LOG_FILE:-${FRAMEWORK_ROOT_DIR}/logs/$(basename "$0").log}"
BASH_FRAMEWORK_LOG_FILE_MAX_ROTATION="${BASH_FRAMEWORK_LOG_FILE_MAX_ROTATION:-5}"
EOF
)"

overrideEnvFile="$(Framework::createTempFile "overrideEnvFile")"

commandOptionParseFinished() {
  # load default template framework config
  defaultEnvFile="${PERSISTENT_TMPDIR}/.framework-config"
  echo "${defaultFrameworkConfig}" > "${defaultEnvFile}"
  local -a files=("${defaultEnvFile}")
  if [[ -f "${envFile}" ]]; then
    files+=("${envFile}")
  fi
  # shellcheck disable=SC2154
  if [[ -f "${optionBashFrameworkConfig}" ]]; then
    files+=("${optionBashFrameworkConfig}")
  fi
  files+=("${overrideEnvFile}")
  Env::requireLoad "${files[@]}"
  Log::requireLoad
  # shellcheck disable=SC2154
  if [[ "${optionConfig}" = "1" ]]; then
    displayConfig
  fi
}

declare -a BASH_FRAMEWORK_ARGV_FILTERED=()

copyrightCallback() {
  if [[ -z "${copyrightBeginYear}" ]]; then
    copyrightBeginYear="$(date +%Y)"
  fi
  echo "Copyright (c) ${copyrightBeginYear}-now Franois Chastanet"
}

# shellcheck disable=SC2317 # if function is overridden
updateArgListInfoVerboseCallback() {
  BASH_FRAMEWORK_ARGV_FILTERED+=(--verbose)
}
# shellcheck disable=SC2317 # if function is overridden
updateArgListDebugVerboseCallback() {
  BASH_FRAMEWORK_ARGV_FILTERED+=(-vv)
}
# shellcheck disable=SC2317 # if function is overridden
updateArgListTraceVerboseCallback() {
  BASH_FRAMEWORK_ARGV_FILTERED+=(-vvv)
}
# shellcheck disable=SC2317 # if function is overridden
updateArgListEnvFileCallback() { :; }
# shellcheck disable=SC2317 # if function is overridden
updateArgListLogLevelCallback() { :; }
# shellcheck disable=SC2317 # if function is overridden
updateArgListDisplayLevelCallback() { :; }
# shellcheck disable=SC2317 # if function is overridden
updateArgListNoColorCallback() {
  BASH_FRAMEWORK_ARGV_FILTERED+=(--no-color)
}
# shellcheck disable=SC2317 # if function is overridden
updateArgListThemeCallback() { :; }
# shellcheck disable=SC2317 # if function is overridden
updateArgListQuietCallback() { :; }

# shellcheck disable=SC2317 # if function is overridden
optionHelpCallback() {
  installScriptCommand help
  exit 0
}

# shellcheck disable=SC2317 # if function is overridden
optionVersionCallback() {
  echo "${SCRIPT_NAME} version "
  exit 0
}

# shellcheck disable=SC2317 # if function is overridden
optionEnvFileCallback() {
  local envFile="$2"
  Log::displayWarning "Command ${SCRIPT_NAME} - Option --env-file is deprecated and will be removed in the future"
  if [[ ! -f "${envFile}" || ! -r "${envFile}" ]]; then
    Log::displayError "Command ${SCRIPT_NAME} - Option --env-file - File '${envFile}' doesn't exist"
    exit 1
  fi
}

# shellcheck disable=SC2317 # if function is overridden
optionInfoVerboseCallback() {
  BASH_FRAMEWORK_ARGS_VERBOSE_OPTION='--verbose'
  BASH_FRAMEWORK_ARGS_VERBOSE=${__VERBOSE_LEVEL_INFO}
  echo "BASH_FRAMEWORK_DISPLAY_LEVEL=${__LEVEL_INFO}" >> "${overrideEnvFile}"
}

# shellcheck disable=SC2317 # if function is overridden
optionDebugVerboseCallback() {
  BASH_FRAMEWORK_ARGS_VERBOSE_OPTION='-vv'
  BASH_FRAMEWORK_ARGS_VERBOSE=${__VERBOSE_LEVEL_DEBUG}
  echo "BASH_FRAMEWORK_DISPLAY_LEVEL=${__LEVEL_DEBUG}" >> "${overrideEnvFile}"
}

# shellcheck disable=SC2317 # if function is overridden
optionTraceVerboseCallback() {
  BASH_FRAMEWORK_ARGS_VERBOSE_OPTION='-vvv'
  BASH_FRAMEWORK_ARGS_VERBOSE=${__VERBOSE_LEVEL_TRACE}
  echo "BASH_FRAMEWORK_DISPLAY_LEVEL=${__LEVEL_DEBUG}" >> "${overrideEnvFile}"
}

getLevel() {
  local levelName="$1"
  case "${levelName^^}" in
    OFF)
      echo "${__LEVEL_OFF}"
      ;;
    ERR | ERROR)
      echo "${__LEVEL_ERROR}"
      ;;
    WARN | WARNING)
      echo "${__LEVEL_WARNING}"
      ;;
    INFO)
      echo "${__LEVEL_INFO}"
      ;;
    DEBUG | TRACE)
      echo "${__LEVEL_DEBUG}"
      ;;
    *)
      Log::displayError "Command ${SCRIPT_NAME} - Invalid level ${level}"
      return 1
  esac
}

getVerboseLevel() {
  local levelName="$1"
  case "${levelName^^}" in
    OFF)
      echo "${__VERBOSE_LEVEL_OFF}"
      ;;
    ERR | ERROR | WARN | WARNING | INFO)
      echo "${__VERBOSE_LEVEL_INFO}"
      ;;
    DEBUG)
      echo "${__VERBOSE_LEVEL_DEBUG}"
      ;;
    TRACE)
      echo "${__VERBOSE_LEVEL_TRACE}"
      ;;
    *)
      Log::displayError "Command ${SCRIPT_NAME} - Invalid level ${level}"
      return 1
  esac
}

# shellcheck disable=SC2317 # if function is overridden
optionDisplayLevelCallback() {
  local level="$2"
  local logLevel verboseLevel
  logLevel="$(getLevel "${level}")"
  verboseLevel="$(getVerboseLevel "${level}")"
  BASH_FRAMEWORK_ARGS_VERBOSE=${verboseLevel}
  echo "BASH_FRAMEWORK_DISPLAY_LEVEL=${logLevel}" >> "${overrideEnvFile}"
}

# shellcheck disable=SC2317 # if function is overridden
optionLogLevelCallback() {
  local level="$2"
  local logLevel verboseLevel
  logLevel="$(getLevel "${level}")"
  verboseLevel="$(getVerboseLevel "${level}")"
  BASH_FRAMEWORK_ARGS_VERBOSE=${verboseLevel}
  echo "BASH_FRAMEWORK_LOG_LEVEL=${logLevel}" >> "${overrideEnvFile}"
}

# shellcheck disable=SC2317 # if function is overridden
optionLogFileCallback() {
  local logFile="$2"
  echo "BASH_FRAMEWORK_LOG_FILE='${logFile}'" >> "${overrideEnvFile}"
}

# shellcheck disable=SC2317 # if function is overridden
optionQuietCallback() {
  echo "BASH_FRAMEWORK_QUIET_MODE=1" >> "${overrideEnvFile}"
}

# shellcheck disable=SC2317 # if function is overridden
optionNoColorCallback() {
  UI::theme "noColor"
}

# shellcheck disable=SC2317 # if function is overridden
optionThemeCallback() {
  UI::theme "$2"
}

displayConfig() {
  echo "Config"
  UI::drawLine "-"
  local var
  while read -r var; do
    printf '%-40s = %s\n' "${var}" "$(declare -p "${var}" | sed -E -e 's/^[^=]+=(.*)/\1/')"
  done < <(typeset -p | awk 'match($3, "^(BASH_FRAMEWORK_[^=]+)=", m) { print m[1] }' | sort)
  exit 0
}

optionBashFrameworkConfigCallback() {
  if [[ ! -f "$2" ]]; then
    Log::fatal "Command ${SCRIPT_NAME} - Bash framework config file '$2' does not exists"
  fi
}

defaultFrameworkConfig="$(
  cat <<'EOF'
# copied from src/_includes/.framework-config.default
# shellcheck disable=SC2034

REAL_SCRIPT_FILE="${REAL_SCRIPT_FILE:-$(readlink -e "$(realpath "${BASH_SOURCE[0]}")")}"
FRAMEWORK_ROOT_DIR="${FRAMEWORK_ROOT_DIR:-$(cd "$(readlink -e "${REAL_SCRIPT_FILE%/*}")/../.." && pwd -P)}"
FRAMEWORK_SRC_DIR="${FRAMEWORK_SRC_DIR:-${FRAMEWORK_ROOT_DIR}/src}"
FRAMEWORK_BIN_DIR="${FRAMEWORK_BIN_DIR:-${FRAMEWORK_ROOT_DIR}/bin}"
FRAMEWORK_VENDOR_DIR="${FRAMEWORK_VENDOR_DIR:-${FRAMEWORK_ROOT_DIR}/vendor}"
FRAMEWORK_VENDOR_BIN_DIR="${FRAMEWORK_VENDOR_BIN_DIR:-${FRAMEWORK_ROOT_DIR}/vendor/bin}"

# describe the functions that will be skipped from being imported
FRAMEWORK_FUNCTIONS_IGNORE_REGEXP="${FRAMEWORK_FUNCTIONS_IGNORE_REGEXP:-^(Namespace::functions|Functions::myFunction|Namespace::requireSomething|Acquire::ForceIPv4)$}"
# describe the files that do not contain function to be imported
NON_FRAMEWORK_FILES_REGEXP="${NON_FRAMEWORK_FILES_REGEXP:-(^bin/|.framework-config|.bats$|/testsData/|^manualTests/|/_.sh$|/ZZZ.sh$|/__all.sh$|^src/_binaries|^src/_includes|^src/batsHeaders.sh$|^src/_standalone)}"
# describe the files that are allowed to not have an associated bats file
BATS_FILE_NOT_NEEDED_REGEXP="${BATS_FILE_NOT_NEEDED_REGEXP:-(^bin/|.framework-config|.bats$|/testsData/|^manualTests/|/_.sh$|/ZZZ.sh$|/__all.sh$|^src/batsHeaders.sh$|^src/_includes)}"
# describe the files that are allowed to not have a function matching the filename
FRAMEWORK_FILES_FUNCTION_MATCHING_IGNORE_REGEXP="${FRAMEWORK_FILES_FUNCTION_MATCHING_IGNORE_REGEXP:-^bin/|^\.framework-config$|\.tpl$|/testsData/|^manualTests/|\.bats$}"
# Source directories
if [[ ! -v FRAMEWORK_SRC_DIRS ]]; then
  FRAMEWORK_SRC_DIRS=(
    "${FRAMEWORK_ROOT_DIR}/src"
  )
fi

# export here all the variables that will be used in your templates
export REPOSITORY_URL="${REPOSITORY_URL:-https://github.com/fchastanet/bash-tools-framework}"

BASH_FRAMEWORK_THEME="${BASH_FRAMEWORK_THEME:-default}"
BASH_FRAMEWORK_LOG_LEVEL="${BASH_FRAMEWORK_LOG_LEVEL:-0}"
BASH_FRAMEWORK_DISPLAY_LEVEL="${BASH_FRAMEWORK_DISPLAY_LEVEL:-3}"
BASH_FRAMEWORK_LOG_FILE="${BASH_FRAMEWORK_LOG_FILE:-${FRAMEWORK_ROOT_DIR}/logs/$(basename "$0").log}"
BASH_FRAMEWORK_LOG_FILE_MAX_ROTATION="${BASH_FRAMEWORK_LOG_FILE_MAX_ROTATION:-5}"
EOF
)"

overrideEnvFile="$(Framework::createTempFile "overrideEnvFile")"

commandOptionParseFinished() {
  # load default template framework config
  defaultEnvFile="${PERSISTENT_TMPDIR}/.framework-config"
  echo "${defaultFrameworkConfig}" > "${defaultEnvFile}"
  local -a files=("${defaultEnvFile}")
  if [[ -f "${envFile}" ]]; then
    files+=("${envFile}")
  fi
  # shellcheck disable=SC2154
  if [[ -f "${optionBashFrameworkConfig}" ]]; then
    files+=("${optionBashFrameworkConfig}")
  fi
  files+=("${overrideEnvFile}")
  Env::requireLoad "${files[@]}"
  Log::requireLoad
  # shellcheck disable=SC2154
  if [[ "${optionConfig}" = "1" ]]; then
    displayConfig
  fi
}

profileHelp() {
  echo "Profile name to use that contains all the softwares to install"
  echo "List of profiles available:"
  echo
  Conf::list "${BASH_DEV_ENV_ROOT_DIR}/profiles" "" ".sh" "-type f" "   - "  | sort | uniq
}

softwareArgHelp() {
  echo "List of softwares to install (--profile option cannot be used in this case)"
  echo "List of softwares available:"
  Conf::list "${BASH_DEV_ENV_ROOT_DIR}/installScripts" "" "" "-type f" "" |
    grep -v -E '^(_.*|MandatorySoftwares)$' | paste -s -d ',' | sed -e 's/,/, /g' || true

}

validateProfile() {
  if [[ ! -f "${BASH_DEV_ENV_ROOT_DIR}/profiles/$2.sh" ]]; then
    Log::fatal "Profile file ${BASH_DEV_ENV_ROOT_DIR}/$2.sh doesn't exist"
  fi
}

export SKIP_INSTALL
export SKIP_CONFIGURE
export SKIP_TEST
export PREPARE_EXPORT
export SKIP_DEPENDENCIES

installScriptCommand() {
  local options_parse_cmd="$1"
  shift || true

  if [[ "${options_parse_cmd}" = "parse" ]]; then
    SKIP_CONFIGURE="0"
    local -i options_parse_optionParsedCountSKIP_CONFIGURE
    ((options_parse_optionParsedCountSKIP_CONFIGURE = 0)) || true
    SKIP_INSTALL="0"
    local -i options_parse_optionParsedCountSKIP_INSTALL
    ((options_parse_optionParsedCountSKIP_INSTALL = 0)) || true
    SKIP_TEST="0"
    local -i options_parse_optionParsedCountSKIP_TEST
    ((options_parse_optionParsedCountSKIP_TEST = 0)) || true
    SKIP_DEPENDENCIES="0"
    local -i options_parse_optionParsedCountSKIP_DEPENDENCIES
    ((options_parse_optionParsedCountSKIP_DEPENDENCIES = 0)) || true
    PREPARE_EXPORT="0"
    local -i options_parse_optionParsedCountPREPARE_EXPORT
    ((options_parse_optionParsedCountPREPARE_EXPORT = 0)) || true
    local -i options_parse_optionParsedCountOptionBashFrameworkConfig
    ((options_parse_optionParsedCountOptionBashFrameworkConfig = 0)) || true
    optionConfig="0"
    local -i options_parse_optionParsedCountOptionConfig
    ((options_parse_optionParsedCountOptionConfig = 0)) || true
    optionInfoVerbose="0"
    local -i options_parse_optionParsedCountOptionInfoVerbose
    ((options_parse_optionParsedCountOptionInfoVerbose = 0)) || true
    optionDebugVerbose="0"
    local -i options_parse_optionParsedCountOptionDebugVerbose
    ((options_parse_optionParsedCountOptionDebugVerbose = 0)) || true
    optionTraceVerbose="0"
    local -i options_parse_optionParsedCountOptionTraceVerbose
    ((options_parse_optionParsedCountOptionTraceVerbose = 0)) || true
    optionNoColor="0"
    local -i options_parse_optionParsedCountOptionNoColor
    ((options_parse_optionParsedCountOptionNoColor = 0)) || true
    optionTheme="default"
    local -i options_parse_optionParsedCountOptionTheme
    ((options_parse_optionParsedCountOptionTheme = 0)) || true
    optionHelp="0"
    local -i options_parse_optionParsedCountOptionHelp
    ((options_parse_optionParsedCountOptionHelp = 0)) || true
    optionVersion="0"
    local -i options_parse_optionParsedCountOptionVersion
    ((options_parse_optionParsedCountOptionVersion = 0)) || true
    optionQuiet="0"
    local -i options_parse_optionParsedCountOptionQuiet
    ((options_parse_optionParsedCountOptionQuiet = 0)) || true
    local -i options_parse_optionParsedCountOptionLogLevel
    ((options_parse_optionParsedCountOptionLogLevel = 0)) || true
    local -i options_parse_optionParsedCountOptionLogFile
    ((options_parse_optionParsedCountOptionLogFile = 0)) || true
    local -i options_parse_optionParsedCountOptionDisplayLevel
    ((options_parse_optionParsedCountOptionDisplayLevel = 0)) || true
    # shellcheck disable=SC2034
    local -i options_parse_parsedArgIndex=0
    while (($# > 0)); do
      local options_parse_arg="$1"
      local argOptDefaultBehavior=0
      case "${options_parse_arg}" in
        # Option 1/19
        # Option SKIP_CONFIGURE --skip-config|--skip-configure|--skip-configuration variableType Boolean min 0 max 1 authorizedValues '' regexp ''
        --skip-config | --skip-configure | --skip-configuration)
          # shellcheck disable=SC2034
          SKIP_CONFIGURE="1"
          if ((options_parse_optionParsedCountSKIP_CONFIGURE >= 1)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
            return 1
          fi
          ((++options_parse_optionParsedCountSKIP_CONFIGURE))
          ;;
        # Option 2/19
        # Option SKIP_INSTALL --skip-install|--skip-installation variableType Boolean min 0 max 1 authorizedValues '' regexp ''
        --skip-install | --skip-installation)
          # shellcheck disable=SC2034
          SKIP_INSTALL="1"
          if ((options_parse_optionParsedCountSKIP_INSTALL >= 1)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
            return 1
          fi
          ((++options_parse_optionParsedCountSKIP_INSTALL))
          ;;
        # Option 3/19
        # Option SKIP_TEST --skip-test|--skip-tests variableType Boolean min 0 max 1 authorizedValues '' regexp ''
        --skip-test | --skip-tests)
          # shellcheck disable=SC2034
          SKIP_TEST="1"
          if ((options_parse_optionParsedCountSKIP_TEST >= 1)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
            return 1
          fi
          ((++options_parse_optionParsedCountSKIP_TEST))
          ;;
        # Option 4/19
        # Option SKIP_DEPENDENCIES --skip-dependencies|--skip-deps variableType Boolean min 0 max 1 authorizedValues '' regexp ''
        --skip-dependencies | --skip-deps)
          # shellcheck disable=SC2034
          SKIP_DEPENDENCIES="1"
          if ((options_parse_optionParsedCountSKIP_DEPENDENCIES >= 1)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
            return 1
          fi
          ((++options_parse_optionParsedCountSKIP_DEPENDENCIES))
          ;;
        # Option 5/19
        # Option PREPARE_EXPORT --prepare-export|-e variableType Boolean min 0 max 1 authorizedValues '' regexp ''
        --prepare-export | -e)
          # shellcheck disable=SC2034
          PREPARE_EXPORT="1"
          if ((options_parse_optionParsedCountPREPARE_EXPORT >= 1)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
            return 1
          fi
          ((++options_parse_optionParsedCountPREPARE_EXPORT))
          ;;
        # Option 6/19
        # Option optionBashFrameworkConfig --bash-framework-config variableType String min 0 max 1 authorizedValues '' regexp ''
        --bash-framework-config)
          shift
          if (($# == 0)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - a value needs to be specified"
            return 1
          fi
          if ((options_parse_optionParsedCountOptionBashFrameworkConfig >= 1)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
            return 1
          fi
          ((++options_parse_optionParsedCountOptionBashFrameworkConfig))
          # shellcheck disable=SC2034
          optionBashFrameworkConfig="$1"
          optionBashFrameworkConfigCallback "${options_parse_arg}" "${optionBashFrameworkConfig}"
          ;;
        # Option 7/19
        # Option optionConfig --config variableType Boolean min 0 max 1 authorizedValues '' regexp ''
        --config)
          # shellcheck disable=SC2034
          optionConfig="1"
          if ((options_parse_optionParsedCountOptionConfig >= 1)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
            return 1
          fi
          ((++options_parse_optionParsedCountOptionConfig))
          ;;
        # Option 8/19
        # Option optionInfoVerbose --verbose|-v variableType Boolean min 0 max 1 authorizedValues '' regexp ''
        --verbose | -v)
          # shellcheck disable=SC2034
          optionInfoVerbose="1"
          if ((options_parse_optionParsedCountOptionInfoVerbose >= 1)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
            return 1
          fi
          ((++options_parse_optionParsedCountOptionInfoVerbose))
          optionInfoVerboseCallback "${options_parse_arg}"
          updateArgListInfoVerboseCallback "${options_parse_arg}"
          ;;
        # Option 9/19
        # Option optionDebugVerbose -vv variableType Boolean min 0 max 1 authorizedValues '' regexp ''
        -vv)
          # shellcheck disable=SC2034
          optionDebugVerbose="1"
          if ((options_parse_optionParsedCountOptionDebugVerbose >= 1)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
            return 1
          fi
          ((++options_parse_optionParsedCountOptionDebugVerbose))
          optionDebugVerboseCallback "${options_parse_arg}"
          updateArgListDebugVerboseCallback "${options_parse_arg}"
          ;;
        # Option 10/19
        # Option optionTraceVerbose -vvv variableType Boolean min 0 max 1 authorizedValues '' regexp ''
        -vvv)
          # shellcheck disable=SC2034
          optionTraceVerbose="1"
          if ((options_parse_optionParsedCountOptionTraceVerbose >= 1)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
            return 1
          fi
          ((++options_parse_optionParsedCountOptionTraceVerbose))
          optionTraceVerboseCallback "${options_parse_arg}"
          updateArgListTraceVerboseCallback "${options_parse_arg}"
          ;;
        # Option 11/19
        # Option optionEnvFiles --env-file variableType StringArray min 0 max -1 authorizedValues '' regexp ''
        --env-file)
          shift
          if (($# == 0)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - a value needs to be specified"
            return 1
          fi
          ((++options_parse_optionParsedCountOptionEnvFiles))
          optionEnvFiles+=("$1")
          optionEnvFileCallback "${options_parse_arg}" "${optionEnvFiles[@]}"
          updateArgListEnvFileCallback "${options_parse_arg}" "${optionEnvFiles[@]}"
          ;;
        # Option 12/19
        # Option optionNoColor --no-color variableType Boolean min 0 max 1 authorizedValues '' regexp ''
        --no-color)
          # shellcheck disable=SC2034
          optionNoColor="1"
          if ((options_parse_optionParsedCountOptionNoColor >= 1)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
            return 1
          fi
          ((++options_parse_optionParsedCountOptionNoColor))
          optionNoColorCallback "${options_parse_arg}"
          updateArgListNoColorCallback "${options_parse_arg}"
          ;;
        # Option 13/19
        # Option optionTheme --theme variableType String min 0 max 1 authorizedValues 'default|default-force|noColor' regexp ''
        --theme)
          shift
          if (($# == 0)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - a value needs to be specified"
            return 1
          fi
          if [[ ! "$1" =~ default|default-force|noColor ]]; then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - value '$1' is not part of authorized values(default|default-force|noColor)"
            return 1
          fi
          if ((options_parse_optionParsedCountOptionTheme >= 1)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
            return 1
          fi
          ((++options_parse_optionParsedCountOptionTheme))
          # shellcheck disable=SC2034
          optionTheme="$1"
          optionThemeCallback "${options_parse_arg}" "${optionTheme}"
          updateArgListThemeCallback "${options_parse_arg}" "${optionTheme}"
          ;;
        # Option 14/19
        # Option optionHelp --help|-h variableType Boolean min 0 max 1 authorizedValues '' regexp ''
        --help | -h)
          # shellcheck disable=SC2034
          optionHelp="1"
          if ((options_parse_optionParsedCountOptionHelp >= 1)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
            return 1
          fi
          ((++options_parse_optionParsedCountOptionHelp))
          optionHelpCallback "${options_parse_arg}"
          ;;
        # Option 15/19
        # Option optionVersion --version variableType Boolean min 0 max 1 authorizedValues '' regexp ''
        --version)
          # shellcheck disable=SC2034
          optionVersion="1"
          if ((options_parse_optionParsedCountOptionVersion >= 1)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
            return 1
          fi
          ((++options_parse_optionParsedCountOptionVersion))
          optionVersionCallback "${options_parse_arg}"
          ;;
        # Option 16/19
        # Option optionQuiet --quiet|-q variableType Boolean min 0 max 1 authorizedValues '' regexp ''
        --quiet | -q)
          # shellcheck disable=SC2034
          optionQuiet="1"
          if ((options_parse_optionParsedCountOptionQuiet >= 1)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
            return 1
          fi
          ((++options_parse_optionParsedCountOptionQuiet))
          optionQuietCallback "${options_parse_arg}"
          updateArgListQuietCallback "${options_parse_arg}"
          ;;
        # Option 17/19
        # Option optionLogLevel --log-level variableType String min 0 max 1 authorizedValues 'OFF|ERR|ERROR|WARN|WARNING|INFO|DEBUG|TRACE' regexp ''
        --log-level)
          shift
          if (($# == 0)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - a value needs to be specified"
            return 1
          fi
          if [[ ! "$1" =~ OFF|ERR|ERROR|WARN|WARNING|INFO|DEBUG|TRACE ]]; then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - value '$1' is not part of authorized values(OFF|ERR|ERROR|WARN|WARNING|INFO|DEBUG|TRACE)"
            return 1
          fi
          if ((options_parse_optionParsedCountOptionLogLevel >= 1)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
            return 1
          fi
          ((++options_parse_optionParsedCountOptionLogLevel))
          # shellcheck disable=SC2034
          optionLogLevel="$1"
          optionLogLevelCallback "${options_parse_arg}" "${optionLogLevel}"
          updateArgListLogLevelCallback "${options_parse_arg}" "${optionLogLevel}"
          ;;
        # Option 18/19
        # Option optionLogFile --log-file variableType String min 0 max 1 authorizedValues '' regexp ''
        --log-file)
          shift
          if (($# == 0)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - a value needs to be specified"
            return 1
          fi
          if ((options_parse_optionParsedCountOptionLogFile >= 1)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
            return 1
          fi
          ((++options_parse_optionParsedCountOptionLogFile))
          # shellcheck disable=SC2034
          optionLogFile="$1"
          optionLogFileCallback "${options_parse_arg}" "${optionLogFile}"
          updateArgListLogFileCallback "${options_parse_arg}" "${optionLogFile}"
          ;;
        # Option 19/19
        # Option optionDisplayLevel --display-level variableType String min 0 max 1 authorizedValues 'OFF|ERR|ERROR|WARN|WARNING|INFO|DEBUG|TRACE' regexp ''
        --display-level)
          shift
          if (($# == 0)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - a value needs to be specified"
            return 1
          fi
          if [[ ! "$1" =~ OFF|ERR|ERROR|WARN|WARNING|INFO|DEBUG|TRACE ]]; then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - value '$1' is not part of authorized values(OFF|ERR|ERROR|WARN|WARNING|INFO|DEBUG|TRACE)"
            return 1
          fi
          if ((options_parse_optionParsedCountOptionDisplayLevel >= 1)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
            return 1
          fi
          ((++options_parse_optionParsedCountOptionDisplayLevel))
          # shellcheck disable=SC2034
          optionDisplayLevel="$1"
          optionDisplayLevelCallback "${options_parse_arg}" "${optionDisplayLevel}"
          updateArgListDisplayLevelCallback "${options_parse_arg}" "${optionDisplayLevel}"
          ;;
        -*)
          if [[ "${argOptDefaultBehavior}" = "0" ]]; then
            Log::displayError "Command ${SCRIPT_NAME} - Invalid option ${options_parse_arg}"
            return 1
          fi
          ;;
        *)
          if [[ "${argOptDefaultBehavior}" = "0" ]]; then
            Log::displayError "Command ${SCRIPT_NAME} - Argument - too much arguments provided"
            return 1
          fi
          ;;
      esac
      shift || true
    done
    commandOptionParseFinished
    InstallScripts::command
    Log::displayDebug "Command ${SCRIPT_NAME} - parse arguments: ${BASH_FRAMEWORK_ARGV[*]}"
    Log::displayDebug "Command ${SCRIPT_NAME} - parse filtered arguments: ${BASH_FRAMEWORK_ARGV_FILTERED[*]}"
  elif [[ "${options_parse_cmd}" = "help" ]]; then
    Array::wrap2 ' ' 80 0 "\e[1;37mDESCRIPTION:\e[0m" "$(helpDescriptionCallback)"
    echo

    echo -e "$(Array::wrap2 " " 80 2 "${__HELP_TITLE_COLOR}USAGE:${__RESET_COLOR}" "${SCRIPT_NAME}" "[OPTIONS]")"
    echo -e "$(Array::wrap2 " " 80 2 "${__HELP_TITLE_COLOR}USAGE:${__RESET_COLOR}" \
      "${SCRIPT_NAME}" \
      "[--skip-config|--skip-configure|--skip-configuration]" "[--skip-install|--skip-installation]" "[--skip-test|--skip-tests]" "[--skip-dependencies|--skip-deps]" "[--prepare-export|-e]" "[--bash-framework-config <String>]" "[--config]" "[--verbose|-v]" "[-vv]" "[-vvv]" "[--env-file <String>]" "[--no-color]" "[--theme <String>]" "[--help|-h]" "[--version]" "[--quiet|-q]" "[--log-level <String>]" "[--log-file <String>]" "[--display-level <String>]")"
    echo
    echo -e "${__HELP_TITLE_COLOR}OPTIONS:${__RESET_COLOR}"
    echo -e "  ${__HELP_OPTION_COLOR}--skip-config${__HELP_NORMAL}, ${__HELP_OPTION_COLOR}--skip-configure${__HELP_NORMAL}, ${__HELP_OPTION_COLOR}--skip-configuration${__HELP_NORMAL} {single}"
    local -a helpArray
    # shellcheck disable=SC2054
    helpArray=(skip\ software\ configuration)
    echo -e "    $(Array::wrap2 " " 76 4 "${helpArray[@]}")"
    echo -e "  ${__HELP_OPTION_COLOR}--skip-install${__HELP_NORMAL}, ${__HELP_OPTION_COLOR}--skip-installation${__HELP_NORMAL} {single}"
    local -a helpArray
    # shellcheck disable=SC2054
    helpArray=(skip\ software\ installation)
    echo -e "    $(Array::wrap2 " " 76 4 "${helpArray[@]}")"
    echo -e "  ${__HELP_OPTION_COLOR}--skip-test${__HELP_NORMAL}, ${__HELP_OPTION_COLOR}--skip-tests${__HELP_NORMAL} {single}"
    local -a helpArray
    # shellcheck disable=SC2054
    helpArray=(skip\ software\ installation\ test)
    echo -e "    $(Array::wrap2 " " 76 4 "${helpArray[@]}")"
    echo -e "  ${__HELP_OPTION_COLOR}--skip-dependencies${__HELP_NORMAL}, ${__HELP_OPTION_COLOR}--skip-deps${__HELP_NORMAL} {single}"
    local -a helpArray
    # shellcheck disable=SC2054
    helpArray=(install\ the\ software\ requested\ without\ resolving\ dependencies)
    echo -e "    $(Array::wrap2 " " 76 4 "${helpArray[@]}")"
    echo -e "  ${__HELP_OPTION_COLOR}--prepare-export${__HELP_NORMAL}, ${__HELP_OPTION_COLOR}-e${__HELP_NORMAL} {single}"
    local -a helpArray
    # shellcheck disable=SC2054
    helpArray=(prepare\ the\ wsl\ installation\ for\ export\ \(remove\ all\ sensitive\ files\))
    echo -e "    $(Array::wrap2 " " 76 4 "${helpArray[@]}")"
    echo
    echo -e "${__HELP_TITLE_COLOR}GLOBAL OPTIONS:${__RESET_COLOR}"
    echo -e "  ${__HELP_OPTION_COLOR}--bash-framework-config <String>${__HELP_NORMAL} {single}"
    local -a helpArray
    # shellcheck disable=SC2054
    helpArray=(use\ alternate\ bash\ framework\ configuration.)
    echo -e "    $(Array::wrap2 " " 76 4 "${helpArray[@]}")"
    echo -e "  ${__HELP_OPTION_COLOR}--config${__HELP_NORMAL} {single}"
    local -a helpArray
    # shellcheck disable=SC2054
    helpArray=(Display\ configuration)
    echo -e "    $(Array::wrap2 " " 76 4 "${helpArray[@]}")"
    echo -e "  ${__HELP_OPTION_COLOR}--verbose${__HELP_NORMAL}, ${__HELP_OPTION_COLOR}-v${__HELP_NORMAL} {single}"
    local -a helpArray
    # shellcheck disable=SC2054
    helpArray=(info\ level\ verbose\ mode\ \(alias\ of\ --display-level\ INFO\))
    echo -e "    $(Array::wrap2 " " 76 4 "${helpArray[@]}")"
    echo -e "  ${__HELP_OPTION_COLOR}-vv${__HELP_NORMAL} {single}"
    local -a helpArray
    # shellcheck disable=SC2054
    helpArray=(debug\ level\ verbose\ mode\ \(alias\ of\ --display-level\ DEBUG\))
    echo -e "    $(Array::wrap2 " " 76 4 "${helpArray[@]}")"
    echo -e "  ${__HELP_OPTION_COLOR}-vvv${__HELP_NORMAL} {single}"
    local -a helpArray
    # shellcheck disable=SC2054
    helpArray=(trace\ level\ verbose\ mode\ \(alias\ of\ --display-level\ TRACE\))
    echo -e "    $(Array::wrap2 " " 76 4 "${helpArray[@]}")"
    echo -e "  ${__HELP_OPTION_COLOR}--env-file <String>${__HELP_NORMAL} {list} (optional)"
    local -a helpArray
    # shellcheck disable=SC2054
    helpArray=(Load\ the\ specified\ env\ file\ \(deprecated\,\ please\ use\ --bash-framework-config\ option\ instead\))
    echo -e "    $(Array::wrap2 " " 76 4 "${helpArray[@]}")"
    echo -e "  ${__HELP_OPTION_COLOR}--no-color${__HELP_NORMAL} {single}"
    local -a helpArray
    # shellcheck disable=SC2054
    helpArray=(Produce\ monochrome\ output.\ alias\ of\ --theme\ noColor.)
    echo -e "    $(Array::wrap2 " " 76 4 "${helpArray[@]}")"
    echo -e "  ${__HELP_OPTION_COLOR}--theme <String>${__HELP_NORMAL} {single}"
    local -a helpArray
    # shellcheck disable=SC2054
    helpArray=(choose\ color\ theme\ -\ default-force\ means\ colors\ will\ be\ produced\ even\ if\ command\ is\ piped)
    echo -e "    $(Array::wrap2 " " 76 4 "${helpArray[@]}")"
    echo '    Default value: default'
    echo '    Possible values: default|default-force|noColor'
    echo -e "  ${__HELP_OPTION_COLOR}--help${__HELP_NORMAL}, ${__HELP_OPTION_COLOR}-h${__HELP_NORMAL} {single}"
    local -a helpArray
    # shellcheck disable=SC2054
    helpArray=(Display\ this\ command\ help)
    echo -e "    $(Array::wrap2 " " 76 4 "${helpArray[@]}")"
    echo -e "  ${__HELP_OPTION_COLOR}--version${__HELP_NORMAL} {single}"
    local -a helpArray
    # shellcheck disable=SC2054
    helpArray=(Print\ version\ information\ and\ quit)
    echo -e "    $(Array::wrap2 " " 76 4 "${helpArray[@]}")"
    echo -e "  ${__HELP_OPTION_COLOR}--quiet${__HELP_NORMAL}, ${__HELP_OPTION_COLOR}-q${__HELP_NORMAL} {single}"
    local -a helpArray
    # shellcheck disable=SC2054
    helpArray=(quiet\ mode\,\ doesn\'t\ display\ any\ output)
    echo -e "    $(Array::wrap2 " " 76 4 "${helpArray[@]}")"
    echo -e "  ${__HELP_OPTION_COLOR}--log-level <String>${__HELP_NORMAL} {single}"
    local -a helpArray
    # shellcheck disable=SC2054
    helpArray=(Set\ log\ level)
    echo -e "    $(Array::wrap2 " " 76 4 "${helpArray[@]}")"
    echo '    Possible values: OFF|ERR|ERROR|WARN|WARNING|INFO|DEBUG|TRACE'
    echo -e "  ${__HELP_OPTION_COLOR}--log-file <String>${__HELP_NORMAL} {single}"
    local -a helpArray
    # shellcheck disable=SC2054
    helpArray=(Set\ log\ file)
    echo -e "    $(Array::wrap2 " " 76 4 "${helpArray[@]}")"
    echo -e "  ${__HELP_OPTION_COLOR}--display-level <String>${__HELP_NORMAL} {single}"
    local -a helpArray
    # shellcheck disable=SC2054
    helpArray=(set\ display\ level)
    echo -e "    $(Array::wrap2 " " 76 4 "${helpArray[@]}")"
    echo '    Possible values: OFF|ERR|ERROR|WARN|WARNING|INFO|DEBUG|TRACE'
    Array::wrap2 ' ' 76 0 "$(helpLongDescriptionCallback)"
    echo
    echo -e "${__HELP_TITLE_COLOR}AUTHOR:${__RESET_COLOR}"
    echo '[Franois Chastanet](https://github.com/fchastanet)'
    echo
    echo -e "${__HELP_TITLE_COLOR}SOURCE FILE:${__RESET_COLOR}"
    echo 'https://github.com/fchastanet/bash-dev-env/tree/master/src/_binaries/installScripts/Docker.sh'
    echo
    echo -e "${__HELP_TITLE_COLOR}LICENSE:${__RESET_COLOR}"
    echo 'MIT License'
    echo
    Array::wrap2 ' ' 76 4 "$(copyrightCallback)"
  else
    Log::displayError "Command ${SCRIPT_NAME} - Option command invalid: '${options_parse_cmd}'"
    return 1
  fi
}

# default action called by the facade if no interface action recognized
defaultFacadeAction() {
  installScriptCommand parse "${BASH_FRAMEWORK_ARGV[@]}"
}

stringOrNone() {
  local string="$1"
  echo -e "${string:-${__HELP_EXAMPLE}None${__HELP_NORMAL}}"
}

helpDescriptionCallback() {
  helpDescription
  echo
}

helpLongDescriptionCallback() {
  helpDescription
  echo

  echo -e "${__HELP_TITLE}List of needed variables:${__HELP_NORMAL}"
  stringOrNone "$(helpVariables)"

  echo -e "${__HELP_TITLE}List of dependencies:${__HELP_NORMAL}"
  stringOrNone "$(dependencies)"
}

scriptName() {
  echo "Docker"
}

helpDescription() {
  echo "install docker and docker-compose inside wsl"
}

helpVariables() {
  true
}

listVariables() {
  true
}

defaultVariables() {
  true
}

checkVariables() {
  true
}

fortunes() {
  return 0
}

dependencies() {
  echo "MandatorySoftwares"
  echo "WslConfig"
}

breakOnConfigFailure() {
  return 0
}

breakOnTestFailure() {
  return 0
}

# REQUIRE Linux::requireUbuntu
# REQUIRE Linux::requireExecutedAsUser
install() {
  Log::displayInfo "install docker required packages"
  Linux::Apt::update
  Linux::Apt::install \
    apt-transport-https \
    ca-certificates \
    curl \
    gnupg2

  # Docker utilizes iptables to implement network isolation.
  # For good reason, Debian uses the more modern nftables, but this means
  # that Docker cannot automatically tweak the Linux firewall.
  # Given this, you probably want to configure Debian to use the legacy
  # iptables by default
  sudo update-alternatives --set iptables /usr/sbin/iptables-legacy

  Log::displayInfo "install docker apt source list"
  Retry::default curl -fsSL "https://download.docker.com/linux/${ID}/gpg" | sudo apt-key add -
  local dockerSource="deb [arch=amd64] https://download.docker.com/linux/${ID} ${VERSION_CODENAME} stable"
  if ! grep -q "${dockerSource}" "/etc/apt/sources.list.d/docker.list"; then
    echo "deb [arch=amd64] https://download.docker.com/linux/${ID} ${VERSION_CODENAME} stable" | sudo tee /etc/apt/sources.list.d/docker.list
    Linux::Apt::update
  fi

  Log::displayInfo "install docker"
  Retry::default sudo apt-get install -y \
    containerd.io \
    docker-ce \
    docker-ce-cli

  USERNAME="$(id -un)"
  Log::displayInfo "allowing user '${USERNAME}' to use docker"
  sudo getent group docker >/dev/null || sudo groupadd docker || true
  sudo usermod -aG docker "${USERNAME}" || true

  Log::displayInfo "Installing docker-compose"
  # shellcheck disable=SC2317
  dockerComposeVersionCallback() {
    echo "v$(Version::getCommandVersionFromPlainText "$@")"
  }
  export -f dockerComposeVersionCallback
  # shellcheck disable=SC2154
  SUDO=sudo "${embed_function_GithubUpgradeRelease}" \
    /usr/local/bin/docker-compose \
    "https://github.com/docker/compose/releases/download/@latestVersion@/docker-compose-$(uname -s | tr '[:upper:]' '[:lower:]')-$(uname -m)" \
    "--version" \
    dockerComposeVersionCallback

  sudo rm -f /usr/bin/docker-compose || true
  sudo ln -sf /usr/local/bin/docker-compose /usr/bin/docker-compose
}

configure() {
  Log::displayInfo "Configuring docker-compose as docker plugin"
  # create the docker plugins directory if it doesn't exist yet
  # shellcheck disable=SC2153
  mkdir -p "${USER_HOME}/.docker/cli-plugins"
  rm -f "${HOME}/.docker/cli-plugins/docker-compose" || true
  sudo ln -sf /usr/local/bin/docker-compose "${HOME}/.docker/cli-plugins/docker-compose"
}

testInstall() {
  local -i failures=0

  if ! Linux::isSystemdRunning; then
    if grep -q -E '^systemd=true' /etc/wsl.conf; then
      Log::fatal "You need to restart wsl by running 'wsl --shutdown' from powershell and re-run this script, in order to start with systemd"
    else
      Log::fatal "/etc/wsl.conf has not been updated with systemd=true instruction, please check this install logs"
    fi
  fi

  Version::checkMinimal "docker" --version "25.0.3" || ((++failures))
  Version::checkMinimal "docker-compose" --version "2.23.1" || ((++failures))

  echo
  UI::drawLine "-"
  Log::displayInfo "docker executable path $(command -v docker || true)"
  Log::displayInfo "docker version $(docker --version || true)"
  Log::displayInfo "docker-compose version $(docker-compose --version || true)"

  dockerIsStarted() {
    DOCKER_PS="$(docker ps 2>&1 || true)"
    [[ ! "${DOCKER_PS}" =~ "Cannot connect to the Docker daemon" ]]
  }
  Log::displayInfo "Checking if docker is started ..."
  if dockerIsStarted; then
    Log::displaySuccess "Docker connection success"
  else
    Log::displayError "Docker is not started"
    ((++failures))
  fi
  return "${failures}"
}

testConfigure() {
  local -i failures=0

  Log::displayInfo "check if docker-compose binary is working"
  if ! docker-compose version &>/dev/null; then
    Log::displayError "docker-compose failure"
    ((++failures))
  fi

  Log::displayInfo "check if docker compose plugin is installed"
  if [[ ! -f "${HOME}/.docker/cli-plugins/docker-compose" ]]; then
    Log::displayError "docker compose plugin not installed in folder ${HOME}/.docker/cli-plugins/"
    ((++failures))
  fi

  Log::displayInfo "check if docker compose plugin is working"
  if ! docker compose version &>/dev/null; then
    Log::displayError "docker compose plugin failure"
    ((++failures))
  fi

  Log::displayInfo "check if docker dns is working"
  docker run busybox ping google.com -c 1 &>/dev/null || {
    ((++failures))
    Log::displayError "google.com is not reachable from docker, dns issue ?"
    ping google.com -c 1 &>/dev/null || {
      Log::displayError "google.com is not reachable from host neither"
      ((++failures))
    }
  }

  Log::displayInfo "check if docker container can be launched"
  if ! docker run --rm hello-world | grep -q "Hello from Docker!"; then
    ((++failures))
    Log::displayError "docker container cannot be launched"
  fi
  docker image rm hello-world || true

  return "${failures}"
}

local action=$1
shift || true
case ${action} in
  scriptName)
    scriptName "$@"
    ;;
  helpDescription)
    helpDescription "$@"
    ;;
  helpVariables)
    helpVariables "$@"
    ;;
  listVariables)
    listVariables "$@"
    ;;
  defaultVariables)
    defaultVariables "$@"
    ;;
  checkVariables)
    checkVariables "$@"
    ;;
  fortunes)
    fortunes "$@"
    ;;
  dependencies)
    dependencies "$@"
    ;;
  breakOnConfigFailure)
    breakOnConfigFailure "$@"
    ;;
  breakOnTestFailure)
    breakOnTestFailure "$@"
    ;;
  install)
    install "$@"
    ;;
  configure)
    configure "$@"
    ;;
  testInstall)
    testInstall "$@"
    ;;
  testConfigure)
    testConfigure "$@"
    ;;
  *)
    if Assert::functionExists defaultFacadeAction; then
      defaultFacadeAction "$1" "$@"
    else
      Log::displayError "invalid action requested: ${action}"
      exit 1
    fi
    ;;
esac
exit 0
}

facade_main_Dockersh "$@"
