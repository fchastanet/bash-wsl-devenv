#!/usr/bin/env bash
###############################################################################
# GENERATED FACADE FROM https://github.com/fchastanet/bash-dev-env/tree/master/src/_binaries/ShellZsh/ShellZsh.sh
# DO NOT EDIT IT
# @generated
###############################################################################
# shellcheck disable=SC2288,SC2034
# BIN_FILE=${BASH_DEV_ENV_ROOT_DIR}/installScripts/ShellZsh

# ensure that no user aliases could interfere with
# commands used in this script
unalias -a || true
shopt -u expand_aliases

# shellcheck disable=SC2034
((failures = 0)) || true

# Bash will remember & return the highest exit code in a chain of pipes.
# This way you can catch the error inside pipes, e.g. mysqldump | gzip
set -o pipefail
set -o errexit

# Command Substitution can inherit errexit option since bash v4.4
shopt -s inherit_errexit || true

# if set, and job control is not active, the shell runs the last command
# of a pipeline not executed in the background in the current shell
# environment.
shopt -s lastpipe

# a log is generated when a command fails
set -o errtrace

# use nullglob so that (file*.php) will return an empty array if no file
# matches the wildcard
shopt -s nullglob

# ensure regexp are interpreted without accentuated characters
export LC_ALL=POSIX

export TERM=xterm-256color

# avoid interactive install
export DEBIAN_FRONTEND=noninteractive
export DEBCONF_NONINTERACTIVE_SEEN=true

# store command arguments for later usage
# shellcheck disable=SC2034
declare -a BASH_FRAMEWORK_ARGV=("$@")
# shellcheck disable=SC2034
declare -a ORIGINAL_BASH_FRAMEWORK_ARGV=("$@")

# @see https://unix.stackexchange.com/a/386856
# shellcheck disable=SC2317
interruptManagement() {
  # restore SIGINT handler
  trap - INT
  # ensure that Ctrl-C is trapped by this script and not by sub process
  # report to the parent that we have indeed been interrupted
  kill -s INT "$$"
}
trap interruptManagement INT
SCRIPT_NAME=${0##*/}
REAL_SCRIPT_FILE="$(readlink -e "$(realpath "${BASH_SOURCE[0]}")")"
if [[ -n "${EMBED_CURRENT_DIR}" ]]; then
  CURRENT_DIR="${EMBED_CURRENT_DIR}"
else
  CURRENT_DIR="${REAL_SCRIPT_FILE%/*}"
fi

################################################
# Temp dir management
################################################

KEEP_TEMP_FILES="${KEEP_TEMP_FILES:-0}"
export KEEP_TEMP_FILES

# PERSISTENT_TMPDIR is not deleted by traps
PERSISTENT_TMPDIR="${TMPDIR:-/tmp}/bash-framework"
export PERSISTENT_TMPDIR
if [[ ! -d "${PERSISTENT_TMPDIR}" ]]; then
  mkdir -p "${PERSISTENT_TMPDIR}"
fi

# shellcheck disable=SC2034
TMPDIR="$(mktemp -d -p "${PERSISTENT_TMPDIR:-/tmp}" -t bash-framework-$$-XXXXXX)"
export TMPDIR

# temp dir cleaning
# shellcheck disable=SC2317
cleanOnExit() {
  local rc=$?
  if [[ "${KEEP_TEMP_FILES:-0}" = "1" ]]; then
    Log::displayInfo "KEEP_TEMP_FILES=1 temp files kept here '${TMPDIR}'"
  elif [[ -n "${TMPDIR+xxx}" ]]; then
    Log::displayDebug "KEEP_TEMP_FILES=0 removing temp files '${TMPDIR}'"
    rm -Rf "${TMPDIR:-/tmp/fake}" >/dev/null 2>&1
  fi
  exit "${rc}"
}
trap cleanOnExit EXIT HUP QUIT ABRT TERM

# @description Log namespace provides 2 kind of functions
# - Log::display* allows to display given message with
#   given display level
# - Log::log* allows to log given message with
#   given log level
# Log::display* functions automatically log the message too
# @see Env::requireLoad to load the display and log level from .env file

# @description log level off
export __LEVEL_OFF=0
# @description log level error
export __LEVEL_ERROR=1
# @description log level warning
export __LEVEL_WARNING=2
# @description log level info
export __LEVEL_INFO=3
# @description log level success
export __LEVEL_SUCCESS=3
# @description log level debug
export __LEVEL_DEBUG=4

# @description verbose level off
export __VERBOSE_LEVEL_OFF=0
# @description verbose level info
export __VERBOSE_LEVEL_INFO=1
# @description verbose level info
export __VERBOSE_LEVEL_DEBUG=2
# @description verbose level info
export __VERBOSE_LEVEL_TRACE=3

# @description Display message using info color (bg light blue/fg white)
# @arg $1 message:String the message to display
# @env DISPLAY_DURATION int (default 0) if 1 display elapsed time information between 2 info logs
Log::displayInfo() {
  local type="${2:-INFO}"
  if ((BASH_FRAMEWORK_DISPLAY_LEVEL >= __LEVEL_INFO)); then
    Log::computeDuration
    echo -e "${__INFO_COLOR}${type}    - ${LOG_CONTEXT:-}${LOG_LAST_DURATION_STR:-}${1}${__RESET_COLOR}" >&2
  fi
  Log::logInfo "$1" "${type}"
}

# @description Display message using debug color (grey)
# @arg $1 message:String the message to display
Log::displayDebug() {
  if ((BASH_FRAMEWORK_DISPLAY_LEVEL >= __LEVEL_DEBUG)); then
    Log::computeDuration
    echo -e "${__DEBUG_COLOR}DEBUG   - ${LOG_CONTEXT:-}${LOG_LAST_DURATION_STR:-}${1}${__RESET_COLOR}" >&2
  fi
  Log::logDebug "$1"
}

# @description convert base64 encoded back to target dir
# it is advised to include the md5sum of the binFile in the path of the target dir
#
# @arg $1 targetDir:string the directory in which tar archive will be untarred
# @arg $2 base64:string the base64 encoded tar czf archive
# @stderr diagnostics information is displayed
# @require Linux::requireTarCommand
Compiler::Embed::extractDirFromBase64() {
  local targetDir="$1"
  local base64="$2"

  if [[ ! -d "${targetDir}" ]]; then
    mkdir -p "${targetDir}"
    (
      cd "${targetDir}" || exit 1
      base64 -d <<<"${base64}" | tar -xzf - 2>/dev/null || {
        Log::displayError "untar failure, invalid base64 string"
        exit 1
      }
    ) || return 1
  fi
}

# @description convert base64 encoded back to target file
# if target file is executable prepend dir of target
# file to PATH to make binary available everywhere
# it is advised to include in the path of the target file
# the md5sum of the binFile
#
# @arg $1 targetFile:String the file to write
# @arg $2 binFileBase64:String the base64 encoded file
# @arg $3 fileMode:String the chmod to set on the file
# @set PATH String prepend target embedded file binary directory to PATH variable if binary executable
Compiler::Embed::extractFileFromBase64() {
  local targetFile="$1"
  local binFileBase64="$2"
  local fileMode="${3:-+x}"
  local targetDir="${targetFile%/*}"

  if [[ ! -f "${targetFile}" ]]; then
    if [[ ! -d "${targetDir}" ]]; then
      mkdir -p "${targetDir}"
    fi
    base64 -d >"${targetFile}" <<<"${binFileBase64}"
    chmod "${fileMode}" "${targetFile}"
  fi

  if [[ -x "${targetFile}" ]]; then
    Env::pathPrepend "${targetDir}"
  fi
}

# @description checks if function name provided exists
# @arg $1 functionName:String
# @exitcode 1 if function name doesn't exist
Assert::functionExists() {
  declare -F "$1" >/dev/null
}

envFileTemplate="$(
  cat <<'EOF'
# shellcheck disable=SC2034
# wsl username
USERNAME="wsl"
USERGROUP="wsl"
HOME="/home/wsl"

# your login to connect to ssh servers if any
SSH_LOGIN=""

# your git full name 'FirstName LastName'
GIT_USERNAME=""
# email used for git 'ldap@domain.com'
GIT_USER_MAIL=""
# email used to connect to aws
AWS_USER_MAIL="fchastanet@gmail.com"
# app id to connect to aws account
AWS_APP_ID=""
AWS_PROFILE=""
AWS_DEFAULT_REGION=""
AWS_TEST_SECRET_ID=""
AWS_DEFAULT_DOCKER_REGISTRY_ID=""

# KubeDefaultConfig ~/.kube/config generation
# aws region of the cluster (Eg: us-east-1)
KUBE_CONFIG_REGION_CODE=
# aws arn of the cluster arn:aws:ecs:region:aws_account_id:cluster/MyCluster
KUBE_CONFIG_CLUSTER_ARN=

# hostname of the distro
DISTRO_HOSTNAME="wslHost"

# overridden conf directory that will be used to override
# the default configuration that are embedded in binaries
CONF_OVERRIDE_DIR="${BASH_DEV_ENV_ROOT_DIR}/conf.override"

# where to install bash-tools, ...
# shellcheck disable=SC2153
PROJECTS_DIR="${HOME}/projects"

# where overridden config files will be backed up
BACKUP_DIR="${BASH_DEV_ENV_ROOT_DIR}/backup"
# backup files/dirs before installing new file (usually 1, but 0 if using distro)
BACKUP_BEFORE_INSTALL=1
# logs directory
LOGS_DIR="${BASH_DEV_ENV_ROOT_DIR}/logs"
# installScripts dir
INSTALL_SCRIPTS_DIR="${BASH_DEV_ENV_ROOT_DIR}/installScripts"

# 0   => no upgrade at all
# lts => UPGRADE to latest ubuntu lts version
# dev => UPGRADE to latest ubuntu dev version
# Use if you know what you are doing,
# could cause some packages to not being available yet
UPGRADE_UBUNTU_VERSION=0

# -----------------------------------------
# PROFILES options

# Choose your preferred shell
# possible choices: ShellBash (Legacy experience), ShellZsh (Recommended experience)
PREFERRED_SHELL="ShellBash"

# Zsh theme to use
# possible choices: powerlevel10k/powerlevel10k, sindresorhus/pure, starship/starship
ZSH_PREFERRED_THEME="powerlevel10k/powerlevel10k"

# Display Fortune tooltip at bash/zsh session open
SHOW_FORTUNES=1

# Display MOTD at bash/zsh session open
SHOW_MOTD=1

# Install Docker inside wsl
DOCKER_INSIDE_WSL=1

# Configuration files are overwritten even if exists
# !!!! First time initialization: let this value to 1 !!!!
# Value 0:
# - If target configuration file exists, displays a message and do not overwrite the file
# - If target configuration file doesn't exist, installs the file
# Value 1
# - install or overwrite the file without checking existence
OVERWRITE_CONFIG_FILES=1

# Windows files can be overridden if 1
# if 0
# - skip changes to %USERPROFILE%/.wslconfig
# - skip copying fonts
CHANGE_WINDOWS_FILES=1

# Indicate that install script can warn you using speaker when your input is needed
CAN_TALK_DURING_INSTALLATION=${CAN_TALK_DURING_INSTALLATION:-1}

# if 0 install script will skip all interactive activity (saml2aws, ...),
# so dependent installation will be skipped as well
INSTALL_INTERACTIVE=${INSTALL_INTERACTIVE:-1}

# display elapsed time since last log
DISPLAY_DURATION=1

# -----------------------------------------
# WSLCONFIG - these parameters will help to automatically
# configure %USERPROFILE%/.wslconfig file
# Adjust these values to your needs
# @see https://docs.microsoft.com/en-us/windows/wsl/wsl-config
# Recommended 50% of total memory
WSLCONFIG_MAX_MEMORY=8GB
# personally I prefer run out of memory instead of beginning swapping
# So I know immediately if some processes have to be stopped
WSLCONFIG_SWAP=0

# -----------------------------------------
# Hacks
# on some configurations we have to force path of some windows commands
#POWERSHELL_BIN=/mnt/c/Windows/System32/WindowsPowerShell/v1.0/powershell.exe
#IPCONFIG_BIN=/mnt/c/Windows/system32/ipconfig.exe
#WSL_EXE_BIN=/mnt/c/Windows/system32/wsl.exe
EOF
)"

# @description load .env file
# @arg $1 envFile:String the file to load
Engine::Config::loadConfig() {
  if [[ "${BASH_DEV_ENV_CONFIG_LOADED:-0}" = "1" ]]; then
    return 0
  fi
  local envFile="${BASH_DEV_ENV_ROOT_DIR}/.env"
  Engine::Config::createEnvFileFromTemplate \
    "${envFile}" "${envFileTemplate}" || exit 1
  set -o allexport
  # shellcheck source=/.env.template
  source <(echo "${envFileTemplate}")
  # shellcheck source=/.env
  source "${BASH_DEV_ENV_ROOT_DIR}/.env"
  set +o allexport

  # load environment variables ID, VERSION_CODENAME
  Engine::Config::loadOsRelease
  Engine::Config::loadUserVariables

  if ! Engine::Config::checkEnv "${BASH_DEV_ENV_ROOT_DIR}/.env"; then
    Log::displayError "one or more variables are invalid, check above logs and fix '${envFile}' file accordingly"
    return 1
  fi

  Engine::Config::loadHostIp

  Engine::Config::requireWslu

  #Linux::Wsl::initEnv
  Engine::Config::loadWslVariables

  Log::requireLoad

  export PATH="${PATH}:${HOME}/.local/bin"

  export BASH_DEV_ENV_CONFIG_LOADED=1
}

# @description Display message using warning color (yellow)
# @arg $1 message:String the message to display
Log::displayWarning() {
  if ((BASH_FRAMEWORK_DISPLAY_LEVEL >= __LEVEL_WARNING)); then
    Log::computeDuration
    echo -e "${__WARNING_COLOR}WARN    - ${LOG_CONTEXT:-}${LOG_LAST_DURATION_STR:-}${1}${__RESET_COLOR}" >&2
  fi
  Log::logWarning "$1"
}

# @description Display message using error color (red)
# @arg $1 message:String the message to display
Log::displayError() {
  if ((BASH_FRAMEWORK_DISPLAY_LEVEL >= __LEVEL_ERROR)); then
    Log::computeDuration
    echo -e "${__ERROR_COLOR}ERROR   - ${LOG_CONTEXT:-}${LOG_LAST_DURATION_STR:-}${1}${__RESET_COLOR}" >&2
  fi
  Log::logError "$1"
}

# @description load colors theme constants
# @warning if tty not opened, noColor theme will be chosen
# @arg $1 theme:String the theme to use (default, noColor)
# @arg $@ args:String[]
# @set __ERROR_COLOR String indicate error status
# @set __INFO_COLOR String indicate info status
# @set __SUCCESS_COLOR String indicate success status
# @set __WARNING_COLOR String indicate warning status
# @set __SKIPPED_COLOR String indicate skipped status
# @set __DEBUG_COLOR String indicate debug status
# @set __HELP_COLOR String indicate help status
# @set __TEST_COLOR String not used
# @set __TEST_ERROR_COLOR String not used
# @set __HELP_TITLE_COLOR String used to display help title in help strings
# @set __HELP_OPTION_COLOR String used to display highlight options in help strings
#
# @set __RESET_COLOR String reset default color
#
# @set __HELP_EXAMPLE String to remove
# @set __HELP_TITLE String to remove
# @set __HELP_NORMAL String to remove
# shellcheck disable=SC2034
UI::theme() {
  local theme="${1-default}"
  if [[ ! "${theme}" =~ -force$ ]] && ! Assert::tty; then
    theme="noColor"
  fi
  case "${theme}" in
    default | default-force)
      theme="default"
      ;;
    noColor) ;;
    *)
      Log::fatal "invalid theme provided"
      ;;
  esac
  if [[ "${theme}" = "default" ]]; then
    BASH_FRAMEWORK_THEME="default"
    # check colors applicable https://misc.flogisoft.com/bash/tip_colors_and_formatting
    __ERROR_COLOR='\e[31m'         # Red
    __INFO_COLOR='\e[44m'          # white on lightBlue
    __SUCCESS_COLOR='\e[32m'       # Green
    __WARNING_COLOR='\e[33m'       # Yellow
    __SKIPPED_COLOR='\e[33m'       # Yellow
    __DEBUG_COLOR='\e[37m'         # Grey
    __HELP_COLOR='\e[7;49;33m'     # Black on Gold
    __TEST_COLOR='\e[100m'         # Light magenta
    __TEST_ERROR_COLOR='\e[41m'    # white on red
    __HELP_TITLE_COLOR="\e[1;37m"  # Bold
    __HELP_OPTION_COLOR="\e[1;34m" # Blue
    # Internal: reset color
    __RESET_COLOR='\e[0m' # Reset Color
    # shellcheck disable=SC2155,SC2034
    __HELP_EXAMPLE="$(echo -e "\e[2;97m")"
    # shellcheck disable=SC2155,SC2034
    __HELP_TITLE="$(echo -e "\e[1;37m")"
    # shellcheck disable=SC2155,SC2034
    __HELP_NORMAL="$(echo -e "\033[0m")"
  else
    BASH_FRAMEWORK_THEME="noColor"
    # check colors applicable https://misc.flogisoft.com/bash/tip_colors_and_formatting
    __ERROR_COLOR=''
    __INFO_COLOR=''
    __SUCCESS_COLOR=''
    __WARNING_COLOR=''
    __SKIPPED_COLOR=''
    __DEBUG_COLOR=''
    __HELP_COLOR=''
    __TEST_COLOR=''
    __TEST_ERROR_COLOR=''
    __HELP_TITLE_COLOR=''
    __HELP_OPTION_COLOR=''
    # Internal: reset color
    __RESET_COLOR=''
    __HELP_EXAMPLE=''
    __HELP_TITLE=''
    __HELP_NORMAL=''
  fi
}

# @description draw a line with the character passed in parameter repeated depending on terminal width
# @arg $1 character:String character to use as separator (default value #)
UI::drawLine() {
  local character="${1:-#}"
  printf -- "${character}%.0s" $(seq "${COLUMNS:-$([[ -t 0 ]] && tput cols || echo '80')}")
}

# @description Display message using error color (red) and exit immediately with error status 1
# @arg $1 message:String the message to display
Log::fatal() {
  Log::computeDuration
  echo -e "${__ERROR_COLOR}FATAL   - ${LOG_CONTEXT:-}${LOG_LAST_DURATION_STR:-}${1}${__RESET_COLOR}" >&2
  Log::logFatal "$1"
  exit 1
}

# @description create a temp file using default TMPDIR variable
# initialized in _includes/_commonHeader.sh
# @env TMPDIR String (default value /tmp)
# @arg $1 templateName:String template name to use(optional)
Framework::createTempFile() {
  mktemp -p "${TMPDIR:-/tmp}" -t "${1:-}.XXXXXXXXXXXX"
}

# @description ensure env files are loaded
# @arg $@ list of default files to load at the end
# @exitcode 1 if one of env files fails to load
# @stderr diagnostics information is displayed
# shellcheck disable=SC2120
Env::requireLoad() {
  local -a defaultFiles=("$@")
  # get list of possible config files
  local -a configFiles=()
  if [[ -n "${BASH_FRAMEWORK_ENV_FILES[0]+1}" ]]; then
    # BASH_FRAMEWORK_ENV_FILES is an array
    configFiles+=("${BASH_FRAMEWORK_ENV_FILES[@]}")
  fi
  local localFrameworkConfigFile
  localFrameworkConfigFile="$(pwd)/.framework-config"
  if [[ -f "${localFrameworkConfigFile}" ]]; then
    configFiles+=("${localFrameworkConfigFile}")
  fi
  if [[ -f "${FRAMEWORK_ROOT_DIR}/.framework-config" ]]; then
    configFiles+=("${FRAMEWORK_ROOT_DIR}/.framework-config")
  fi
  configFiles+=("${optionEnvFiles[@]}")
  configFiles+=("${defaultFiles[@]}")

  for file in "${configFiles[@]}"; do
    # shellcheck source=/.framework-config
    CURRENT_LOADED_ENV_FILE="${file}" source "${file}" || {
      Log::displayError "while loading config file: ${file}"
      return 1
    }
  done
}

# @description activate or not Log::display* and Log::log* functions
# based on BASH_FRAMEWORK_DISPLAY_LEVEL and BASH_FRAMEWORK_LOG_LEVEL
# environment variables loaded by Env::requireLoad
# try to create log file and rotate it if necessary
# @noargs
# @set BASH_FRAMEWORK_LOG_LEVEL int to OFF level if BASH_FRAMEWORK_LOG_FILE is empty or not writable
# @env BASH_FRAMEWORK_DISPLAY_LEVEL int
# @env BASH_FRAMEWORK_LOG_LEVEL int
# @env BASH_FRAMEWORK_LOG_FILE String
# @env BASH_FRAMEWORK_LOG_FILE_MAX_ROTATION int do log rotation if > 0
# @exitcode 0 always successful
# @stderr diagnostics information about log file is displayed
# @require Env::requireLoad
# @require UI::requireTheme
Log::requireLoad() {
  if [[ -z "${BASH_FRAMEWORK_LOG_FILE:-}" ]]; then
    BASH_FRAMEWORK_LOG_LEVEL=${__LEVEL_OFF}
    export BASH_FRAMEWORK_LOG_LEVEL
  fi

  if ((BASH_FRAMEWORK_LOG_LEVEL > __LEVEL_OFF)); then
    if [[ ! -f "${BASH_FRAMEWORK_LOG_FILE}" ]]; then
      if [[ ! -d "${BASH_FRAMEWORK_LOG_FILE%/*}" ]]; then
        if ! mkdir -p "${BASH_FRAMEWORK_LOG_FILE%/*}" 2>/dev/null; then
          BASH_FRAMEWORK_LOG_LEVEL=${__LEVEL_OFF}
          echo -e "${__ERROR_COLOR}ERROR   - directory ${BASH_FRAMEWORK_LOG_FILE%/*} is not writable${__RESET_COLOR}" >&2
        fi
      elif ! touch --no-create "${BASH_FRAMEWORK_LOG_FILE}" 2>/dev/null; then
        BASH_FRAMEWORK_LOG_LEVEL=${__LEVEL_OFF}
        echo -e "${__ERROR_COLOR}ERROR   - File ${BASH_FRAMEWORK_LOG_FILE} is not writable${__RESET_COLOR}" >&2
      fi
    elif [[ ! -w "${BASH_FRAMEWORK_LOG_FILE}" ]]; then
      BASH_FRAMEWORK_LOG_LEVEL=${__LEVEL_OFF}
      echo -e "${__ERROR_COLOR}ERROR   - File ${BASH_FRAMEWORK_LOG_FILE} is not writable${__RESET_COLOR}" >&2
    fi
  fi

  if ((BASH_FRAMEWORK_LOG_LEVEL > __LEVEL_OFF)); then
    # will always be created even if not in info level
    Log::logMessage "INFO" "Logging to file ${BASH_FRAMEWORK_LOG_FILE} - Log level ${BASH_FRAMEWORK_LOG_LEVEL}"
    if ((BASH_FRAMEWORK_LOG_FILE_MAX_ROTATION > 0)); then
      Log::rotate "${BASH_FRAMEWORK_LOG_FILE}" "${BASH_FRAMEWORK_LOG_FILE_MAX_ROTATION}"
    fi
  fi
}

# @description the command launch different actions(install, configure, test)
# depending on the options selected
# @see src/_includes/install.skip.options.tpl
# @env SKIP_INSTALL
# @env SKIP_CONFIGURE
# @env SKIP_TEST
# @env LOGS_DIR
InstallScripts::command() {
  local logsDir="${LOGS_DIR:-#}"
  local scriptName
  scriptName="$(scriptName)"
  rm -f "${logsDir}/${scriptName}-.*" || true

  # shellcheck disable=SC2317
  onInterrupt() {
    Log::displayError "${scriptName} aborted"
    exit 1
  }
  trap onInterrupt INT TERM ABRT

  local startDate logFile statsFile
  local installStatus="0"
  sourceHook() {
    local hookName="$1"
    # shellcheck disable=SC2154
    hook="$(IGNORE_ERROR=1 Conf::dynamicConfFile "${scriptName}/${hookName}.sh" "${embed_dir_hooks_dir}/${hookName}.sh")"
    if [[ -n "${hook}" && -f "${hook}" && -x "${hook}" ]]; then
      # shellcheck source=src/_binaries/SimpleTest/hooks/preInstall.sh
      source "${hook}" || {
        Log::displayError "${scriptName} - unable to load hook '${hook}'"
        exit 1
      }
    fi
  }
  local globalStatsFile="${logsDir}/${scriptName}-global.stat"
  local hook
  if [[ "${SKIP_INSTALL}" = "0" ]] && ! InstallScripts::scriptFunctionEmpty install; then
    LOG_CONTEXT="${scriptName} - " Log::headLine "INSTALL" "Installing ${scriptName}"
    logFile="${logsDir}/${scriptName}-install.log"
    statsFile="${logsDir}/${scriptName}-install.stat"

    # break at first install error
    (
      startDate="$(date +%s)"
      # shellcheck disable=SC2317
      computeStats() {
        local rc=$?
        Stats::computeStatsTrap "${logFile}" "${statsFile}" "${startDate}"
        Stats::computeStatsTrap "${logFile}" "${globalStatsFile}" "${startDate}"
        LOG_CONTEXT="${scriptName} - " Stats::statusLine "${rc}" "${statsFile}" "Installation"
        exit "${rc}"
      }
      trap 'computeStats' EXIT INT TERM ABRT

      local -i failures=0
      sourceHook preInstall || ((++failures))
      install || ((++failures))
      sourceHook postInstall || ((++failures))
      exit "${failures}"
    ) 2>&1 | tee "${logFile}"
  fi

  local testInstallStatus="0"
  if [[ "${SKIP_TEST}" = "0" && "${installStatus}" = "0" ]] &&
    ! InstallScripts::scriptFunctionEmpty testInstall; then
    Log::headLine "TEST" "Testing ${scriptName} installation"
    logFile="${logsDir}/${scriptName}-test-install.log"
    statsFile="${logsDir}/${scriptName}-test-install.stat"
    (
      startDate="$(date +%s)"
      # shellcheck disable=SC2317
      computeStats() {
        local rc=$?
        Stats::computeStatsTrap "${logFile}" "${statsFile}" "${startDate}"
        Stats::computeStatsTrap "${logFile}" "${globalStatsFile}" "${startDate}"
        Stats::statusLine "${rc}" "${statsFile}" "Test Install ${scriptName}"
        exit "${rc}"
      }
      trap 'computeStats' EXIT INT TERM ABRT

      local -i failures=0
      sourceHook preTestInstall || ((++failures))
      testInstall || ((++failures))
      sourceHook postTestInstall || ((++failures))
      exit "${failures}"
    ) 2>&1 | tee "${logFile}" || testInstallStatus="$?" || true
    if [[ "${testInstallStatus}" != "0" ]] && breakOnTestFailure; then
      # break if test script error
      exit "${testInstallStatus}"
    fi
  fi

  local configStatus="0"
  if [[ "${SKIP_CONFIGURE}" = "0" && "${installStatus}" = "0" ]] &&
    ! InstallScripts::scriptFunctionEmpty configure; then
    Log::headLine "CONFIG" "Configuring ${scriptName}"
    logFile="${logsDir}/${scriptName}-config.log"
    statsFile="${logsDir}/${scriptName}-config.stat"
    (
      startDate="$(date +%s)"
      # shellcheck disable=SC2317
      computeStats() {
        local rc=$?
        Stats::computeStatsTrap "${logFile}" "${statsFile}" "${startDate}"
        Stats::computeStatsTrap "${logFile}" "${globalStatsFile}" "${startDate}"
        Stats::statusLine "${rc}" "${statsFile}" "Configuration ${scriptName}"
        exit "${rc}"
      }
      trap 'computeStats' EXIT INT TERM ABRT

      local -i failures=0
      sourceHook preConfigure || ((++failures))
      configure || ((++failures))
      sourceHook postConfigure || ((++failures))
      exit "${failures}"
    ) 2>&1 | tee "${logFile}" || configStatus="$?" || true

    if [[ "${configStatus}" != "0" ]] && breakOnConfigFailure; then
      # break if config script error
      exit "${configStatus}"
    fi
  fi

  local testConfigStatus="0"
  if [[ "${SKIP_TEST}" = "0" && "${installStatus}" = "0" && "${configStatus}" = "0" ]] &&
    ! InstallScripts::scriptFunctionEmpty configure; then
    Log::headLine "TEST" "Testing ${scriptName} configuration"
    logFile="${logsDir}/${scriptName}-test-configuration.log"
    statsFile="${logsDir}/${scriptName}-test-configuration.stat"
    (
      startDate="$(date +%s)"
      # shellcheck disable=SC2317
      computeStats() {
        local rc=$?
        Stats::computeStatsTrap "${logFile}" "${statsFile}" "${startDate}"
        Stats::computeStatsTrap "${logFile}" "${globalStatsFile}" "${startDate}"
        Stats::statusLine "${rc}" "${statsFile}" "Test Configuration ${scriptName}"
        exit "${rc}"
      }
      trap 'computeStats' EXIT INT TERM ABRT

      local -i failures=0
      sourceHook preTestConfigure || ((++failures))
      testConfigure || ((++failures))
      sourceHook postTestConfigure || ((++failures))
      exit "${failures}"
    ) 2>&1 | tee "${logFile}" || testConfigStatus="$?" || true
    if [[ "${testConfigStatus}" != "0" ]] && breakOnTestFailure; then
      # break if test script error
      exit "${testConfigStatus}"
    fi
  fi
}

# @description concat each element of an array with a separator
# but wrapping text when line length is more than provided argument
# The algorithm will try not to cut the array element if it can.
# - if an arg can be placed on current line it will be,
#   otherwise current line is printed and arg is added to the new
#   current line
# - Empty arg is interpreted as a new line.
# - Add \r to arg in order to force break line and avoid following
#   arg to be concatenated with current arg.
#
# @arg $1 glue:String
# @arg $2 maxLineLength:int
# @arg $3 indentNextLine:int
# @arg $@ array:String[]
Array::wrap2() {
  local glue="${1-}"
  local -i glueLength="${#glue}"
  shift || true
  local -i maxLineLength=$1
  shift || true
  local -i indentNextLine=$1
  shift || true
  local indentStr=""
  if ((indentNextLine > 0)); then
    indentStr="$(head -c "${indentNextLine}" </dev/zero | tr '\0' " ")"
  fi
  if (($# == 0)); then
    return 0
  fi

  printCurrentLine() {
    if ((isNewline == 0)) || ((previousLineEmpty == 1)); then
      echo
    fi
    ((isNewline = 1))
    echo -en "${indentStr}"
    ((currentLineLength = indentNextLine)) || true
  }
  appendToCurrentLine() {
    local text="$1"
    local -i length=$2
    ((currentLineLength += length)) || true
    ((isNewline = 0)) || true
    if [[ "${text: -1}" = $'\r' ]]; then
      text="${text:0:-1}"
      echo -en "${text%%+([[:blank:]])}"
      printCurrentLine
    else
      echo -en "${text%%+([[:blank:]])}"
    fi
  }

  (
    local currentLine
    local -i currentLineLength=0 isNewline=1 argLength=0
    local -a additionalLines
    local -i previousLineEmpty=0
    local arg=""

    while (($# > 0)); do
      arg="$1"
      shift || true

      # replace tab by 2 spaces
      arg="${arg//$'\t'/  }"
      # remove trailing spaces
      arg="${arg%[[:blank:]]}"
      if [[ "${arg}" = $'\n' || -z "${arg}" ]]; then
        printCurrentLine
        ((previousLineEmpty = 1))
        continue
      else
        if ((previousLineEmpty == 1)); then
          printCurrentLine
        fi
        ((previousLineEmpty = 0)) || true
      fi
      # convert eol to args
      mapfile -t additionalLines <<<"${arg}"
      if ((${#additionalLines[@]} > 1)); then
        set -- "${additionalLines[@]}" "$@"
        continue
      fi

      ((argLength = ${#arg})) || true

      # empty arg
      if ((argLength == 0)); then
        if ((isNewline == 0)); then
          # isNewline = 0 means currentLine is not empty
          printCurrentLine
        fi
        continue
      fi

      if ((isNewline == 0)); then
        glueLength="${#glue}"
      else
        glueLength="0"
      fi
      if ((currentLineLength + argLength + glueLength > maxLineLength)); then
        if ((argLength + glueLength > maxLineLength)); then
          # arg is too long to even fit on one line
          # we have to split the arg on current and next line
          local -i remainingLineLength
          ((remainingLineLength = maxLineLength - currentLineLength - glueLength))
          appendToCurrentLine "${glue:0:${glueLength}}${arg:0:${remainingLineLength}}" "$((glueLength + remainingLineLength))"
          printCurrentLine
          arg="${arg:${remainingLineLength}}"
          # remove leading spaces
          arg="${arg##[[:blank:]]}"

          set -- "${arg}" "$@"
        else
          # the arg can fit on next line
          printCurrentLine
          appendToCurrentLine "${arg}" "${argLength}"
        fi
      else
        appendToCurrentLine "${glue:0:${glueLength}}${arg}" "$((glueLength + argLength))"
      fi
    done
    if [[ "${currentLine}" != "" ]] && [[ ! "${currentLine}" =~ ^[\ \t]+$ ]]; then
      printCurrentLine
    fi
  ) | sed -E -e 's/[[:blank:]]+$//'
}

# @description check if function is empty
# @arg $1 function:Function
# @exitcode 0 if function is considered empty (body with : or true)
InstallScripts::scriptFunctionEmpty() {
  local pattern="^[ \t]+(:|true)"
  [[ "$(declare -f "$1" | sed '3q;d')" =~ ${pattern} && "$(declare -f "$1" | sed '4q;d')" = "}" ]]
}

# @description apt-get install if package is not installed yet
# @arg $@ packages:String[] list of packages to install
# @feature Retry::default
# Linux::requireSudoCommand
# @require Linux::requireUbuntu
# @env SKIP_APT_GET_UPDATE
# @stdout diagnostics logs
Linux::Apt::installIfNecessary() {
  local -a packages=("$@")
  local package
  local -i installNeeded=0
  for package in "${packages[@]}"; do
    if [[ "${package}" =~ ^-- ]]; then
      continue
    fi
    if ! Linux::Apt::isPackageInstalled "${package}"; then
      Log::displayInfo "Package ${package} is not installed"
      installNeeded=1
    fi
  done
  if ((installNeeded == 1)); then
    if [[ "${SKIP_APT_GET_UPDATE:-0}" = "0" ]]; then
      Linux::Apt::update
    fi
    Linux::Apt::install "${packages[@]}"
    for package in "${packages[@]}"; do
      if [[ "${package}" =~ ^-- ]]; then
        continue
      fi
      if ! Linux::Apt::isPackageInstalled "${package}"; then
        Log::displayWarning "Package ${package} does not appear to have been installed, check if you could have chosen the wrong package name (Eg: python3.9-distutils instead of python3-distutils)"
      fi
    done
  else
    Log::displayInfo "Apt install avoided as packages are already installed : ${packages[*]}"
  fi
}

# @description check if command specified exists or return 1
# with error and message if not
#
# @arg $1 commandName:String on which existence must be checked
# @arg $2 helpIfNotExists:String a help command to display if the command does not exist
#
# @exitcode 1 if the command specified does not exist
# @stderr diagnostic information + help if second argument is provided
Assert::commandExists() {
  local commandName="$1"
  local helpIfNotExists="$2"

  "${BASH_FRAMEWORK_COMMAND:-command}" -v "${commandName}" >/dev/null 2>/dev/null || {
    Log::displayError "${commandName} is not installed, please install it"
    if [[ -n "${helpIfNotExists}" ]]; then
      Log::displayInfo "${helpIfNotExists}"
    fi
    return 1
  }
  return 0
}

# @description Display message using info color (bg light blue/fg white)
# @arg $1 message:String the message to display
Log::displayHelp() {
  local type="${2:-HELP}"
  if ((BASH_FRAMEWORK_DISPLAY_LEVEL >= __LEVEL_INFO)); then
    Log::computeDuration
    echo -e "${__HELP_COLOR}${type}    - ${LOG_CONTEXT:-}${LOG_LAST_DURATION_STR:-}${1}${__RESET_COLOR}" >&2
  fi
  Log::logHelp "$1" "${type}"
}

# @description copy folder structure to target directory
# merge embedDir with overridden directory if provided and available
# @arg $1 embedDir:String the path embedded
# @arg $2 overrideDir:String the path overridden
# @arg $3 subDir:String the sub-directory to copy from embedDir and/or overrideDir
# @arg $4 targetDir:String the target directory (default: ${HOME}/${subDir})
# @env SUDO String allows to use custom sudo prefix command
# @env HOME used for default value of targetDir arg
# @env OVERWRITE_CONFIG_FILES indicates if target directory should be overwritten if it exists
# @env PRETTY_ROOT_DIR used to make paths relative to this directory to reduce length of messages
Conf::copyStructure() {
  local embedDir="$1"
  local overrideDir="$2"
  local subDir="$3"
  local targetDir="${4:-${HOME}/${subDir}}"

  local configDir
  # shellcheck disable=SC2154
  configDir="$(Conf::getOverriddenDir "${embedDir}" "${overrideDir}")"
  # shellcheck disable=SC2154
  OVERWRITE_CONFIG_FILES=${OVERWRITE_CONFIG_FILES:-1} \
    PRETTY_ROOT_DIR="${embedDir%/*}" \
    Install::structure "${configDir}/${subDir}" "${targetDir}"
}

# @description installs file to given directory
#
# callbacks parameters `${fromFile} ${targetFile} $@`
# @arg $1 fromFile - original file to copy
# @arg $2 targetFile - target file
# @arg $3 userName:String (optional) (default: ${USERNAME}) the user name that will be used to set target files ownership
# @arg $4 userGroup:String (optional) (default: ${USERNAME}) the group name that will be used to set target files ownership
# @arg $5 successCallback:Function the callback to call when file is installed successfully, by default setUserRights callback is called
# @arg $6 failureCallback:Function the callback to call when file installation has failed, by default unableToCopyCallback callback is called
# @arg $@ callbacksParams:String[] additional parameters passed to callbacks
# @exitcode 1 if fromFile is not readable
# @exitcode 2 if backup file failure
# @exitcode 3 if copy failure
# @exitcode 0 on success or if OVERWRITE_CONFIG_FILES=0
# @exitcode 0 on success or if CHANGE_WINDOWS_FILES=0 and target file is a windows file
# @env OVERWRITE_CONFIG_FILES Boolean (default:0) if 1 will overwrite existing directory
# @env CHANGE_WINDOWS_FILES Boolean (default:0) if 1 and target file is in windows file system, overwrite it
# @env USERNAME (default: root) the user name that will be used to set target files ownership
# @env USERGROUP (default: root) the group name that will be used to set target files ownership
# @env BASE_MNT_C String windows C drive base PATH
# @env FRAMEWORK_ROOT_DIR used to make paths relative to this directory to reduce length of messages
# @env SUDO String allows to use custom sudo prefix command
# @env BACKUP_BEFORE_INSTALL Boolean (default: 1) backup file before installing the file
Install::file() {
  local fromFile="$1"
  local targetFile="$2"
  local userName="${3:-${USERNAME:-root}}"
  local userGroup="${4:-${USERGROUP:-root}}"
  local successCallback=${5:-Install::setUserRightsCallback}
  local failureCallback=${6:-Install::unableToCopyCallback}
  shift 6 || true

  if [[ ! -f "${fromFile}" || ! -r "${fromFile}" ]]; then
    Log::displayError "cannot read source file '${fromFile}'"
    return 1
  fi

  # skip if OVERWRITE_CONFIG_FILES is 0 and target file exists
  if [[ "${OVERWRITE_CONFIG_FILES}" = "0" && -f "${targetFile}" ]]; then
    Log::displayWarning "File '${targetFile}' exists - Skip install (because OVERWRITE_CONFIG_FILES=0 in .env file)"
    return 0
  fi

  # skip if CHANGE_WINDOWS_FILES is 0 and target dir is c drive
  if [[ "${CHANGE_WINDOWS_FILES}" = "0" && "${targetFile}" =~ ^${BASE_MNT_C} ]]; then
    Log::displayWarning "File '${targetFile}' - Skip install (because CHANGE_WINDOWS_FILES=0 in .env file)"
    return 0
  fi

  local targetDir="${targetFile%/*}"
  if ! ${SUDO} test -d "${targetDir}"; then
    ${SUDO:-} mkdir -p "${targetDir}"
    ${SUDO:-} chown "${userName}":"${userGroup}" "${targetDir}"
  fi
  local fromDir="${fromFile%/*}"
  local fromFilename="${fromFile##*/}"

  local prettyFromDir
  # shellcheck disable=SC2295
  prettyFromDir="${fromDir#${PRETTY_ROOT_DIR:-${FRAMEWORK_ROOT_DIR}}/}"
  if diff -q "${fromFile}" "${targetFile}" &>/dev/null; then
    Log::displayStatus "No changes detected. No need to update '${targetFile}' from '${prettyFromDir}/${fromFilename}'"
    return 0
  fi

  if [[ "${BACKUP_BEFORE_INSTALL:-1}" = "1" ]]; then
    Backup::file "${targetFile}" || return 2
  fi

  if ${SUDO:-} cp "${fromFile}" "${targetFile}"; then
    # shellcheck disable=SC2295
    Log::displaySuccess "Installed file '${targetFile}' from '${prettyFromDir}/${fromFilename}'"
    ${successCallback} "${fromFile}" "${targetFile}" "${userName}" "${userGroup}" "${prettyFromDir}" "${fromFilename}"
  else
    # shellcheck disable=SC2295
    Log::displayError "unable to copy file '${targetFile}' from '${fromDir#${FRAMEWORK_ROOT_DIR}/}/${fromFilename}'"
    ${failureCallback} "${fromFile}" "${targetFile}" "${userName}" "${userGroup}" "${prettyFromDir}" "${fromFilename}"
    return 3
  fi
}

# @description asserts that first argument is file that exists with specified ownership
# @arg $1 file:String
# @arg $2 user:String expected owner user name of the file (default: USERNAME or id -un command)
# @arg $3 group:String expected owner group name of the file (default: USERGROUP or id -gn command)
# @env USERNAME String if arg $2 is not provided
# @env USERGROUP String if arg $3 is not provided
# @env SUDO String allows to use custom sudo prefix command
# @exitcode 1 if missing file
# @exitcode 2 if incorrect user ownership
# @exitcode 3 if incorrect group ownership
# @stderr diagnostics information is displayed
Assert::fileExists() {
  local file="$1"
  local user="${2:-${USERNAME}}"
  local group="${3:-${USERGROUP}}"
  Log::displayInfo "Check ${file} exists with user ${user}:${group}"
  if ! ${SUDO:-} test -f "${file}" &>/dev/null; then
    Log::displayError "missing file ${file}"
    return 1
  fi
  if [[ "${user}" != "$(${SUDO:-} stat -c '%U' "${file}")" ]]; then
    Log::displayError "incorrect user ownership on file ${file}"
    return 2
  fi
  if [[ "${group}" != "$(${SUDO:-} stat -c '%G' "${file}")" ]]; then
    Log::displayError "incorrect group ownership on file ${file}"
    return 3
  fi
}

# @description ensure COMMAND_BIN_DIR env var is set
# and PATH correctly prepared
# @noargs
# @set COMMAND_BIN_DIR string the directory where to find this command
# @set PATH string add directory where to find this command binary
Compiler::Facade::requireCommandBinDir() {
  COMMAND_BIN_DIR="${CURRENT_DIR}"
  Env::pathPrepend "${COMMAND_BIN_DIR}"
}

declare -g FIRST_LOG_DATE LOG_LAST_LOG_DATE LOG_LAST_LOG_DATE_INIT LOG_LAST_DURATION_STR
FIRST_LOG_DATE="${EPOCHREALTIME/[^0-9]/}"
LOG_LAST_LOG_DATE="${FIRST_LOG_DATE}"
LOG_LAST_LOG_DATE_INIT=1
LOG_LAST_DURATION_STR=""

# @description Display message using info color (bg light blue/fg white)
# @arg $1 message:String the message to display
# @env DISPLAY_DURATION int (default 0) if 1 display elapsed time information between 2 info logs
Log::computeDuration() {
  if ((DISPLAY_DURATION == 1)); then
    local -i duration=0
    local -i delta=0
    local -i currentLogDate
    currentLogDate="${EPOCHREALTIME/[^0-9]/}"
    if ((LOG_LAST_LOG_DATE_INIT == 1)); then
      LOG_LAST_LOG_DATE_INIT=0
      LOG_LAST_DURATION_STR="Ref"
    else
      duration=$(((currentLogDate - FIRST_LOG_DATE) / 1000000))
      delta=$(((currentLogDate - LOG_LAST_LOG_DATE) / 1000000))
      LOG_LAST_DURATION_STR="${duration}s/+${delta}s"
    fi
    LOG_LAST_LOG_DATE="${currentLogDate}"
    # shellcheck disable=SC2034
    local microSeconds="${EPOCHREALTIME#*.}"
    LOG_LAST_DURATION_STR="$(printf '%(%T)T.%03.0f\n' "${EPOCHSECONDS}" "${microSeconds:0:3}")(${LOG_LAST_DURATION_STR}) - "
  else
    # shellcheck disable=SC2034
    LOG_LAST_DURATION_STR=""
  fi
}

# @description log message to file
# @arg $1 message:String the message to display
Log::logInfo() {
  if ((BASH_FRAMEWORK_LOG_LEVEL >= __LEVEL_INFO)); then
    Log::logMessage "${2:-INFO}" "$1"
  fi
}

# @description log message to file
# @arg $1 message:String the message to display
Log::logDebug() {
  if ((BASH_FRAMEWORK_LOG_LEVEL >= __LEVEL_DEBUG)); then
    Log::logMessage "${2:-DEBUG}" "$1"
  fi
}

# @description prepend directories to the PATH environment variable
# @arg $@ args:String[] list of directories to prepend
# @set PATH update PATH with the directories prepended
Env::pathPrepend() {
  local arg
  for arg in "$@"; do
    if [[ -d "${arg}" && ":${PATH}:" != *":${arg}:"* ]]; then
      PATH="$(realpath "${arg}"):${PATH}"
    fi
  done
}

# @description if .env does not exist, initialize it with .env.template
Engine::Config::createEnvFileFromTemplate() {
  local envFile="$1"
  local envFileTemplate="$2"

  if [[ ! -f "${envFile}" ]]; then
    echo "${envFileTemplate}" >"${envFile}"
    Log::displayError "a default env file has been created, please edit ${envFile}"
    return 1
  fi
}

# @description load /etc/os-release file
# @set NAME
# @set VERSION
# @set ID
# @set ID_LIKE
# @set PRETTY_NAME
# @set VERSION_ID
# @set HOME_URL
# @set SUPPORT_URL
# @set BUG_REPORT_URL
# @set PRIVACY_POLICY_URL
# @set VERSION_CODENAME
# @set UBUNTU_CODENAME
Engine::Config::loadOsRelease() {
  if [[ ! -f /etc/os-release ]]; then
    Log::displayError "file /etc/os-release does not exists"
    return 1
  fi
  # This will load environment variables ID, VERSION_CODENAME, ...
  set -o allexport
  source /etc/os-release
  set +o allexport
}

# @description deduce HOME, USER_ID, USERGROUP_ID and USERGROUP from USERNAME
# @env USERNAME String the name of the user
# @set USER_ID String
# @set USERGROUP String
# @set USERGROUP_ID String
# @set USER_SHELL String current user shell
# @set HOME String
Engine::Config::loadUserVariables() {
  # deduce user home and group
  local -a split
  local IFS=':'
  # shellcheck disable=SC2207
  split=($(getent passwd "${USERNAME}"))
  USER_ID="${split[2]}"
  USERGROUP_ID="${split[3]}"
  HOME="${split[5]}"
  USER_SHELL="${split[6]}"
  # shellcheck disable=SC2207
  split=($(getent group "${USERNAME}"))
  USERGROUP="${split[0]}"

  if [[ -z "${USERGROUP}" || -z "${HOME}" ]]; then
    Log::displayError "USERNAME - unable to deduce USERGROUP, HOME from USERNAME"
    return 1
  fi

  export HOME
  export USER_ID
  export USERGROUP_ID
  export USERGROUP
  export USER_SHELL
}

# @description check validity of .env variables
# @env CHECK_ENV int 0 to avoid checking environment
# @noargs
Engine::Config::checkEnv() {
  local envFile="$1"
  if [[ "${CHECK_ENV:-1}" = "0" ]]; then
    return 0
  fi
  # avoid checks if .env file didn't changed
  local envFileMd5Cache="${PERSISTENT_TMPDIR:-/tmp}/bash-dev-env-enf-file-checksum"
  if md5sum -c "${envFileMd5Cache}" &>/dev/null; then
    return 0
  else
    md5sum "${envFile}" >"${envFileMd5Cache}"
  fi
  local errorCount=0 || true
  checkNotEmpty() {
    local var="$1"
    if ! Assert::varExistsAndNotEmpty "${var}"; then
      ((++errorCount))
      return 1
    fi
  }
  checkVarAndDir() {
    local var="$1"
    local mode="${2:-}"
    local status=0
    if checkNotEmpty "${var}"; then
      if [[ ! -d "${!var}" ]] && ! mkdir -p "${!var}"; then
        Log::displayError "variable ${var} - impossible to create the directory '${!var}'"
        ((errorCount++))
        return 1
      fi
      if [[ "${mode}" =~ w && ! -w "${!var}" ]]; then
        Log::displayError "variable ${var} - directory '${!var}' is not writable"
        ((status++))
        ((errorCount++))
      fi
      if [[ "${mode}" =~ r && ! -r "${!var}" ]]; then
        Log::displayError "variable ${var} - directory '${!var}' is not accessible"
        ((status++))
        ((errorCount++))
      fi
    fi

    return "${status}"
  }
  checkValidValues() {
    local var="$1"
    shift || true
    local -a validValues=("$@")
    if ! Array::contains "${!var}" "${validValues[@]}"; then
      Log::displayError "variable ${var} - value ${!var} is not part of the following values ${validValues[*]}"
      ((++errorCount))
    fi
  }

  if ! echo "${ID}" | grep -qEw 'debian|ubuntu'; then
    Log::fatal "This script is built to support only Debian or Ubuntu distributions. You are using ${ID}."
  fi

  if checkNotEmpty USERNAME && ! getent passwd "${USERNAME}" 2>/dev/null >/dev/null; then
    Log::displayError "USERNAME - user '${USERNAME}' does not exist"
    ((errorCount++))
  fi

  if [[ -n "${SSH_LOGIN:-}" ]] && ! Assert::ldapLogin "${SSH_LOGIN}"; then
    Log::displayError "SSH_LOGIN - invalid ldap login (format expected firstNameLastName) in ${BASH_DEV_ENV_ROOT_DIR}/.env file"
    ((errorCount++))
  fi

  if checkNotEmpty "GIT_USERNAME" && ! Assert::firstNameLastName "${GIT_USERNAME}"; then
    Log::displayError "GIT_USERNAME - invalid format, expected : firstName lastName"
    ((errorCount++))
  fi

  if checkNotEmpty "GIT_USER_MAIL" && ! Assert::emailAddress "${GIT_USER_MAIL}"; then
    Log::displayError "GIT_USER_MAIL - invalid email address"
    ((errorCount++))
  fi

  if checkNotEmpty "AWS_USER_MAIL" && ! Assert::emailAddress "${AWS_USER_MAIL}"; then
    Log::displayError "AWS_USER_MAIL - invalid email address"
    ((errorCount++))
  fi

  checkVarAndDir CONF_OVERRIDE_DIR r || true
  checkVarAndDir PROJECTS_DIR r || true
  checkVarAndDir BACKUP_DIR rw || true
  checkVarAndDir LOGS_DIR rw || true
  checkVarAndDir INSTALL_SCRIPTS_DIR r || true
  checkVarAndDir HOME rw || true

  checkValidValues UPGRADE_UBUNTU_VERSION 0 lts dev
  checkValidValues PREFERRED_SHELL ShellBash ShellZsh
  checkValidValues ZSH_PREFERRED_THEME powerlevel10k/powerlevel10k sindresorhus/pure starship/starship

  checkValidValues SHOW_FORTUNES 0 1
  checkValidValues SHOW_MOTD 0 1
  checkValidValues DOCKER_INSIDE_WSL 0 1
  checkValidValues OVERWRITE_CONFIG_FILES 0 1
  checkValidValues CHANGE_WINDOWS_FILES 0 1
  checkValidValues CAN_TALK_DURING_INSTALLATION 0 1
  checkValidValues INSTALL_INTERACTIVE 0 1

  checkNotEmpty WSLCONFIG_MAX_MEMORY
  checkValidValues WSLCONFIG_SWAP 0 1
  export CHECK_ENV=0
  return "${errorCount}"
}

# @description deduce wsl host ip
# @set HOST_IP exported env containing the IP
Engine::Config::loadHostIp() {
  HOST_IP="$(/sbin/ip route | awk '/default/ { print $3 }')"

  export HOST_IP
}

# @description install apt wslu if necessary providing wslvar, wslpath
Engine::Config::requireWslu() {
  if ! command -v wslvar &>/dev/null; then
    Log::displayInfo "Installing pre-requisite Wslu : wslvar, wslpath, ... commands"
    Linux::Apt::installIfNecessary --no-install-recommends wslu

    # @see https://github.com/microsoft/WSL/issues/8843#issuecomment-1792256894
    Log::displayInfo "Fix wsl interoperability due to wsl bug"
    if [[ ! -f /usr/lib/binfmt.d/WSLInterop.conf &&
      ! -f /etc/systemd/system/wsl-binfmt.service &&
      -f /run/systemd/generator.early/wsl-binfmt.service ]]; then
      sudo sh -c 'echo :WSLInterop:M::MZ::/init:PF > /usr/lib/binfmt.d/WSLInterop.conf'
      sudo ln -s /run/systemd/generator.early/wsl-binfmt.service /etc/systemd/system/wsl-binfmt.service
    fi
  fi
}

# @description load wsl env variables
# @set BASE_MNT_C
# @set WINDOWS_DIR
# @set WINDOWS_PROFILE_DIR
# @set LOCAL_APP_DATA
# @set WINDOW_PATH
# @set WSL_EXE_BIN
# @set IPCONFIG_BIN
# @set POWERSHELL_BIN
# @env WSL_EXE_BIN
# @env IPCONFIG_BIN
# @env POWERSHELL_BIN
Engine::Config::loadWslVariables() {
  if ! Assert::wsl; then
    # skip
    return 0
  fi

  local IFS=' '
  local -a split=()
  # shellcheck disable=SC2207
  split=($(grep -m 1 -E 'C:\\[^ ]+ ([^ ]+) ' /proc/mounts 2>/dev/null))
  # shellcheck disable=SC1003
  BASE_MNT_C="${split[1]}"
  export BASE_MNT_C

  Linux::Wsl::cachedWslpathFromWslVar2 WINDOWS_DIR SystemRoot
  WINDOWS_DIR="${WINDOWS_DIR:-${BASE_MNT_C:-/mnt/c}/Windows}"
  export WINDOWS_DIR

  Linux::Wsl::cachedWslpathFromWslVar2 WINDOWS_PROFILE_DIR USERPROFILE
  WINDOWS_PROFILE_DIR="${WINDOWS_PROFILE_DIR:-${BASE_MNT_C:-/mnt/c}/Users/${USERNAME}}"
  export WINDOWS_PROFILE_DIR

  Linux::Wsl::cachedWslpathFromWslVar2 LOCAL_APP_DATA LOCALAPPDATA
  export LOCAL_APP_DATA

  # WINDOW_PATH
  Linux::Wsl::cachedWslvar2 WINDOW_PATH PATH
  WINDOW_PATH="${WINDOW_PATH//;/:}"
  WINDOW_PATH="${WINDOW_PATH//\\//}"
  WINDOW_PATH="${WINDOW_PATH//C:/${BASE_MNT_C:-/mnt/c}}"

  deduceBin() {
    local var="$1"
    local expectedFullPath="$2"
    local expectedBin="$3"
    if [[ -z "${!var+xxx}" ]]; then
      eval "${var}=${expectedFullPath}"
      if ! command -v "${!var}" >/dev/null 2>&1; then
        eval "${var}=$(command -v "${expectedBin}" 2>/dev/null)"
      fi
    fi
    if [[ -z "${!var:-}" ]] || ! command -v "${!var}" >/dev/null 2>&1; then
      Log::fatal "variable ${var} - command ${expectedBin} not found"
    fi
    # shellcheck disable=SC2163
    export "${var}"
  }

  checkBinary() {
    local var="$1"
    if [[ -z "${var}" || ! -x "${!var}" ]]; then
      Log::displayError "variable ${var} - binary '${!var}' does not exist or not executable"
      ((errorCount++))
    fi
  }

  local errorCount=0
  # IPCONFIG_BIN - which ipconfig.exe does not work when executed as root
  deduceBin IPCONFIG_BIN "${WINDOWS_DIR}/System32/ipconfig.exe" "ipconfig.exe"
  checkBinary IPCONFIG_BIN

  deduceBin WSL_EXE_BIN "${WINDOWS_DIR}/System32/wsl.exe" "wsl.exe"
  checkBinary WSL_EXE_BIN

  deduceBin POWERSHELL_BIN "${WINDOWS_DIR}/System32/WindowsPowerShell/v1.0/powershell.exe" "powershell.exe"
  checkBinary POWERSHELL_BIN

  return "${errorCount}"
}

# @description log message to file
# @arg $1 message:String the message to display
Log::logWarning() {
  if ((BASH_FRAMEWORK_LOG_LEVEL >= __LEVEL_WARNING)); then
    Log::logMessage "${2:-WARNING}" "$1"
  fi
}

# @description log message to file
# @arg $1 message:String the message to display
Log::logError() {
  if ((BASH_FRAMEWORK_LOG_LEVEL >= __LEVEL_ERROR)); then
    Log::logMessage "${2:-ERROR}" "$1"
  fi
}

# @description check if tty (interactive mode) is active
# @noargs
# @exitcode 1 if tty not active
# @env NON_INTERACTIVE if 1 consider as not interactive even if environment is interactive
# @env INTERACTIVE if 1 consider as interactive even if environment is not interactive
Assert::tty() {
  if [[ "${NON_INTERACTIVE:-0}" = "1" ]]; then
    return 1
  fi
  if [[ "${INTERACTIVE:-0}" = "1" ]]; then
    return 0
  fi
  # check if stdout or stderr is connected to terminal
  [[ -t 1 || -t 2 ]]
}

# @description log message to file
# @arg $1 message:String the message to display
Log::logFatal() {
  Log::logMessage "${2:-FATAL}" "$1"
}

# @description Internal: common log message
# @example text
#   [date]|[levelMsg]|message
#
# @example text
#   2020-01-19 19:20:21|ERROR  |log error
#   2020-01-19 19:20:21|SKIPPED|log skipped
#
# @arg $1 levelMsg:String message's level description (eg: STATUS, ERROR, ...)
# @arg $2 msg:String the message to display
# @env BASH_FRAMEWORK_LOG_FILE String log file to use, do nothing if empty
# @env BASH_FRAMEWORK_LOG_LEVEL int log level log only if > OFF or fatal messages
# @stderr diagnostics information is displayed
# @require Env::requireLoad
# @require Log::requireLoad
Log::logMessage() {
  local levelMsg="$1"
  local msg="$2"
  local date

  if [[ -n "${BASH_FRAMEWORK_LOG_FILE}" ]] && ((BASH_FRAMEWORK_LOG_LEVEL > __LEVEL_OFF)); then
    date="$(date '+%Y-%m-%d %H:%M:%S')"
    touch "${BASH_FRAMEWORK_LOG_FILE}"
    printf "%s|%7s|%s\n" "${date}" "${levelMsg}" "${msg}" >>"${BASH_FRAMEWORK_LOG_FILE}"
  fi
}

# @description To be called before logging in the log file
# @arg $1 file:string log file name
# @arg $2 maxLogFilesCount:int maximum number of log files
Log::rotate() {
  local file="$1"
  local maxLogFilesCount="${2:-5}"

  if [[ ! -f "${file}" ]]; then
    Log::displayDebug "Log file ${file} doesn't exist yet"
    return 0
  fi
  local i
  for ((i = maxLogFilesCount - 1; i > 0; i--)); do
    Log::displayInfo "Log rotation ${file}.${i} to ${file}.$((i + 1))"
    mv "${file}."{"${i}","$((i + 1))"} &>/dev/null || true
  done
  if cp "${file}" "${file}.1" &>/dev/null; then
    echo >"${file}" # reset log file
    Log::displayInfo "Log rotation ${file} to ${file}.1"
  fi
}

# @description select right file to load depending if file exists in this order:
# - from conf.override
# - from embedded file if provided
# - from conf dir
# @arg $1 file:String
# @arg $2 embedFile:String eventual embedded file
# @exitcode 1 if file does not exist at all
Conf::dynamicConfFile() {
  local file="${1/#\//}" # remove first slash if any
  local embedFile="${2:-}"
  if [[ -f "${CONF_OVERRIDE_DIR}/${file}" ]]; then
    echo "${CONF_OVERRIDE_DIR}/${file}"
    return 0
  elif [[ -f "${embedFile}" ]]; then
    echo "${embedFile}"
    return 0
  fi
  if [[ "${IGNORE_ERROR:-0}" = "0" ]]; then
    Log::displayWarning "Conf::dynamicConfFile - ${file} does not exist in any config dirs declared"
    return 1
  fi
}

# @description Display given text on full line with TEST_COLOR style
# @arg $1 text:String text to display
Log::headLine() {
  local type="$1"
  local text="$2"
  local message="${type}   - ${text}"
  if [[ -z "${type}" ]]; then
    message="${text}"
  else
    Log::computeDuration
    message="$(printf '%-7s - %s%s' "${type}" "${LOG_CONTEXT:-}${LOG_LAST_DURATION_STR:-}" "${text}")"
  fi
  echo -e "${__TEST_COLOR}$(UI::textLine "${message}" " ")${__RESET_COLOR}" >&2
}

# @description trap function responsible to compute and display stats after each script execution
# @arg $1 logFile:String
# @arg $2 statFile:String
# @arg $3 startDate:String date at which log started
Stats::computeStatsTrap() {
  local status="$?"
  local logFile="$1"
  local statFile="$2"
  local startDate="$3"
  local endDate
  endDate="$(date +%s)"
  Stats::computeFromLog "${logFile}" "${status}" "$((endDate - startDate))" >"${statFile}"
  return "${status}"
}

# @description display message to reflect last installation status
Stats::statusLine() {
  local status="$1"
  local statFile="$2"
  local msg="$3"
  if [[ ! -f "${statFile}" ]]; then
    return 0
  fi
  Log::computeDuration
  (
    # shellcheck source=src/Stats/logStats.example
    source "${statFile}" || exit 1

    local color="${__TEST_ERROR_COLOR}"
    local statusMsg
    if [[ "${status}" = "0" ]]; then
      if [[ "${skipped}" = "0" ]]; then
        color="${__SUCCESS_COLOR}"
        statusMsg="SUCCESS - ${LOG_CONTEXT:-}${LOG_LAST_DURATION_STR}${msg} successful"
      fi
    elif [[ "${status}" = "-1" ]]; then
      statusMsg="ABORTED - ${LOG_CONTEXT:-}${LOG_LAST_DURATION_STR}${msg} not executed"
    else
      statusMsg="ERROR   - ${LOG_CONTEXT:-}${LOG_LAST_DURATION_STR}${msg} in error"
    fi
    # overwrite final TEST line
    echo -e "${color}${statusMsg}${__RESET_COLOR}"
  )
}

# @description check if apt package is installed
# @arg $1 package:String the package name to check
# @require Linux::requireUbuntu
# @stdout diagnostics logs
Linux::Apt::isPackageInstalled() {
  local package="$1"
  dpkg -l "${package}" | grep -Eq "^ii  ${package}"
}

# @description update apt packages list
# @feature Retry::default
# Linux::requireSudoCommand
# @require Linux::requireUbuntu
# @stdout diagnostics logs
Linux::Apt::update() {
  Log::displayInfo "Apt update ..."
  Retry::default sudo apt-get update -y --fix-missing -o Acquire::ForceIPv4=true
}

# @description apt-get install
# @arg $@ softwares:String[] list of softwares to install
# @feature Retry::default
# Linux::requireSudoCommand
# @require Linux::requireUbuntu
# @stdout diagnostics logs
Linux::Apt::install() {
  Log::displayInfo "Apt install $*"
  Retry::default sudo apt-get install -y -q "$@"
}

# @description log message to file
# @arg $1 message:String the message to display
Log::logHelp() {
  if ((BASH_FRAMEWORK_LOG_LEVEL >= __LEVEL_INFO)); then
    Log::logMessage "${2:-HELP}" "$1"
  fi
}

# @description generate temp directory where default
# and overridden directories have been merged
#   - if overridden dir exists, create a new temp folder
#     - copy all files from default folder
#     - overwrite with files from overridden folder
#     - (Later) delete files listed in .remove$$ file
#     - return the path of this temp folder
#   - else just return the default folder path
# Then it is easier to pick overridden or default files/folders
#
# @arg $1 defaultDir:String usually the embed directory
# @arg $2 overriddenDirPath:String the path to the directory
#   that could be overridden
# @exitcode 1 if default dir does not exist
# @exitcode 2 if error during copy
Conf::getOverriddenDir() {
  local defaultDir="$1"
  local overriddenDirPath="$2"

  if [[ ! -d "${defaultDir}" ]]; then
    Log::displayError "Directory ${defaultDir} does not exists"
    return 1
  fi
  if [[ ! -d "${overriddenDirPath}" || -z "$(ls -A "${overriddenDirPath}")" ]]; then
    Log::displayInfo "Conf::getOverriddenDir - directory ${overriddenDirPath} does not exist, keep default one ${defaultDir}"
    echo "${defaultDir}"
    return 0
  fi
  local tempDir
  tempDir="$(mktemp -d)"
  (
    shopt -s dotglob
    cp -R "${defaultDir}/." "${tempDir}"
    cp -R "${overriddenDirPath}/." "${tempDir}"
  ) || return 2
  echo "${tempDir}"
}

# @description install dir to given directory but backup it before
# @arg $1 fromDir:String the source base directory
# @arg $2 toDir:String the target base directory
# @env OVERWRITE_CONFIG_FILES Boolean (default:0) if 1 will overwrite existing files
# @env CHANGE_WINDOWS_FILES Boolean (default:0) if 1 and target directory is in windows file system, overwrite it
# @env USERNAME (default: ${USERNAME} if SUDO empty else root) the user name that will be used to set target files ownership
# @env USERGROUP (default: ${USERGROUP} if SUDO empty else root) the group name that will be used to set target files ownership
# @env BASE_MNT_C String windows C drive base PATH
# @env PRETTY_ROOT_DIR used to make paths relative to this directory to reduce length of messages
# @env SUDO String allows to use custom sudo prefix command
# @env BACKUP_BEFORE_INSTALL Boolean (default:1) backup directory before installing the dir
# @exitcode 1 if source directory is not readable
# @exitcode 2 if error during structure replication
# @exitcode 2 if error during file copy
# @exitcode 0 if copy successful
# @exitcode 0 with warning message if CHANGE_WINDOWS_FILES=0 and target directory in C drive
# @stderr diagnostics information is displayed, skipped information if OVERWRITE_CONFIG_FILES or CHANGE_WINDOWS_FILES are set to 1
Install::structure() {
  local fromDir="$1"
  local toDir="$2"
  local userName="root"
  local userGroup="root"
  if [[ -z "${SUDO:-}" ]]; then
    userName="${USERNAME:-root}"
    userGroup="${USERGROUP:-root}"
  fi

  if [[ ! -d "${fromDir}" || ! -r "${fromDir}" ]]; then
    Log::displayError "Install::structure - cannot read source directory '${fromDir}'"
    return 1
  fi

  # skip if CHANGE_WINDOWS_FILES is 0 and target dir is c drive
  if [[ "${CHANGE_WINDOWS_FILES:-0}" = "0" && "${toDir}" =~ ^${BASE_MNT_C} ]]; then
    Log::displayWarning "Install::structure - Directory '${fromDir}' - Skip install (because CHANGE_WINDOWS_FILES=0 in .env file)"
    return 0
  fi

  # first replicate directory structure
  # shellcheck disable=SC2317
  createStructure() {
    local dir="$1"
    if ! ${SUDO} test -d "${dir}"; then
      if ! ${SUDO:-} mkdir -p "${dir}"; then
        Log::displayError "Install::structure - impossible to create directory '${dir}'"
        exit 1
      fi
    fi

    if ! ${SUDO:-} chown "${userName}":"${userGroup}" "${dir}"; then
      Log::displayError "Install::structure - impossible to update directory owner '${dir}' with ${userName}:${userGroup}"
      exit 1
    fi
  }
  local dir

  (
    local dir
    shopt -s lastpipe
    # -links 2 allows to exclude empty directories
    # %P get file without initial directory
    ${SUDO:-} find "${fromDir}" -depth -type d -links 2 -printf "%P\0" |
      while read -rd '' dir; do
        if ! createStructure "${toDir}/${dir}"; then
          # error already reported by createStructure
          exit 1
        fi
      done || {
      if [[ "${PIPESTATUS[0]}" != "0" ]]; then
        Log::displayError "Install::structure - replicated directory structure - find directories on '${fromDir}' resulted in an error"
        exit 2
      fi
    }
  ) || return 2

  # for each file, copy it
  (
    local file
    shopt -s lastpipe
    ${SUDO:-} find "${fromDir}" -depth -type f -printf "%P\0" |
      while read -rd '' file; do
        if ! Install::file "${fromDir}/${file}" "${toDir}/${file}"; then
          # error already reported by Install::file
          exit 1
        fi
      done || {
      if [[ "${PIPESTATUS[0]}" != "0" ]]; then
        Log::displayError "Install::structure - replicated file structure - find files on '${fromDir}' resulted in an error"
        exit 2
      fi
    }
  ) || return 3

  # shellcheck disable=SC2295
  Log::displaySuccess "Installed directory '${toDir#${PRETTY_ROOT_DIR}/}' from '${fromDir#${PRETTY_ROOT_DIR}/}'"
}

# @description install callback
#   set file with root ownership and execution bit
# @arg $1 fromFile:String
# @arg $2 targetFile:String
# @arg $3 userName:String (optional) (default: ${USERNAME}) the user name that will be used to set target files ownership
# @arg $4 userGroup:String (optional) (default: ${USERNAME}) the group name that will be used to set target files ownership
# @env USERNAME (default: root) the user name that will be used to set target files ownership
# @env USERGROUP (default: root) the group name that will be used to set target files ownership
# @env SUDO String allows to use custom sudo prefix command
# @exitcode 1 on any failure
# @see Install::file
Install::setUserRightsCallback() {
  # shellcheck disable=SC2034 # $1 not used
  local fromFile="$1"
  local targetFile="$2"
  local userName="${3:-${USERNAME:-root}}"
  local userGroup="${4:-${USERGROUP:-root}}"

  ${SUDO:-} chown "${userName}":"${userGroup}" "${targetFile}"
}

# @description install callback
#   default callback used called when file copy has failed
# @arg $1 fromFile:String
# @arg $2 targetFile:String
# @env FRAMEWORK_ROOT_DIR used to make paths relative to this directory to reduce length of messages
# @exitcode 1 always fail
# @stderr diagnostics information is displayed
# @see Install::file
Install::unableToCopyCallback() {
  local fromDir="$1"
  local fileName="$2"
  local targetFile="$3"
  Log::fatal "unable to copy file '${fromDir#"${FRAMEWORK_ROOT_DIR}/"}/${fileName}' to '${targetFile}'"
}

# @description Display message using info color (blue) but warning level
# @arg $1 message:String the message to display
Log::displayStatus() {
  local type="${2:-STATUS}"
  if ((BASH_FRAMEWORK_DISPLAY_LEVEL >= __LEVEL_WARNING)); then
    Log::computeDuration
    echo -e "${__INFO_COLOR}${type}  - ${LOG_CONTEXT:-}${LOG_LAST_DURATION_STR:-}${1}${__RESET_COLOR}" >&2
  fi
  Log::logStatus "$1" "${type}"
}

# @description Backup given file in the same directory or in BACKUP_DIR directory
# backup file name is composed by following fields separated by -:
#   - if BACKUP_DIR is not empty then escaped dir name separated by @
#   - filename(without path)
#   - date with format %Y%m%d_%H:%M:%S (Eg: 20240326_14:45:08)
# @arg $1 file:String the file to backup
# @stderr messages about backup file location
# @env SUDO String allows to use custom sudo prefix command
# @env BACKUP_DIR if not set backup the file in the same directory as original file
# @exitcode 1 on copy failure
Backup::file() {
  local file="$1"
  if [[ -f "${file}" ]]; then
    local backupFile fileDirname escapedDirname
    fileDirname="${file%/*}"
    escapedDirname=${fileDirname/\//}      # remove first slash
    escapedDirname=${escapedDirname//\//@} # replace all slashes by @
    if [[ -z "${BACKUP_DIR:-}" ]]; then
      backupFile="${fileDirname}/${file##*/}-$(date +"%Y%m%d_%H:%M:%S")"
    else
      backupFile="${BACKUP_DIR}/${escapedDirname}@${file##*/}-$(date +"%Y%m%d_%H:%M:%S")"
    fi
    Log::displayInfo "Backup file '${file}' to ${backupFile}"
    ${SUDO:-} cp "${file}" "${backupFile}"
  fi
}

# @description Display message using success color (bg green/fg white)
# @arg $1 message:String the message to display
Log::displaySuccess() {
  if ((BASH_FRAMEWORK_DISPLAY_LEVEL >= __LEVEL_INFO)); then
    Log::computeDuration
    echo -e "${__SUCCESS_COLOR}SUCCESS - ${LOG_CONTEXT:-}${LOG_LAST_DURATION_STR:-}${1}${__RESET_COLOR}" >&2
  fi
  Log::logSuccess "$1"
}

# @description ensure command tar is available
# @exitcode 1 if tar command not available
# @stderr diagnostics information is displayed
Linux::requireTarCommand() {
  Assert::commandExists tar
}

# @description load color theme
# @noargs
# @env BASH_FRAMEWORK_THEME String theme to use
# @env LOAD_THEME int 0 to avoid loading theme
# @exitcode 0 always successful
UI::requireTheme() {
  if [[ "${LOAD_THEME:-1}" = "1" ]]; then
    UI::theme "${BASH_FRAMEWORK_THEME-default}"
  fi
}

# @description ensure linux distribution is ubuntu
# @exitcode 1 if linux distribution is not ubuntu
Linux::requireUbuntu() {
  if ! Array::contains "$(Linux::getDistributorId)" "ubuntu" "debian"; then
    Log::fatal "this script should be executed under Ubuntu or Debian OS"
  fi
}

# @description checks if variable name provided exists
# @arg $1 varName:String
# @exitcode 1 if variable doesn't exist
# @exitcode 2 if variable value empty
# @exitcode 3 if variable name invalid
# @see Assert::validVariableName
# @stderr diagnostics information is displayed
Assert::varExistsAndNotEmpty() {
  local varName="$1"
  if ! Assert::validVariableName "${varName}"; then
    Log::displayError "${varName} - invalid variable name"
    return 3
  fi
  if [[ -z "${!varName+unset}" ]]; then
    Log::displayError "${varName} - not defined"
    return 1
  elif [[ -z "${!varName}" ]]; then
    Log::displayError "${varName} - please provide a value"
    return 2
  fi
}

# @description check if an element is contained in an array
#
# @arg $1 needle:String
# @arg $@ array:String[]
# @exitcode 0 if found
# @exitcode 1 otherwise
# @example
#   Array::contains "${libPath}" "${__BASH_FRAMEWORK_IMPORTED_FILES[@]}"
Array::contains() {
  local element
  for element in "${@:2}"; do
    [[ "${element}" = "$1" ]] && return 0
  done
  return 1
}

# @description check if argument respects ldap login naming convention
# only using lowercase characters a-z
# @arg $1 ldapLogin:String
# @exitcode 1 if regexp not matches
Assert::ldapLogin() {
  [[ $1 =~ ^[a-z]+$ ]]
}

# @description check if argument respects 2 or more words separated by a space
# it supports accentuated characters and names with hyphen(-)
# @arg $1 firstNameLastName:String
# @exitcode 1 if regexp not matches
# @see https://regex101.com/r/JyyfOM/1
Assert::firstNameLastName() {
  local regexp="^[^ ]+([ ][^ ]+)+$"
  [[ $1 =~ ${regexp} ]]
}

# @description check if param is valid email address
# @warning it is a very simple check, no RFC validation
# @arg $1 emailAddress:String the full email address
# @exitcode 1 if invalid email address
Assert::emailAddress() {
  local expectedRegexp="^\S+@\S+$"

  [[ "$1" =~ ${expectedRegexp} ]]
}

# @description determine if the script is executed under WSL
# cspell:disable
# @example text
#   uname GitBash windows (with wsl) => MINGW64_NT-10.0 ZOXFL-6619QN2 2.10.0(0.325/5/3) 2018-06-13 23:34 x86_64 Msys
#   uname GitBash windows (wo wsl)   => MINGW64_NT-10.0 frsa02-j5cbkc2 2.9.0(0.318/5/3) 2018-01-12 23:37 x86_64 Msys
#   uname wsl => Linux ZOXFL-6619QN2 4.4.0-17134-Microsoft #112-Microsoft Thu Jun 07 22:57:00 PST 2018 x86_64 x86_64 x86_64 GNU/Linux
# cspell:enable
#
# @exitcode 1 on error
Assert::wsl() {
  [[ "$(uname -o)" = "GNU/Linux" ]]
}

# @description retrieve path from wslvar and then use wslpath to resolve it
# using cache (cache is refreshed every day)
# @arg $1 var:String the var to retrieve using wslvar
# @arg $@ args:String[] (optional) additional arguments to pass to wslvar
# @env WSL_TMPDIR String temp directory to store the wslpath cache (default value: TMPDIR), you can use PERSISTENT_TMPDIR instead
# @exitcode * if Linux::Wsl::originalWslpath cannot find the path or Linux::Wsl::originalWslvar cannot find the var
# @stderr diagnostics information is displayed
# @require Linux::Wsl::requireWsl
# @feature cache
Linux::Wsl::cachedWslpathFromWslVar2() {
  # shellcheck disable=SC2034
  local -n cachedWslpathFromWslVar2_value=$1
  shift || true
  local value
  Linux::Wsl::cachedWslvar2 value "$@"
  Linux::Wsl::cachedWslpath2 cachedWslpathFromWslVar2_value "${value}" || return 1
}

declare -Agx bash_tools_wslvar=()
# @description retrieve wslvar using cache (cache is refreshed every day)
# @arg $1 cachedWslvar2_var:&String the variable to set by reference if the value is found
# @arg $@ args:String[] arguments to pass to wslvar
# @env WSL_TMPDIR String temp directory to store the wslvar cache (default value: TMPDIR), you can use PERSISTENT_TMPDIR instead
# @exitcode * if Linux::Wsl::originalWslvar cannot find the variable
# @stderr diagnostics information is displayed
# @require Linux::Wsl::requireWsl
# @feature cache
Linux::Wsl::cachedWslvar2() {
  # shellcheck disable=SC2034
  local -n cachedWslvar2_var="$1"
  shift || true
  local -a args=("$@")
  local tempWslvarFile="${WSL_TMPDIR:-${PERSISTENT_TMPDIR:-/tmp}}/bash_tools_wslvar"
  local key
  key="$(Linux::Wsl::getKeyFromWslpathOptions "${args[@]}")"
  Cache::getPropertyValue2 \
    "${tempWslvarFile}" \
    bash_tools_wslvar \
    cachedWslvar2_var \
    "${key}" \
    Linux::Wsl::originalWslvar "${args[@]}"
}

# @description Display given text and complete the rest of the line with given character
# @arg $1 text:String text to display
# @arg $2 character:String (default:#) character to use to complete the line
UI::textLine() {
  local text="$1"
  local character="${2:-#}"
  ((textSize = ${#text}))
  ((fullWith = $(tput cols)))
  ((remainingWidth = $((fullWith - textSize))))
  echo -n "${text}"
  printf '%*s\n' "${remainingWidth}" '' | tr ' ' "${character}"
}

# @description extract stats form log
# @arg $1 logFile:String the log file to parse
# @arg $2 status:int the status of the command associated to that log file
# @arg $3 duration:int the duration  of the command associated to that log file
# @stdout output with the format provided by this example src/Stats/aggregateStats.example
# @see src/Stats/aggregateStats.example
Stats::computeFromLog() {
  local logFile="$1"
  local status="$2"
  local duration="$3"

  local logStatsAwkScript
  logStatsAwkScript="$(
    cat <<'EOF'
BEGIN {
  error=0
  warning=0
  skipped=0
  help=0
  success=0
}
{
  buffer = substr($0, 1, 20)
  if(match(buffer, /(ERROR)[ ]+- /, arr) != 0) {
    error+=1
  } else if(match(buffer, /(WARNING)[ ]+- /, arr) != 0) {
    warning+=1
  } else if(match(buffer, /(SKIPPED)[ ]+- /, arr) != 0) {
    skipped+=1
  } else if(match(buffer, /(ERROR)[ ]+- /, arr) != 0) {
    error+=1
  } else if(match(buffer, /(HELP)[ ]+- /, arr) != 0) {
    help+=1
  } else if(match(buffer, /(SUCCESS)[ ]+- /, arr) != 0) {
    success+=1
  }

}
END {
  print "error=" error
  print "warning=" warning
  print "skipped=" skipped
  print "help=" help
  print "success=" success
}
EOF
  )"

  if [[ -f "${logFile}" ]]; then
    awk --source "${logStatsAwkScript}" "${logFile}"
    echo "status=${status}"
    echo "duration=${duration}"
  else
    # not executed
    echo "status=-1"
  fi
}

# @description Retry a command 5 times with a delay of 15 seconds between each attempt
# @arg $@ command:String[] the command to run
# @exitcode 0 on success
# @exitcode 1 if max retries count reached
Retry::default() {
  Retry::parameterized 5 15 "" "$@"
}

# @description log message to file
# @arg $1 message:String the message to display
Log::logStatus() {
  if ((BASH_FRAMEWORK_LOG_LEVEL >= __LEVEL_WARNING)); then
    Log::logMessage "${2:-STATUS}" "$1"
  fi
}

# @description log message to file
# @arg $1 message:String the message to display
Log::logSuccess() {
  if ((BASH_FRAMEWORK_LOG_LEVEL >= __LEVEL_INFO)); then
    Log::logMessage "${2:-SUCCESS}" "$1"
  fi
}

# @description retrieve linux distributor id
# @noargs
# @exitcode 1 if lsb_release fails or not found
# @stdout the linux distributor id
Linux::getDistributorId() {
  (
    source /etc/os-release
    echo "${ID}"
  )
}

# @description check if argument respects this framework variable naming convention
# - if variable begins with an uppercase or underscore, following letters have to be uppercase or underscore
# - variable name can includes ':' or '_' or digits but not as first letter
# here valid variable name examples
#
# @arg $1 variableName:String
# @exitcode 1 if regexp not matches
# @see https://regex101.com/r/BUlPXS/1
Assert::validVariableName() {
  [[ "$1" =~ (^[a-z][A-Za-z_0-9:]+$)|(^[A-Z_][A-Z_0-9:]+$) ]]
}

declare -Agx bash_tools_wslpath=()
# @description retrieve wslpath using cache (cache is refreshed every day)
# @arg $@ args:String[] arguments to pass to wslpath
# @env WSL_TMPDIR String temp directory to store the wslpath cache (default value: TMPDIR), you can use PERSISTENT_TMPDIR instead
# @exitcode * if Linux::Wsl::originalWslpath cannot find the path
# @stderr diagnostics information is displayed
# @require Linux::Wsl::requireWsl
# @feature cache
Linux::Wsl::cachedWslpath2() {
  # shellcheck disable=SC2034
  local -n cachedWslpath2_value=$1
  shift || true
  local tempEnvFile key
  tempEnvFile="${WSL_TMPDIR:-${PERSISTENT_TMPDIR:-/tmp}}/bash_tools_wslpath"

  key="$(Linux::Wsl::getKeyFromWslpathOptions "$@")"
  Cache::getPropertyValue2 \
    "${tempEnvFile}" \
    bash_tools_wslpath \
    cachedWslpath2_value \
    "${key}" \
    Linux::Wsl::originalWslpath "$@"
}

# @description Compute a cache from wslpath options
# @arg $@ args:String[] arguments passed to wslpath
# @stderr diagnostics information is displayed
# @stdout the cache key deduced from the options
# @require Linux::Wsl::requireWsl
# @feature cache
# @internal
Linux::Wsl::getKeyFromWslpathOptions() {
  local options
  options=$(getopt -o "auwm" -- "$@" 2>/dev/null) || {
    Log::displayError "invalid options specified"
    return 1
  }
  local key="wslpath"
  eval set -- "${options}"
  while true; do
    case "$1" in
      -a | -u | -w | -m)
        key="${key}$1"
        ;;
      --)
        shift || true
        break
        ;;
      *)
        shift || true
        Log::displayWarning "Unknown key $1"
        ;;
    esac
    shift || true
  done
  key="${key}_$1"
  # replace some characters \:/
  key="${key//\\//}"
  key="${key//:/_}"
  key="${key////_}"
  echo "${key}"
}

# @description get property value from file
# if not present compute it using propertyNotFoundCallback (if provided) and store it in property file
# @arg $1 propertyFile:String the file in which the property will be searched
# @arg $2 key:String the property key to search in property file
# @arg $3 propertyNotFoundCallback:Function (optional) a callback to call if property key is not found in property file
# @arg $@ args:String[] (optional) the arguments to pass to the propertyNotFoundCallback
# @exitcode 1 if value is not found
# @exitcode * if propertyNotFoundCallback fails
# @stdout the property value given by property file or by the propertyNotFoundCallback
Cache::getPropertyValue2() {
  local propertyFile="$1"
  local -n propertiesMap=$2
  local -n getPropertyValue2_val=$3
  local key="$4"
  local propertyNotFoundCallback=$5
  shift 5 || true
  local -a args=("$@")

  if [[ "${#propertiesMap[@]}" = "0" && -s "${propertyFile}" ]]; then
    local line
    while IFS="" read -r line; do
      if [[ "${line}" =~ ^([^=]+)=(.+)$ ]]; then
        propertiesMap["${BASH_REMATCH[1]}"]="${BASH_REMATCH[2]}"
      fi
    done <"${propertyFile}"
  fi

  if [[ -n "${propertiesMap[${key}]+abc}" ]]; then
    getPropertyValue2_val="${propertiesMap[${key}]}"
    return 0
  elif [[ "$(type -t "${propertyNotFoundCallback}")" = "function" ]]; then
    getPropertyValue2_val="$("${propertyNotFoundCallback}" "${args[@]}")" || return $?
    propertiesMap["${key}"]="${getPropertyValue2_val}"
    echo "${key}=${getPropertyValue2_val}" >>"${propertyFile}"
    return 0
  fi
  return 1
}

# @description call simply original wslvar command
# @arg $@ args:String[] args to pass to wslvar
# @exitcode * wslvar exit code
# @stdout wslvar stdout
# @require Linux::Wsl::requireWsl
Linux::Wsl::originalWslvar() {
  wslvar "$@" | sed -z '$ s/[\r\n]$//'
}

# @description Retry a command several times depending on parameters
# @arg $1 maxRetries:int    $1 max retries
# @arg $2 delay:int between attempt
# @arg $3 message:String to display to describe the attempt
# @arg $@ rest of parameters, the command to run
# @exitcode 0 on success
# @exitcode 1 if max retries count reached
# @exitcode 2 if maxRetries invalid value
Retry::parameterized() {
  local maxRetries=$1
  shift || true
  local delayBetweenTries=$1
  shift || true
  local message="$1"
  shift || true
  local retriesCount=1
  if [[ "${maxRetries}" -lt 1 ]]; then
    Log::displayError "invalid maxRetry value"
    return 2
  fi

  while true; do
    Log::displayInfo "Attempt ${retriesCount}/${maxRetries}: ${message}"
    if "$@"; then
      break
    elif [[ "${retriesCount}" -lt "${maxRetries}" ]]; then
      Log::displayWarning "Command failed. Wait for ${delayBetweenTries} seconds"
      ((retriesCount++))
      sleep "${delayBetweenTries}"
    else
      Log::displayError "The command has failed after ${retriesCount} attempts."
      return 1
    fi
  done
  return 0
}

# @description ensure linux runs under wsl
# @env WSL_GARBAGE_COLLECT int 0 to disable garbage collect of cache files
# @exitcode 1 if linux does not run under wsl
Linux::Wsl::requireWsl() {
  Assert::wsl || return 1
  if [[ "${WSL_GARBAGE_COLLECT:-1}" = "1" ]]; then
    local tempEnvDir
    tempEnvDir="${WSL_TMPDIR:-${PERSISTENT_TMPDIR:-/tmp}}"
    File::garbageCollect "${tempEnvDir}/bash_tools_wslpath_${USER_ID:-$(id -un)}" "1"
    tempEnvDir="${WSL_TMPDIR:-${PERSISTENT_TMPDIR:-/tmp}}"
    File::garbageCollect "${tempEnvDir}/bash_tools_wslvar_${USER_ID:-$(id -un)}" "1"
  fi
}

# @description call simply original wslpath command
# @arg $@ args:String[] args to pass to wslpath
# @exitcode * wslpath exit code
# @stdout wslpath stdout
# @require Linux::Wsl::requireWsl
Linux::Wsl::originalWslpath() {
  wslpath "$@" | sed -z '$ s/[\r\n]$//'
}

# @description delete files older than n days in given path
# @warning use this function with caution as it will delete all files in given path without any prompt
# @arg $1 path:String the directory in which files will be deleted or the file to delete
# @arg $2 mtime:String expiration time in days (eg: 1 means 1 day) (default value: 1). Eg: +1 match files that have been accessed at least two days ago (rounding effect)
# @arg $3 maxdepth:int Descend at most levels (a non-negative integer) levels of directories below the starting-points. (default value: 1)
# @exitcode 1 if path not provided or empty
# @exitcode * find command failure code
# @stderr find output on error or diagnostics logs
# @see man find atime
File::garbageCollect() {
  local path="$1"
  local mtime="$2"
  local maxdepth="${3:-1}"

  if [[ -z "${path}" ]]; then
    return 1
  fi

  if [[ ! -e "${path}" ]]; then
    # path already removed
    return 0
  fi

  Log::displayInfo "Garbage collect files older than ${mtime} days in path ${path} with max depth ${maxdepth}"
  find "${path}" -depth -maxdepth "${maxdepth}" -type f -mtime "${mtime}" -print -delete
}

# FUNCTIONS

Compiler::Embed::extractDirFromBase64 "${TMPDIR:-/tmp}/conf_dir" "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"

declare -gx embed_dir_conf_dir="${TMPDIR:-/tmp}/conf_dir"
Compiler::Embed::extractFileFromBase64 "${PERSISTENT_TMPDIR:-/tmp}/1361c58830a7be9c06aa1b1f559dbbdb/loadConfigFiles" "IyEvdXNyL2Jpbi9lbnYgYmFzaAojIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjCiMgR0VORVJBVEVEIEZBQ0FERSBGUk9NIGh0dHBzOi8vZ2l0aHViLmNvbS9mY2hhc3RhbmV0L2Jhc2gtZGV2LWVudi90cmVlL21hc3Rlci9zcmMvX2JpbmFyaWVzL190b29scy9sb2FkQ29uZmlnRmlsZXMuc2gKIyBETyBOT1QgRURJVCBJVAojIEBnZW5lcmF0ZWQKIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIwojIHNoZWxsY2hlY2sgZGlzYWJsZT1TQzIyODgsU0MyMDM0CiMgQklOX0ZJTEU9JHtCQVNIX0RFVl9FTlZfUk9PVF9ESVJ9L2Jpbi9sb2FkQ29uZmlnRmlsZXMKIyBWQVJfUkVMQVRJVkVfRlJBTUVXT1JLX0RJUl9UT19DVVJSRU5UX0RJUj0KIyBWQVJfTE9BRF9SRVFVSVJFUz0wCiMgVkFSX0xPQURfQ09ORklHPTAKIyBGQUNBREUKCiMgZW5zdXJlIHRoYXQgbm8gdXNlciBhbGlhc2VzIGNvdWxkIGludGVyZmVyZSB3aXRoCiMgY29tbWFuZHMgdXNlZCBpbiB0aGlzIHNjcmlwdAp1bmFsaWFzIC1hIHx8IHRydWUKc2hvcHQgLXUgZXhwYW5kX2FsaWFzZXMKCiMgc2hlbGxjaGVjayBkaXNhYmxlPVNDMjAzNAooKGZhaWx1cmVzID0gMCkpIHx8IHRydWUKCiMgQmFzaCB3aWxsIHJlbWVtYmVyICYgcmV0dXJuIHRoZSBoaWdoZXN0IGV4aXQgY29kZSBpbiBhIGNoYWluIG9mIHBpcGVzLgojIFRoaXMgd2F5IHlvdSBjYW4gY2F0Y2ggdGhlIGVycm9yIGluc2lkZSBwaXBlcywgZS5nLiBteXNxbGR1bXAgfCBnemlwCnNldCAtbyBwaXBlZmFpbApzZXQgLW8gZXJyZXhpdAoKIyBDb21tYW5kIFN1YnN0aXR1dGlvbiBjYW4gaW5oZXJpdCBlcnJleGl0IG9wdGlvbiBzaW5jZSBiYXNoIHY0LjQKc2hvcHQgLXMgaW5oZXJpdF9lcnJleGl0IHx8IHRydWUKCiMgaWYgc2V0LCBhbmQgam9iIGNvbnRyb2wgaXMgbm90IGFjdGl2ZSwgdGhlIHNoZWxsIHJ1bnMgdGhlIGxhc3QgY29tbWFuZAojIG9mIGEgcGlwZWxpbmUgbm90IGV4ZWN1dGVkIGluIHRoZSBiYWNrZ3JvdW5kIGluIHRoZSBjdXJyZW50IHNoZWxsCiMgZW52aXJvbm1lbnQuCnNob3B0IC1zIGxhc3RwaXBlCgojIGEgbG9nIGlzIGdlbmVyYXRlZCB3aGVuIGEgY29tbWFuZCBmYWlscwpzZXQgLW8gZXJydHJhY2UKCiMgdXNlIG51bGxnbG9iIHNvIHRoYXQgKGZpbGUqLnBocCkgd2lsbCByZXR1cm4gYW4gZW1wdHkgYXJyYXkgaWYgbm8gZmlsZQojIG1hdGNoZXMgdGhlIHdpbGRjYXJkCnNob3B0IC1zIG51bGxnbG9iCgojIGVuc3VyZSByZWdleHAgYXJlIGludGVycHJldGVkIHdpdGhvdXQgYWNjZW50dWF0ZWQgY2hhcmFjdGVycwpleHBvcnQgTENfQUxMPVBPU0lYCgpleHBvcnQgVEVSTT14dGVybS0yNTZjb2xvcgoKIyBhdm9pZCBpbnRlcmFjdGl2ZSBpbnN0YWxsCmV4cG9ydCBERUJJQU5fRlJPTlRFTkQ9bm9uaW50ZXJhY3RpdmUKZXhwb3J0IERFQkNPTkZfTk9OSU5URVJBQ1RJVkVfU0VFTj10cnVlCgojIHN0b3JlIGNvbW1hbmQgYXJndW1lbnRzIGZvciBsYXRlciB1c2FnZQojIHNoZWxsY2hlY2sgZGlzYWJsZT1TQzIwMzQKZGVjbGFyZSAtYSBCQVNIX0ZSQU1FV09SS19BUkdWPSgiJEAiKQojIHNoZWxsY2hlY2sgZGlzYWJsZT1TQzIwMzQKZGVjbGFyZSAtYSBPUklHSU5BTF9CQVNIX0ZSQU1FV09SS19BUkdWPSgiJEAiKQoKIyBAc2VlIGh0dHBzOi8vdW5peC5zdGFja2V4Y2hhbmdlLmNvbS9hLzM4Njg1NgojIHNoZWxsY2hlY2sgZGlzYWJsZT1TQzIzMTcKaW50ZXJydXB0TWFuYWdlbWVudCgpIHsKICAjIHJlc3RvcmUgU0lHSU5UIGhhbmRsZXIKICB0cmFwIC0gSU5UCiAgIyBlbnN1cmUgdGhhdCBDdHJsLUMgaXMgdHJhcHBlZCBieSB0aGlzIHNjcmlwdCBhbmQgbm90IGJ5IHN1YiBwcm9jZXNzCiAgIyByZXBvcnQgdG8gdGhlIHBhcmVudCB0aGF0IHdlIGhhdmUgaW5kZWVkIGJlZW4gaW50ZXJydXB0ZWQKICBraWxsIC1zIElOVCAiJCQiCn0KdHJhcCBpbnRlcnJ1cHRNYW5hZ2VtZW50IElOVApTQ1JJUFRfTkFNRT0kezAjIyovfQpSRUFMX1NDUklQVF9GSUxFPSIkKHJlYWRsaW5rIC1lICIkKHJlYWxwYXRoICIke0JBU0hfU09VUkNFWzBdfSIpIikiCmlmIFtbIC1uICIke0VNQkVEX0NVUlJFTlRfRElSfSIgXV07IHRoZW4KICBDVVJSRU5UX0RJUj0iJHtFTUJFRF9DVVJSRU5UX0RJUn0iCmVsc2UKICBDVVJSRU5UX0RJUj0iJHtSRUFMX1NDUklQVF9GSUxFJS8qfSIKZmkKCiMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIwojIFRlbXAgZGlyIG1hbmFnZW1lbnQKIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjCgpLRUVQX1RFTVBfRklMRVM9IiR7S0VFUF9URU1QX0ZJTEVTOi0wfSIKZXhwb3J0IEtFRVBfVEVNUF9GSUxFUwoKIyBQRVJTSVNURU5UX1RNUERJUiBpcyBub3QgZGVsZXRlZCBieSB0cmFwcwpQRVJTSVNURU5UX1RNUERJUj0iJHtUTVBESVI6LS90bXB9L2Jhc2gtZnJhbWV3b3JrIgpleHBvcnQgUEVSU0lTVEVOVF9UTVBESVIKaWYgW1sgISAtZCAiJHtQRVJTSVNURU5UX1RNUERJUn0iIF1dOyB0aGVuCiAgbWtkaXIgLXAgIiR7UEVSU0lTVEVOVF9UTVBESVJ9IgpmaQoKIyBzaGVsbGNoZWNrIGRpc2FibGU9U0MyMDM0ClRNUERJUj0iJChta3RlbXAgLWQgLXAgIiR7UEVSU0lTVEVOVF9UTVBESVI6LS90bXB9IiAtdCBiYXNoLWZyYW1ld29yay0kJC1YWFhYWFgpIgpleHBvcnQgVE1QRElSCgojIHRlbXAgZGlyIGNsZWFuaW5nCiMgc2hlbGxjaGVjayBkaXNhYmxlPVNDMjMxNwpjbGVhbk9uRXhpdCgpIHsKICBsb2NhbCByYz0kPwogIGlmIFtbICIke0tFRVBfVEVNUF9GSUxFUzotMH0iID0gIjEiIF1dOyB0aGVuCiAgICBMb2c6OmRpc3BsYXlJbmZvICJLRUVQX1RFTVBfRklMRVM9MSB0ZW1wIGZpbGVzIGtlcHQgaGVyZSAnJHtUTVBESVJ9JyIKICBlbGlmIFtbIC1uICIke1RNUERJUit4eHh9IiBdXTsgdGhlbgogICAgTG9nOjpkaXNwbGF5RGVidWcgIktFRVBfVEVNUF9GSUxFUz0wIHJlbW92aW5nIHRlbXAgZmlsZXMgJyR7VE1QRElSfSciCiAgICBybSAtUmYgIiR7VE1QRElSOi0vdG1wL2Zha2V9IiA+L2Rldi9udWxsIDI+JjEKICBmaQogIGV4aXQgIiR7cmN9Igp9CnRyYXAgY2xlYW5PbkV4aXQgRVhJVCBIVVAgUVVJVCBBQlJUIFRFUk0KCiMgQGRlc2NyaXB0aW9uIExvZyBuYW1lc3BhY2UgcHJvdmlkZXMgMiBraW5kIG9mIGZ1bmN0aW9ucwojIC0gTG9nOjpkaXNwbGF5KiBhbGxvd3MgdG8gZGlzcGxheSBnaXZlbiBtZXNzYWdlIHdpdGgKIyAgIGdpdmVuIGRpc3BsYXkgbGV2ZWwKIyAtIExvZzo6bG9nKiBhbGxvd3MgdG8gbG9nIGdpdmVuIG1lc3NhZ2Ugd2l0aAojICAgZ2l2ZW4gbG9nIGxldmVsCiMgTG9nOjpkaXNwbGF5KiBmdW5jdGlvbnMgYXV0b21hdGljYWxseSBsb2cgdGhlIG1lc3NhZ2UgdG9vCiMgQHNlZSBFbnY6OnJlcXVpcmVMb2FkIHRvIGxvYWQgdGhlIGRpc3BsYXkgYW5kIGxvZyBsZXZlbCBmcm9tIC5lbnYgZmlsZQoKIyBAZGVzY3JpcHRpb24gbG9nIGxldmVsIG9mZgpleHBvcnQgX19MRVZFTF9PRkY9MAojIEBkZXNjcmlwdGlvbiBsb2cgbGV2ZWwgZXJyb3IKZXhwb3J0IF9fTEVWRUxfRVJST1I9MQojIEBkZXNjcmlwdGlvbiBsb2cgbGV2ZWwgd2FybmluZwpleHBvcnQgX19MRVZFTF9XQVJOSU5HPTIKIyBAZGVzY3JpcHRpb24gbG9nIGxldmVsIGluZm8KZXhwb3J0IF9fTEVWRUxfSU5GTz0zCiMgQGRlc2NyaXB0aW9uIGxvZyBsZXZlbCBzdWNjZXNzCmV4cG9ydCBfX0xFVkVMX1NVQ0NFU1M9MwojIEBkZXNjcmlwdGlvbiBsb2cgbGV2ZWwgZGVidWcKZXhwb3J0IF9fTEVWRUxfREVCVUc9NAoKIyBAZGVzY3JpcHRpb24gdmVyYm9zZSBsZXZlbCBvZmYKZXhwb3J0IF9fVkVSQk9TRV9MRVZFTF9PRkY9MAojIEBkZXNjcmlwdGlvbiB2ZXJib3NlIGxldmVsIGluZm8KZXhwb3J0IF9fVkVSQk9TRV9MRVZFTF9JTkZPPTEKIyBAZGVzY3JpcHRpb24gdmVyYm9zZSBsZXZlbCBpbmZvCmV4cG9ydCBfX1ZFUkJPU0VfTEVWRUxfREVCVUc9MgojIEBkZXNjcmlwdGlvbiB2ZXJib3NlIGxldmVsIGluZm8KZXhwb3J0IF9fVkVSQk9TRV9MRVZFTF9UUkFDRT0zCgojIEBkZXNjcmlwdGlvbiBEaXNwbGF5IG1lc3NhZ2UgdXNpbmcgaW5mbyBjb2xvciAoYmcgbGlnaHQgYmx1ZS9mZyB3aGl0ZSkKIyBAYXJnICQxIG1lc3NhZ2U6U3RyaW5nIHRoZSBtZXNzYWdlIHRvIGRpc3BsYXkKIyBAZW52IERJU1BMQVlfRFVSQVRJT04gaW50IChkZWZhdWx0IDApIGlmIDEgZGlzcGxheSBlbGFwc2VkIHRpbWUgaW5mb3JtYXRpb24gYmV0d2VlbiAyIGluZm8gbG9ncwpMb2c6OmRpc3BsYXlJbmZvKCkgewogIGxvY2FsIHR5cGU9IiR7MjotSU5GT30iCiAgaWYgKChCQVNIX0ZSQU1FV09SS19ESVNQTEFZX0xFVkVMID49IF9fTEVWRUxfSU5GTykpOyB0aGVuCiAgICBMb2c6OmNvbXB1dGVEdXJhdGlvbgogICAgZWNobyAtZSAiJHtfX0lORk9fQ09MT1J9JHt0eXBlfSAgICAtICR7TE9HX0NPTlRFWFQ6LX0ke0xPR19MQVNUX0RVUkFUSU9OX1NUUjotfSR7MX0ke19fUkVTRVRfQ09MT1J9IiA+JjIKICBmaQogIExvZzo6bG9nSW5mbyAiJDEiICIke3R5cGV9Igp9CgojIEBkZXNjcmlwdGlvbiBEaXNwbGF5IG1lc3NhZ2UgdXNpbmcgZGVidWcgY29sb3IgKGdyZXkpCiMgQGFyZyAkMSBtZXNzYWdlOlN0cmluZyB0aGUgbWVzc2FnZSB0byBkaXNwbGF5CkxvZzo6ZGlzcGxheURlYnVnKCkgewogIGlmICgoQkFTSF9GUkFNRVdPUktfRElTUExBWV9MRVZFTCA+PSBfX0xFVkVMX0RFQlVHKSk7IHRoZW4KICAgIExvZzo6Y29tcHV0ZUR1cmF0aW9uCiAgICBlY2hvIC1lICIke19fREVCVUdfQ09MT1J9REVCVUcgICAtICR7TE9HX0NPTlRFWFQ6LX0ke0xPR19MQVNUX0RVUkFUSU9OX1NUUjotfSR7MX0ke19fUkVTRVRfQ09MT1J9IiA+JjIKICBmaQogIExvZzo6bG9nRGVidWcgIiQxIgp9CgojIEBkZXNjcmlwdGlvbiBjaGVja3MgaWYgZnVuY3Rpb24gbmFtZSBwcm92aWRlZCBleGlzdHMKIyBAYXJnICQxIGZ1bmN0aW9uTmFtZTpTdHJpbmcKIyBAZXhpdGNvZGUgMSBpZiBmdW5jdGlvbiBuYW1lIGRvZXNuJ3QgZXhpc3QKQXNzZXJ0OjpmdW5jdGlvbkV4aXN0cygpIHsKICBkZWNsYXJlIC1GICIkMSIgPi9kZXYvbnVsbAp9CgojIEBkZXNjcmlwdGlvbiBlbnN1cmUgQ09NTUFORF9CSU5fRElSIGVudiB2YXIgaXMgc2V0CiMgYW5kIFBBVEggY29ycmVjdGx5IHByZXBhcmVkCiMgQG5vYXJncwojIEBzZXQgQ09NTUFORF9CSU5fRElSIHN0cmluZyB0aGUgZGlyZWN0b3J5IHdoZXJlIHRvIGZpbmQgdGhpcyBjb21tYW5kCiMgQHNldCBQQVRIIHN0cmluZyBhZGQgZGlyZWN0b3J5IHdoZXJlIHRvIGZpbmQgdGhpcyBjb21tYW5kIGJpbmFyeQpDb21waWxlcjo6RmFjYWRlOjpyZXF1aXJlQ29tbWFuZEJpbkRpcigpIHsKICBDT01NQU5EX0JJTl9ESVI9IiR7Q1VSUkVOVF9ESVJ9IgogIEVudjo6cGF0aFByZXBlbmQgIiR7Q09NTUFORF9CSU5fRElSfSIKfQoKZGVjbGFyZSAtZyBGSVJTVF9MT0dfREFURSBMT0dfTEFTVF9MT0dfREFURSBMT0dfTEFTVF9MT0dfREFURV9JTklUIExPR19MQVNUX0RVUkFUSU9OX1NUUgpGSVJTVF9MT0dfREFURT0iJHtFUE9DSFJFQUxUSU1FL1teMC05XS99IgpMT0dfTEFTVF9MT0dfREFURT0iJHtGSVJTVF9MT0dfREFURX0iCkxPR19MQVNUX0xPR19EQVRFX0lOSVQ9MQpMT0dfTEFTVF9EVVJBVElPTl9TVFI9IiIKCiMgQGRlc2NyaXB0aW9uIERpc3BsYXkgbWVzc2FnZSB1c2luZyBpbmZvIGNvbG9yIChiZyBsaWdodCBibHVlL2ZnIHdoaXRlKQojIEBhcmcgJDEgbWVzc2FnZTpTdHJpbmcgdGhlIG1lc3NhZ2UgdG8gZGlzcGxheQojIEBlbnYgRElTUExBWV9EVVJBVElPTiBpbnQgKGRlZmF1bHQgMCkgaWYgMSBkaXNwbGF5IGVsYXBzZWQgdGltZSBpbmZvcm1hdGlvbiBiZXR3ZWVuIDIgaW5mbyBsb2dzCkxvZzo6Y29tcHV0ZUR1cmF0aW9uKCkgewogIGlmICgoRElTUExBWV9EVVJBVElPTiA9PSAxKSk7IHRoZW4KICAgIGxvY2FsIC1pIGR1cmF0aW9uPTAKICAgIGxvY2FsIC1pIGRlbHRhPTAKICAgIGxvY2FsIC1pIGN1cnJlbnRMb2dEYXRlCiAgICBjdXJyZW50TG9nRGF0ZT0iJHtFUE9DSFJFQUxUSU1FL1teMC05XS99IgogICAgaWYgKChMT0dfTEFTVF9MT0dfREFURV9JTklUID09IDEpKTsgdGhlbgogICAgICBMT0dfTEFTVF9MT0dfREFURV9JTklUPTAKICAgICAgTE9HX0xBU1RfRFVSQVRJT05fU1RSPSJSZWYiCiAgICBlbHNlCiAgICAgIGR1cmF0aW9uPSQoKChjdXJyZW50TG9nRGF0ZSAtIEZJUlNUX0xPR19EQVRFKSAvIDEwMDAwMDApKQogICAgICBkZWx0YT0kKCgoY3VycmVudExvZ0RhdGUgLSBMT0dfTEFTVF9MT0dfREFURSkgLyAxMDAwMDAwKSkKICAgICAgTE9HX0xBU1RfRFVSQVRJT05fU1RSPSIke2R1cmF0aW9ufXMvKyR7ZGVsdGF9cyIKICAgIGZpCiAgICBMT0dfTEFTVF9MT0dfREFURT0iJHtjdXJyZW50TG9nRGF0ZX0iCiAgICAjIHNoZWxsY2hlY2sgZGlzYWJsZT1TQzIwMzQKICAgIGxvY2FsIG1pY3JvU2Vjb25kcz0iJHtFUE9DSFJFQUxUSU1FIyoufSIKICAgIExPR19MQVNUX0RVUkFUSU9OX1NUUj0iJChwcmludGYgJyUoJVQpVC4lMDMuMGZcbicgIiR7RVBPQ0hTRUNPTkRTfSIgIiR7bWljcm9TZWNvbmRzOjA6M30iKSgke0xPR19MQVNUX0RVUkFUSU9OX1NUUn0pIC0gIgogIGVsc2UKICAgICMgc2hlbGxjaGVjayBkaXNhYmxlPVNDMjAzNAogICAgTE9HX0xBU1RfRFVSQVRJT05fU1RSPSIiCiAgZmkKfQoKIyBAZGVzY3JpcHRpb24gbG9nIG1lc3NhZ2UgdG8gZmlsZQojIEBhcmcgJDEgbWVzc2FnZTpTdHJpbmcgdGhlIG1lc3NhZ2UgdG8gZGlzcGxheQpMb2c6OmxvZ0luZm8oKSB7CiAgaWYgKChCQVNIX0ZSQU1FV09SS19MT0dfTEVWRUwgPj0gX19MRVZFTF9JTkZPKSk7IHRoZW4KICAgIExvZzo6bG9nTWVzc2FnZSAiJHsyOi1JTkZPfSIgIiQxIgogIGZpCn0KCiMgQGRlc2NyaXB0aW9uIGxvZyBtZXNzYWdlIHRvIGZpbGUKIyBAYXJnICQxIG1lc3NhZ2U6U3RyaW5nIHRoZSBtZXNzYWdlIHRvIGRpc3BsYXkKTG9nOjpsb2dEZWJ1ZygpIHsKICBpZiAoKEJBU0hfRlJBTUVXT1JLX0xPR19MRVZFTCA+PSBfX0xFVkVMX0RFQlVHKSk7IHRoZW4KICAgIExvZzo6bG9nTWVzc2FnZSAiJHsyOi1ERUJVR30iICIkMSIKICBmaQp9CgojIEBkZXNjcmlwdGlvbiBwcmVwZW5kIGRpcmVjdG9yaWVzIHRvIHRoZSBQQVRIIGVudmlyb25tZW50IHZhcmlhYmxlCiMgQGFyZyAkQCBhcmdzOlN0cmluZ1tdIGxpc3Qgb2YgZGlyZWN0b3JpZXMgdG8gcHJlcGVuZAojIEBzZXQgUEFUSCB1cGRhdGUgUEFUSCB3aXRoIHRoZSBkaXJlY3RvcmllcyBwcmVwZW5kZWQKRW52OjpwYXRoUHJlcGVuZCgpIHsKICBsb2NhbCBhcmcKICBmb3IgYXJnIGluICIkQCI7IGRvCiAgICBpZiBbWyAtZCAiJHthcmd9IiAmJiAiOiR7UEFUSH06IiAhPSAqIjoke2FyZ306IiogXV07IHRoZW4KICAgICAgUEFUSD0iJChyZWFscGF0aCAiJHthcmd9Iik6JHtQQVRIfSIKICAgIGZpCiAgZG9uZQp9CgojIEBkZXNjcmlwdGlvbiBJbnRlcm5hbDogY29tbW9uIGxvZyBtZXNzYWdlCiMgQGV4YW1wbGUgdGV4dAojICAgW2RhdGVdfFtsZXZlbE1zZ118bWVzc2FnZQojCiMgQGV4YW1wbGUgdGV4dAojICAgMjAyMC0wMS0xOSAxOToyMDoyMXxFUlJPUiAgfGxvZyBlcnJvcgojICAgMjAyMC0wMS0xOSAxOToyMDoyMXxTS0lQUEVEfGxvZyBza2lwcGVkCiMKIyBAYXJnICQxIGxldmVsTXNnOlN0cmluZyBtZXNzYWdlJ3MgbGV2ZWwgZGVzY3JpcHRpb24gKGVnOiBTVEFUVVMsIEVSUk9SLCAuLi4pCiMgQGFyZyAkMiBtc2c6U3RyaW5nIHRoZSBtZXNzYWdlIHRvIGRpc3BsYXkKIyBAZW52IEJBU0hfRlJBTUVXT1JLX0xPR19GSUxFIFN0cmluZyBsb2cgZmlsZSB0byB1c2UsIGRvIG5vdGhpbmcgaWYgZW1wdHkKIyBAZW52IEJBU0hfRlJBTUVXT1JLX0xPR19MRVZFTCBpbnQgbG9nIGxldmVsIGxvZyBvbmx5IGlmID4gT0ZGIG9yIGZhdGFsIG1lc3NhZ2VzCiMgQHN0ZGVyciBkaWFnbm9zdGljcyBpbmZvcm1hdGlvbiBpcyBkaXNwbGF5ZWQKIyBAcmVxdWlyZSBFbnY6OnJlcXVpcmVMb2FkCiMgQHJlcXVpcmUgTG9nOjpyZXF1aXJlTG9hZApMb2c6OmxvZ01lc3NhZ2UoKSB7CiAgbG9jYWwgbGV2ZWxNc2c9IiQxIgogIGxvY2FsIG1zZz0iJDIiCiAgbG9jYWwgZGF0ZQoKICBpZiBbWyAtbiAiJHtCQVNIX0ZSQU1FV09SS19MT0dfRklMRX0iIF1dICYmICgoQkFTSF9GUkFNRVdPUktfTE9HX0xFVkVMID4gX19MRVZFTF9PRkYpKTsgdGhlbgogICAgZGF0ZT0iJChkYXRlICcrJVktJW0tJWQgJUg6JU06JVMnKSIKICAgIHRvdWNoICIke0JBU0hfRlJBTUVXT1JLX0xPR19GSUxFfSIKICAgIHByaW50ZiAiJXN8JTdzfCVzXG4iICIke2RhdGV9IiAiJHtsZXZlbE1zZ30iICIke21zZ30iID4+IiR7QkFTSF9GUkFNRVdPUktfTE9HX0ZJTEV9IgogIGZpCn0KCiMgQGRlc2NyaXB0aW9uIGVuc3VyZSBlbnYgZmlsZXMgYXJlIGxvYWRlZAojIEBhcmcgJEAgbGlzdCBvZiBkZWZhdWx0IGZpbGVzIHRvIGxvYWQgYXQgdGhlIGVuZAojIEBleGl0Y29kZSAxIGlmIG9uZSBvZiBlbnYgZmlsZXMgZmFpbHMgdG8gbG9hZAojIEBzdGRlcnIgZGlhZ25vc3RpY3MgaW5mb3JtYXRpb24gaXMgZGlzcGxheWVkCiMgc2hlbGxjaGVjayBkaXNhYmxlPVNDMjEyMApFbnY6OnJlcXVpcmVMb2FkKCkgewogIGxvY2FsIC1hIGRlZmF1bHRGaWxlcz0oIiRAIikKICAjIGdldCBsaXN0IG9mIHBvc3NpYmxlIGNvbmZpZyBmaWxlcwogIGxvY2FsIC1hIGNvbmZpZ0ZpbGVzPSgpCiAgaWYgW1sgLW4gIiR7QkFTSF9GUkFNRVdPUktfRU5WX0ZJTEVTWzBdKzF9IiBdXTsgdGhlbgogICAgIyBCQVNIX0ZSQU1FV09SS19FTlZfRklMRVMgaXMgYW4gYXJyYXkKICAgIGNvbmZpZ0ZpbGVzKz0oIiR7QkFTSF9GUkFNRVdPUktfRU5WX0ZJTEVTW0BdfSIpCiAgZmkKICBsb2NhbCBsb2NhbEZyYW1ld29ya0NvbmZpZ0ZpbGUKICBsb2NhbEZyYW1ld29ya0NvbmZpZ0ZpbGU9IiQocHdkKS8uZnJhbWV3b3JrLWNvbmZpZyIKICBpZiBbWyAtZiAiJHtsb2NhbEZyYW1ld29ya0NvbmZpZ0ZpbGV9IiBdXTsgdGhlbgogICAgY29uZmlnRmlsZXMrPSgiJHtsb2NhbEZyYW1ld29ya0NvbmZpZ0ZpbGV9IikKICBmaQogIGlmIFtbIC1mICIke0ZSQU1FV09SS19ST09UX0RJUn0vLmZyYW1ld29yay1jb25maWciIF1dOyB0aGVuCiAgICBjb25maWdGaWxlcys9KCIke0ZSQU1FV09SS19ST09UX0RJUn0vLmZyYW1ld29yay1jb25maWciKQogIGZpCiAgY29uZmlnRmlsZXMrPSgiJHtvcHRpb25FbnZGaWxlc1tAXX0iKQogIGNvbmZpZ0ZpbGVzKz0oIiR7ZGVmYXVsdEZpbGVzW0BdfSIpCgogIGZvciBmaWxlIGluICIke2NvbmZpZ0ZpbGVzW0BdfSI7IGRvCiAgICAjIHNoZWxsY2hlY2sgc291cmNlPS8uZnJhbWV3b3JrLWNvbmZpZwogICAgQ1VSUkVOVF9MT0FERURfRU5WX0ZJTEU9IiR7ZmlsZX0iIHNvdXJjZSAiJHtmaWxlfSIgfHwgewogICAgICBMb2c6OmRpc3BsYXlFcnJvciAid2hpbGUgbG9hZGluZyBjb25maWcgZmlsZTogJHtmaWxlfSIKICAgICAgcmV0dXJuIDEKICAgIH0KICBkb25lCn0KCiMgQGRlc2NyaXB0aW9uIGFjdGl2YXRlIG9yIG5vdCBMb2c6OmRpc3BsYXkqIGFuZCBMb2c6OmxvZyogZnVuY3Rpb25zCiMgYmFzZWQgb24gQkFTSF9GUkFNRVdPUktfRElTUExBWV9MRVZFTCBhbmQgQkFTSF9GUkFNRVdPUktfTE9HX0xFVkVMCiMgZW52aXJvbm1lbnQgdmFyaWFibGVzIGxvYWRlZCBieSBFbnY6OnJlcXVpcmVMb2FkCiMgdHJ5IHRvIGNyZWF0ZSBsb2cgZmlsZSBhbmQgcm90YXRlIGl0IGlmIG5lY2Vzc2FyeQojIEBub2FyZ3MKIyBAc2V0IEJBU0hfRlJBTUVXT1JLX0xPR19MRVZFTCBpbnQgdG8gT0ZGIGxldmVsIGlmIEJBU0hfRlJBTUVXT1JLX0xPR19GSUxFIGlzIGVtcHR5IG9yIG5vdCB3cml0YWJsZQojIEBlbnYgQkFTSF9GUkFNRVdPUktfRElTUExBWV9MRVZFTCBpbnQKIyBAZW52IEJBU0hfRlJBTUVXT1JLX0xPR19MRVZFTCBpbnQKIyBAZW52IEJBU0hfRlJBTUVXT1JLX0xPR19GSUxFIFN0cmluZwojIEBlbnYgQkFTSF9GUkFNRVdPUktfTE9HX0ZJTEVfTUFYX1JPVEFUSU9OIGludCBkbyBsb2cgcm90YXRpb24gaWYgPiAwCiMgQGV4aXRjb2RlIDAgYWx3YXlzIHN1Y2Nlc3NmdWwKIyBAc3RkZXJyIGRpYWdub3N0aWNzIGluZm9ybWF0aW9uIGFib3V0IGxvZyBmaWxlIGlzIGRpc3BsYXllZAojIEByZXF1aXJlIEVudjo6cmVxdWlyZUxvYWQKIyBAcmVxdWlyZSBVSTo6cmVxdWlyZVRoZW1lCkxvZzo6cmVxdWlyZUxvYWQoKSB7CiAgaWYgW1sgLXogIiR7QkFTSF9GUkFNRVdPUktfTE9HX0ZJTEU6LX0iIF1dOyB0aGVuCiAgICBCQVNIX0ZSQU1FV09SS19MT0dfTEVWRUw9JHtfX0xFVkVMX09GRn0KICAgIGV4cG9ydCBCQVNIX0ZSQU1FV09SS19MT0dfTEVWRUwKICBmaQoKICBpZiAoKEJBU0hfRlJBTUVXT1JLX0xPR19MRVZFTCA+IF9fTEVWRUxfT0ZGKSk7IHRoZW4KICAgIGlmIFtbICEgLWYgIiR7QkFTSF9GUkFNRVdPUktfTE9HX0ZJTEV9IiBdXTsgdGhlbgogICAgICBpZiBbWyAhIC1kICIke0JBU0hfRlJBTUVXT1JLX0xPR19GSUxFJS8qfSIgXV07IHRoZW4KICAgICAgICBpZiAhIG1rZGlyIC1wICIke0JBU0hfRlJBTUVXT1JLX0xPR19GSUxFJS8qfSIgMj4vZGV2L251bGw7IHRoZW4KICAgICAgICAgIEJBU0hfRlJBTUVXT1JLX0xPR19MRVZFTD0ke19fTEVWRUxfT0ZGfQogICAgICAgICAgZWNobyAtZSAiJHtfX0VSUk9SX0NPTE9SfUVSUk9SICAgLSBkaXJlY3RvcnkgJHtCQVNIX0ZSQU1FV09SS19MT0dfRklMRSUvKn0gaXMgbm90IHdyaXRhYmxlJHtfX1JFU0VUX0NPTE9SfSIgPiYyCiAgICAgICAgZmkKICAgICAgZWxpZiAhIHRvdWNoIC0tbm8tY3JlYXRlICIke0JBU0hfRlJBTUVXT1JLX0xPR19GSUxFfSIgMj4vZGV2L251bGw7IHRoZW4KICAgICAgICBCQVNIX0ZSQU1FV09SS19MT0dfTEVWRUw9JHtfX0xFVkVMX09GRn0KICAgICAgICBlY2hvIC1lICIke19fRVJST1JfQ09MT1J9RVJST1IgICAtIEZpbGUgJHtCQVNIX0ZSQU1FV09SS19MT0dfRklMRX0gaXMgbm90IHdyaXRhYmxlJHtfX1JFU0VUX0NPTE9SfSIgPiYyCiAgICAgIGZpCiAgICBlbGlmIFtbICEgLXcgIiR7QkFTSF9GUkFNRVdPUktfTE9HX0ZJTEV9IiBdXTsgdGhlbgogICAgICBCQVNIX0ZSQU1FV09SS19MT0dfTEVWRUw9JHtfX0xFVkVMX09GRn0KICAgICAgZWNobyAtZSAiJHtfX0VSUk9SX0NPTE9SfUVSUk9SICAgLSBGaWxlICR7QkFTSF9GUkFNRVdPUktfTE9HX0ZJTEV9IGlzIG5vdCB3cml0YWJsZSR7X19SRVNFVF9DT0xPUn0iID4mMgogICAgZmkKICBmaQoKICBpZiAoKEJBU0hfRlJBTUVXT1JLX0xPR19MRVZFTCA+IF9fTEVWRUxfT0ZGKSk7IHRoZW4KICAgICMgd2lsbCBhbHdheXMgYmUgY3JlYXRlZCBldmVuIGlmIG5vdCBpbiBpbmZvIGxldmVsCiAgICBMb2c6OmxvZ01lc3NhZ2UgIklORk8iICJMb2dnaW5nIHRvIGZpbGUgJHtCQVNIX0ZSQU1FV09SS19MT0dfRklMRX0gLSBMb2cgbGV2ZWwgJHtCQVNIX0ZSQU1FV09SS19MT0dfTEVWRUx9IgogICAgaWYgKChCQVNIX0ZSQU1FV09SS19MT0dfRklMRV9NQVhfUk9UQVRJT04gPiAwKSk7IHRoZW4KICAgICAgTG9nOjpyb3RhdGUgIiR7QkFTSF9GUkFNRVdPUktfTE9HX0ZJTEV9IiAiJHtCQVNIX0ZSQU1FV09SS19MT0dfRklMRV9NQVhfUk9UQVRJT059IgogICAgZmkKICBmaQp9CgojIEBkZXNjcmlwdGlvbiBEaXNwbGF5IG1lc3NhZ2UgdXNpbmcgZXJyb3IgY29sb3IgKHJlZCkKIyBAYXJnICQxIG1lc3NhZ2U6U3RyaW5nIHRoZSBtZXNzYWdlIHRvIGRpc3BsYXkKTG9nOjpkaXNwbGF5RXJyb3IoKSB7CiAgaWYgKChCQVNIX0ZSQU1FV09SS19ESVNQTEFZX0xFVkVMID49IF9fTEVWRUxfRVJST1IpKTsgdGhlbgogICAgTG9nOjpjb21wdXRlRHVyYXRpb24KICAgIGVjaG8gLWUgIiR7X19FUlJPUl9DT0xPUn1FUlJPUiAgIC0gJHtMT0dfQ09OVEVYVDotfSR7TE9HX0xBU1RfRFVSQVRJT05fU1RSOi19JHsxfSR7X19SRVNFVF9DT0xPUn0iID4mMgogIGZpCiAgTG9nOjpsb2dFcnJvciAiJDEiCn0KCiMgQGRlc2NyaXB0aW9uIFRvIGJlIGNhbGxlZCBiZWZvcmUgbG9nZ2luZyBpbiB0aGUgbG9nIGZpbGUKIyBAYXJnICQxIGZpbGU6c3RyaW5nIGxvZyBmaWxlIG5hbWUKIyBAYXJnICQyIG1heExvZ0ZpbGVzQ291bnQ6aW50IG1heGltdW0gbnVtYmVyIG9mIGxvZyBmaWxlcwpMb2c6OnJvdGF0ZSgpIHsKICBsb2NhbCBmaWxlPSIkMSIKICBsb2NhbCBtYXhMb2dGaWxlc0NvdW50PSIkezI6LTV9IgoKICBpZiBbWyAhIC1mICIke2ZpbGV9IiBdXTsgdGhlbgogICAgTG9nOjpkaXNwbGF5RGVidWcgIkxvZyBmaWxlICR7ZmlsZX0gZG9lc24ndCBleGlzdCB5ZXQiCiAgICByZXR1cm4gMAogIGZpCiAgbG9jYWwgaQogIGZvciAoKGkgPSBtYXhMb2dGaWxlc0NvdW50IC0gMTsgaSA+IDA7IGktLSkpOyBkbwogICAgTG9nOjpkaXNwbGF5SW5mbyAiTG9nIHJvdGF0aW9uICR7ZmlsZX0uJHtpfSB0byAke2ZpbGV9LiQoKGkgKyAxKSkiCiAgICBtdiAiJHtmaWxlfS4ieyIke2l9IiwiJCgoaSArIDEpKSJ9ICY+L2Rldi9udWxsIHx8IHRydWUKICBkb25lCiAgaWYgY3AgIiR7ZmlsZX0iICIke2ZpbGV9LjEiICY+L2Rldi9udWxsOyB0aGVuCiAgICBlY2hvID4iJHtmaWxlfSIgIyByZXNldCBsb2cgZmlsZQogICAgTG9nOjpkaXNwbGF5SW5mbyAiTG9nIHJvdGF0aW9uICR7ZmlsZX0gdG8gJHtmaWxlfS4xIgogIGZpCn0KCiMgQGRlc2NyaXB0aW9uIGxvYWQgY29sb3IgdGhlbWUKIyBAbm9hcmdzCiMgQGVudiBCQVNIX0ZSQU1FV09SS19USEVNRSBTdHJpbmcgdGhlbWUgdG8gdXNlCiMgQGVudiBMT0FEX1RIRU1FIGludCAwIHRvIGF2b2lkIGxvYWRpbmcgdGhlbWUKIyBAZXhpdGNvZGUgMCBhbHdheXMgc3VjY2Vzc2Z1bApVSTo6cmVxdWlyZVRoZW1lKCkgewogIGlmIFtbICIke0xPQURfVEhFTUU6LTF9IiA9ICIxIiBdXTsgdGhlbgogICAgVUk6OnRoZW1lICIke0JBU0hfRlJBTUVXT1JLX1RIRU1FLWRlZmF1bHR9IgogIGZpCn0KCiMgQGRlc2NyaXB0aW9uIGxvZyBtZXNzYWdlIHRvIGZpbGUKIyBAYXJnICQxIG1lc3NhZ2U6U3RyaW5nIHRoZSBtZXNzYWdlIHRvIGRpc3BsYXkKTG9nOjpsb2dFcnJvcigpIHsKICBpZiAoKEJBU0hfRlJBTUVXT1JLX0xPR19MRVZFTCA+PSBfX0xFVkVMX0VSUk9SKSk7IHRoZW4KICAgIExvZzo6bG9nTWVzc2FnZSAiJHsyOi1FUlJPUn0iICIkMSIKICBmaQp9CgojIEBkZXNjcmlwdGlvbiBsb2FkIGNvbG9ycyB0aGVtZSBjb25zdGFudHMKIyBAd2FybmluZyBpZiB0dHkgbm90IG9wZW5lZCwgbm9Db2xvciB0aGVtZSB3aWxsIGJlIGNob3NlbgojIEBhcmcgJDEgdGhlbWU6U3RyaW5nIHRoZSB0aGVtZSB0byB1c2UgKGRlZmF1bHQsIG5vQ29sb3IpCiMgQGFyZyAkQCBhcmdzOlN0cmluZ1tdCiMgQHNldCBfX0VSUk9SX0NPTE9SIFN0cmluZyBpbmRpY2F0ZSBlcnJvciBzdGF0dXMKIyBAc2V0IF9fSU5GT19DT0xPUiBTdHJpbmcgaW5kaWNhdGUgaW5mbyBzdGF0dXMKIyBAc2V0IF9fU1VDQ0VTU19DT0xPUiBTdHJpbmcgaW5kaWNhdGUgc3VjY2VzcyBzdGF0dXMKIyBAc2V0IF9fV0FSTklOR19DT0xPUiBTdHJpbmcgaW5kaWNhdGUgd2FybmluZyBzdGF0dXMKIyBAc2V0IF9fU0tJUFBFRF9DT0xPUiBTdHJpbmcgaW5kaWNhdGUgc2tpcHBlZCBzdGF0dXMKIyBAc2V0IF9fREVCVUdfQ09MT1IgU3RyaW5nIGluZGljYXRlIGRlYnVnIHN0YXR1cwojIEBzZXQgX19IRUxQX0NPTE9SIFN0cmluZyBpbmRpY2F0ZSBoZWxwIHN0YXR1cwojIEBzZXQgX19URVNUX0NPTE9SIFN0cmluZyBub3QgdXNlZAojIEBzZXQgX19URVNUX0VSUk9SX0NPTE9SIFN0cmluZyBub3QgdXNlZAojIEBzZXQgX19IRUxQX1RJVExFX0NPTE9SIFN0cmluZyB1c2VkIHRvIGRpc3BsYXkgaGVscCB0aXRsZSBpbiBoZWxwIHN0cmluZ3MKIyBAc2V0IF9fSEVMUF9PUFRJT05fQ09MT1IgU3RyaW5nIHVzZWQgdG8gZGlzcGxheSBoaWdobGlnaHQgb3B0aW9ucyBpbiBoZWxwIHN0cmluZ3MKIwojIEBzZXQgX19SRVNFVF9DT0xPUiBTdHJpbmcgcmVzZXQgZGVmYXVsdCBjb2xvcgojCiMgQHNldCBfX0hFTFBfRVhBTVBMRSBTdHJpbmcgdG8gcmVtb3ZlCiMgQHNldCBfX0hFTFBfVElUTEUgU3RyaW5nIHRvIHJlbW92ZQojIEBzZXQgX19IRUxQX05PUk1BTCBTdHJpbmcgdG8gcmVtb3ZlCiMgc2hlbGxjaGVjayBkaXNhYmxlPVNDMjAzNApVSTo6dGhlbWUoKSB7CiAgbG9jYWwgdGhlbWU9IiR7MS1kZWZhdWx0fSIKICBpZiBbWyAhICIke3RoZW1lfSIgPX4gLWZvcmNlJCBdXSAmJiAhIEFzc2VydDo6dHR5OyB0aGVuCiAgICB0aGVtZT0ibm9Db2xvciIKICBmaQogIGNhc2UgIiR7dGhlbWV9IiBpbgogICAgZGVmYXVsdCB8IGRlZmF1bHQtZm9yY2UpCiAgICAgIHRoZW1lPSJkZWZhdWx0IgogICAgICA7OwogICAgbm9Db2xvcikgOzsKICAgICopCiAgICAgIExvZzo6ZmF0YWwgImludmFsaWQgdGhlbWUgcHJvdmlkZWQiCiAgICAgIDs7CiAgZXNhYwogIGlmIFtbICIke3RoZW1lfSIgPSAiZGVmYXVsdCIgXV07IHRoZW4KICAgIEJBU0hfRlJBTUVXT1JLX1RIRU1FPSJkZWZhdWx0IgogICAgIyBjaGVjayBjb2xvcnMgYXBwbGljYWJsZSBodHRwczovL21pc2MuZmxvZ2lzb2Z0LmNvbS9iYXNoL3RpcF9jb2xvcnNfYW5kX2Zvcm1hdHRpbmcKICAgIF9fRVJST1JfQ09MT1I9J1xlWzMxbScgICAgICAgICAjIFJlZAogICAgX19JTkZPX0NPTE9SPSdcZVs0NG0nICAgICAgICAgICMgd2hpdGUgb24gbGlnaHRCbHVlCiAgICBfX1NVQ0NFU1NfQ09MT1I9J1xlWzMybScgICAgICAgIyBHcmVlbgogICAgX19XQVJOSU5HX0NPTE9SPSdcZVszM20nICAgICAgICMgWWVsbG93CiAgICBfX1NLSVBQRURfQ09MT1I9J1xlWzMzbScgICAgICAgIyBZZWxsb3cKICAgIF9fREVCVUdfQ09MT1I9J1xlWzM3bScgICAgICAgICAjIEdyZXkKICAgIF9fSEVMUF9DT0xPUj0nXGVbNzs0OTszM20nICAgICAjIEJsYWNrIG9uIEdvbGQKICAgIF9fVEVTVF9DT0xPUj0nXGVbMTAwbScgICAgICAgICAjIExpZ2h0IG1hZ2VudGEKICAgIF9fVEVTVF9FUlJPUl9DT0xPUj0nXGVbNDFtJyAgICAjIHdoaXRlIG9uIHJlZAogICAgX19IRUxQX1RJVExFX0NPTE9SPSJcZVsxOzM3bSIgICMgQm9sZAogICAgX19IRUxQX09QVElPTl9DT0xPUj0iXGVbMTszNG0iICMgQmx1ZQogICAgIyBJbnRlcm5hbDogcmVzZXQgY29sb3IKICAgIF9fUkVTRVRfQ09MT1I9J1xlWzBtJyAjIFJlc2V0IENvbG9yCiAgICAjIHNoZWxsY2hlY2sgZGlzYWJsZT1TQzIxNTUsU0MyMDM0CiAgICBfX0hFTFBfRVhBTVBMRT0iJChlY2hvIC1lICJcZVsyOzk3bSIpIgogICAgIyBzaGVsbGNoZWNrIGRpc2FibGU9U0MyMTU1LFNDMjAzNAogICAgX19IRUxQX1RJVExFPSIkKGVjaG8gLWUgIlxlWzE7MzdtIikiCiAgICAjIHNoZWxsY2hlY2sgZGlzYWJsZT1TQzIxNTUsU0MyMDM0CiAgICBfX0hFTFBfTk9STUFMPSIkKGVjaG8gLWUgIlwwMzNbMG0iKSIKICBlbHNlCiAgICBCQVNIX0ZSQU1FV09SS19USEVNRT0ibm9Db2xvciIKICAgICMgY2hlY2sgY29sb3JzIGFwcGxpY2FibGUgaHR0cHM6Ly9taXNjLmZsb2dpc29mdC5jb20vYmFzaC90aXBfY29sb3JzX2FuZF9mb3JtYXR0aW5nCiAgICBfX0VSUk9SX0NPTE9SPScnCiAgICBfX0lORk9fQ09MT1I9JycKICAgIF9fU1VDQ0VTU19DT0xPUj0nJwogICAgX19XQVJOSU5HX0NPTE9SPScnCiAgICBfX1NLSVBQRURfQ09MT1I9JycKICAgIF9fREVCVUdfQ09MT1I9JycKICAgIF9fSEVMUF9DT0xPUj0nJwogICAgX19URVNUX0NPTE9SPScnCiAgICBfX1RFU1RfRVJST1JfQ09MT1I9JycKICAgIF9fSEVMUF9USVRMRV9DT0xPUj0nJwogICAgX19IRUxQX09QVElPTl9DT0xPUj0nJwogICAgIyBJbnRlcm5hbDogcmVzZXQgY29sb3IKICAgIF9fUkVTRVRfQ09MT1I9JycKICAgIF9fSEVMUF9FWEFNUExFPScnCiAgICBfX0hFTFBfVElUTEU9JycKICAgIF9fSEVMUF9OT1JNQUw9JycKICBmaQp9CgojIEBkZXNjcmlwdGlvbiBjaGVjayBpZiB0dHkgKGludGVyYWN0aXZlIG1vZGUpIGlzIGFjdGl2ZQojIEBub2FyZ3MKIyBAZXhpdGNvZGUgMSBpZiB0dHkgbm90IGFjdGl2ZQojIEBlbnYgTk9OX0lOVEVSQUNUSVZFIGlmIDEgY29uc2lkZXIgYXMgbm90IGludGVyYWN0aXZlIGV2ZW4gaWYgZW52aXJvbm1lbnQgaXMgaW50ZXJhY3RpdmUKIyBAZW52IElOVEVSQUNUSVZFIGlmIDEgY29uc2lkZXIgYXMgaW50ZXJhY3RpdmUgZXZlbiBpZiBlbnZpcm9ubWVudCBpcyBub3QgaW50ZXJhY3RpdmUKQXNzZXJ0Ojp0dHkoKSB7CiAgaWYgW1sgIiR7Tk9OX0lOVEVSQUNUSVZFOi0wfSIgPSAiMSIgXV07IHRoZW4KICAgIHJldHVybiAxCiAgZmkKICBpZiBbWyAiJHtJTlRFUkFDVElWRTotMH0iID0gIjEiIF1dOyB0aGVuCiAgICByZXR1cm4gMAogIGZpCiAgIyBjaGVjayBpZiBzdGRvdXQgb3Igc3RkZXJyIGlzIGNvbm5lY3RlZCB0byB0ZXJtaW5hbAogIFtbIC10IDEgfHwgLXQgMiBdXQp9CgojIEBkZXNjcmlwdGlvbiBEaXNwbGF5IG1lc3NhZ2UgdXNpbmcgZXJyb3IgY29sb3IgKHJlZCkgYW5kIGV4aXQgaW1tZWRpYXRlbHkgd2l0aCBlcnJvciBzdGF0dXMgMQojIEBhcmcgJDEgbWVzc2FnZTpTdHJpbmcgdGhlIG1lc3NhZ2UgdG8gZGlzcGxheQpMb2c6OmZhdGFsKCkgewogIExvZzo6Y29tcHV0ZUR1cmF0aW9uCiAgZWNobyAtZSAiJHtfX0VSUk9SX0NPTE9SfUZBVEFMICAgLSAke0xPR19DT05URVhUOi19JHtMT0dfTEFTVF9EVVJBVElPTl9TVFI6LX0kezF9JHtfX1JFU0VUX0NPTE9SfSIgPiYyCiAgTG9nOjpsb2dGYXRhbCAiJDEiCiAgZXhpdCAxCn0KCiMgQGRlc2NyaXB0aW9uIGxvZyBtZXNzYWdlIHRvIGZpbGUKIyBAYXJnICQxIG1lc3NhZ2U6U3RyaW5nIHRoZSBtZXNzYWdlIHRvIGRpc3BsYXkKTG9nOjpsb2dGYXRhbCgpIHsKICBMb2c6OmxvZ01lc3NhZ2UgIiR7MjotRkFUQUx9IiAiJDEiCn0KCiMgRlVOQ1RJT05TCgpmYWNhZGVfbWFpbl9sb2FkQ29uZmlnRmlsZXNzaCgpIHsKCmlmIEFzc2VydDo6ZnVuY3Rpb25FeGlzdHMgaW5pdEZhY2FkZTsgdGhlbgogIGluaXRGYWNhZGUKZmkKCiMgQHJlcXVpcmUgQ29tcGlsZXI6OkZhY2FkZTo6cmVxdWlyZUNvbW1hbmRCaW5EaXIKCmRlY2xhcmUgZGlyPSIkMSIKaWYgW1sgISAtZCAiJHtkaXJ9IiBdXTsgdGhlbgogIHJldHVybiAxCmZpCnNoaWZ0IHx8IHRydWUKZGVjbGFyZSAtYSBleHRlbnNpb25zPSgiJEAiKQppZiAoKCR7I2V4dGVuc2lvbnNbQF19IDwgMSkpOyB0aGVuCiAgZXhpdCAyCmZpCmRlY2xhcmUgLWEgZmluZENtZD0oCiAgZmluZCAiJHtkaXJ9IiAtZXhlY3V0YWJsZSAtdHlwZSAnZixsJyAnKCcKKQpmb3IgZXh0IGluICIke2V4dGVuc2lvbnNbQF19IjsgZG8KICBmaW5kQ21kKz0oLW5hbWUgXCouIiR7ZXh0fSIgLW8pCmRvbmUKdW5zZXQgJ2ZpbmRDbWRbLTFdJwpmaW5kQ21kKz0oJyknIC1wcmludGYgJyVwXG4nKQoKIiR7ZmluZENtZFtAXX0iIDI+L2Rldi9udWxsIHwgYXdrIC12IGV4dD0iJChwcmludGYgJyVzfCcgIiR7ZXh0ZW5zaW9uc1tAXX0iKSIgJwogIEJFR0lOIHsKICAgIEZTPSIuIjsKICAgIHNwbGl0KGV4dCwgZXh0QXJyLCAifCIpOwogICAgZm9yIChpIGluIGV4dEFycikgewogICAgICBleHRJbmRleFtleHRBcnJbaV1dID0gaTsKICAgIH0KICB9CiAgZnVuY3Rpb24gYmFzZW5hbWVXaXRob3V0RXh0ZW5zaW9uKGZpbGUpIHsKICAgIHN1YigiLiovIiwgIiIsIGZpbGUpCiAgICBzdWIoL1wuW14uXSskLywgIiIsIGZpbGUpCiAgICByZXR1cm4gZmlsZQogIH0KICB7CiAgICBpZiAoJE5GIGluIGV4dEluZGV4KSB7CiAgICAgIGZpbGVCYXNlPWJhc2VuYW1lV2l0aG91dEV4dGVuc2lvbigkMCkKICAgICAgcHJpbnQgZmlsZUJhc2UgIlx0IiBleHRJbmRleFskTkZdICJcdCIgJDA7CiAgICB9CiAgfQonIHwgc29ydCAtdCQnXHQnIC1rMSwxIC1rMiwyIHwgY3V0IC1mMy0KCn0KCmZhY2FkZV9tYWluX2xvYWRDb25maWdGaWxlc3NoICIkQCIK" "755"

declare -gx embed_file_loadConfigFiles="${PERSISTENT_TMPDIR:-/tmp}/1361c58830a7be9c06aa1b1f559dbbdb/loadConfigFiles"
Compiler::Embed::extractFileFromBase64 "${PERSISTENT_TMPDIR:-/tmp}/8537ff72412594780cf9f312e8925b1e/talkScript" "cGFyYW0oCiAgICBbUGFyYW1ldGVyKE1hbmRhdG9yeT0kdHJ1ZSwgUG9zaXRpb249MCldCiAgICBbc3RyaW5nXQogICAgJG1zZyA9ICcnCikKCkFkZC1UeXBlIC1Bc3NlbWJseU5hbWUgU3lzdGVtLnNwZWVjaAokc3BlYWsgPSBOZXctT2JqZWN0IFN5c3RlbS5TcGVlY2guU3ludGhlc2lzLlNwZWVjaFN5bnRoZXNpemVyCiRzcGVhay5TcGVhaygkbXNnKQo=" "644"

declare -gx embed_file_talkScript="${PERSISTENT_TMPDIR:-/tmp}/8537ff72412594780cf9f312e8925b1e/talkScript"

facade_main_ShellZshsh() {

# REQUIRES
Linux::requireTarCommand
Env::requireLoad
UI::requireTheme
Linux::requireUbuntu
Log::requireLoad
Linux::Wsl::requireWsl
Compiler::Facade::requireCommandBinDir

if Assert::functionExists initFacade; then
  initFacade
fi
Engine::Config::loadConfig
# @description create sudoer file and add traps to remove it at the end
# @arg $1 sudoerFile:String the file path to create
# @env USERNAME
# shellcheck disable=SC2317
local sudoerFile="${SUDOER_FILE_PREFIX}/etc/sudoers.d/bash-dev-env-no-password"
if [[ -f "${sudoerFile}" ]]; then
  # sudoerFile probably already managed by parent script
  true
else
  cleanSudoer() {
    local rc=$?
    if [[ -f "${sudoerFile}" ]]; then
      ${SUDO:-sudo} rm -f "${sudoerFile}" || true
    fi
    exit "${rc}"
  }
  trap cleanSudoer EXIT HUP QUIT ABRT TERM

  Log::displayInfo "Creating sudoer file"
  echo "${USERNAME} ALL=(ALL) NOPASSWD: ALL" |
    ${SUDO:-sudo} tee "${sudoerFile}" >/dev/null
  ${SUDO:-sudo} chmod 0440 "${sudoerFile}"
fi

# @require Compiler::Facade::requireCommandBinDir
# ROOT_DIR_RELATIVE_TO_BIN_DIR=..
# FACADE
# IMPLEMENT InstallScripts::interface
# EMBED "${BASH_DEV_ENV_ROOT_DIR}/src/_binaries/ShellZsh/conf" as conf_dir
# EMBED "${BASH_DEV_ENV_ROOT_DIR}/bin/loadConfigFiles" as loadConfigFiles
# EMBED "${FRAMEWORK_ROOT_DIR}/src/UI/talk.ps1" as talkScript

declare -a BASH_FRAMEWORK_ARGV_FILTERED=()

copyrightCallback() {
  if [[ -z "${copyrightBeginYear}" ]]; then
    copyrightBeginYear="$(date +%Y)"
  fi
  echo "Copyright (c) ${copyrightBeginYear}-now Franois Chastanet"
}

# shellcheck disable=SC2317 # if function is overridden
updateArgListInfoVerboseCallback() {
  BASH_FRAMEWORK_ARGV_FILTERED+=(--verbose)
}
# shellcheck disable=SC2317 # if function is overridden
updateArgListDebugVerboseCallback() {
  BASH_FRAMEWORK_ARGV_FILTERED+=(-vv)
}
# shellcheck disable=SC2317 # if function is overridden
updateArgListTraceVerboseCallback() {
  BASH_FRAMEWORK_ARGV_FILTERED+=(-vvv)
}
# shellcheck disable=SC2317 # if function is overridden
updateArgListEnvFileCallback() { :; }
# shellcheck disable=SC2317 # if function is overridden
updateArgListLogLevelCallback() { :; }
# shellcheck disable=SC2317 # if function is overridden
updateArgListDisplayLevelCallback() { :; }
# shellcheck disable=SC2317 # if function is overridden
updateArgListNoColorCallback() {
  BASH_FRAMEWORK_ARGV_FILTERED+=(--no-color)
}
# shellcheck disable=SC2317 # if function is overridden
updateArgListThemeCallback() { :; }
# shellcheck disable=SC2317 # if function is overridden
updateArgListQuietCallback() { :; }

# shellcheck disable=SC2317 # if function is overridden
optionHelpCallback() {
  installScriptCommand help
  exit 0
}

# shellcheck disable=SC2317 # if function is overridden
optionVersionCallback() {
  echo "${SCRIPT_NAME} version 1.0"
  exit 0
}

# shellcheck disable=SC2317 # if function is overridden
optionEnvFileCallback() {
  local envFile="$2"
  Log::displayWarning "Command ${SCRIPT_NAME} - Option --env-file is deprecated and will be removed in the future"
  if [[ ! -f "${envFile}" || ! -r "${envFile}" ]]; then
    Log::displayError "Command ${SCRIPT_NAME} - Option --env-file - File '${envFile}' doesn't exist"
    exit 1
  fi
}

# shellcheck disable=SC2317 # if function is overridden
optionInfoVerboseCallback() {
  BASH_FRAMEWORK_ARGS_VERBOSE_OPTION='--verbose'
  BASH_FRAMEWORK_ARGS_VERBOSE=${__VERBOSE_LEVEL_INFO}
  echo "BASH_FRAMEWORK_DISPLAY_LEVEL=${__LEVEL_INFO}" >> "${overrideEnvFile}"
}

# shellcheck disable=SC2317 # if function is overridden
optionDebugVerboseCallback() {
  BASH_FRAMEWORK_ARGS_VERBOSE_OPTION='-vv'
  BASH_FRAMEWORK_ARGS_VERBOSE=${__VERBOSE_LEVEL_DEBUG}
  echo "BASH_FRAMEWORK_DISPLAY_LEVEL=${__LEVEL_DEBUG}" >> "${overrideEnvFile}"
}

# shellcheck disable=SC2317 # if function is overridden
optionTraceVerboseCallback() {
  BASH_FRAMEWORK_ARGS_VERBOSE_OPTION='-vvv'
  BASH_FRAMEWORK_ARGS_VERBOSE=${__VERBOSE_LEVEL_TRACE}
  echo "BASH_FRAMEWORK_DISPLAY_LEVEL=${__LEVEL_DEBUG}" >> "${overrideEnvFile}"
}

getLevel() {
  local levelName="$1"
  case "${levelName^^}" in
    OFF)
      echo "${__LEVEL_OFF}"
      ;;
    ERR | ERROR)
      echo "${__LEVEL_ERROR}"
      ;;
    WARN | WARNING)
      echo "${__LEVEL_WARNING}"
      ;;
    INFO)
      echo "${__LEVEL_INFO}"
      ;;
    DEBUG | TRACE)
      echo "${__LEVEL_DEBUG}"
      ;;
    *)
      Log::displayError "Command ${SCRIPT_NAME} - Invalid level ${level}"
      return 1
  esac
}

getVerboseLevel() {
  local levelName="$1"
  case "${levelName^^}" in
    OFF)
      echo "${__VERBOSE_LEVEL_OFF}"
      ;;
    ERR | ERROR | WARN | WARNING | INFO)
      echo "${__VERBOSE_LEVEL_INFO}"
      ;;
    DEBUG)
      echo "${__VERBOSE_LEVEL_DEBUG}"
      ;;
    TRACE)
      echo "${__VERBOSE_LEVEL_TRACE}"
      ;;
    *)
      Log::displayError "Command ${SCRIPT_NAME} - Invalid level ${level}"
      return 1
  esac
}

# shellcheck disable=SC2317 # if function is overridden
optionDisplayLevelCallback() {
  local level="$2"
  local logLevel verboseLevel
  logLevel="$(getLevel "${level}")"
  verboseLevel="$(getVerboseLevel "${level}")"
  BASH_FRAMEWORK_ARGS_VERBOSE=${verboseLevel}
  echo "BASH_FRAMEWORK_DISPLAY_LEVEL=${logLevel}" >> "${overrideEnvFile}"
}

# shellcheck disable=SC2317 # if function is overridden
optionLogLevelCallback() {
  local level="$2"
  local logLevel verboseLevel
  logLevel="$(getLevel "${level}")"
  verboseLevel="$(getVerboseLevel "${level}")"
  BASH_FRAMEWORK_ARGS_VERBOSE=${verboseLevel}
  echo "BASH_FRAMEWORK_LOG_LEVEL=${logLevel}" >> "${overrideEnvFile}"
}

# shellcheck disable=SC2317 # if function is overridden
optionLogFileCallback() {
  local logFile="$2"
  echo "BASH_FRAMEWORK_LOG_FILE='${logFile}'" >> "${overrideEnvFile}"
}

# shellcheck disable=SC2317 # if function is overridden
optionQuietCallback() {
  echo "BASH_FRAMEWORK_QUIET_MODE=1" >> "${overrideEnvFile}"
}

# shellcheck disable=SC2317 # if function is overridden
optionNoColorCallback() {
  UI::theme "noColor"
}

# shellcheck disable=SC2317 # if function is overridden
optionThemeCallback() {
  UI::theme "$2"
}

displayConfig() {
  echo "Config"
  UI::drawLine "-"
  local var
  while read -r var; do
    printf '%-40s = %s\n' "${var}" "$(declare -p "${var}" | sed -E -e 's/^[^=]+=(.*)/\1/')"
  done < <(typeset -p | awk 'match($3, "^(BASH_FRAMEWORK_[^=]+)=", m) { print m[1] }' | sort)
  exit 0
}

optionBashFrameworkConfigCallback() {
  if [[ ! -f "$2" ]]; then
    Log::fatal "Command ${SCRIPT_NAME} - Bash framework config file '$2' does not exists"
  fi
}

defaultFrameworkConfig="$(
  cat <<'EOF'
# copied from src/_includes/.framework-config.default
# shellcheck disable=SC2034

REAL_SCRIPT_FILE="${REAL_SCRIPT_FILE:-$(readlink -e "$(realpath "${BASH_SOURCE[0]}")")}"
FRAMEWORK_ROOT_DIR="${FRAMEWORK_ROOT_DIR:-${REAL_SCRIPT_FILE%/*/*}}"
FRAMEWORK_SRC_DIR="${FRAMEWORK_SRC_DIR:-${FRAMEWORK_ROOT_DIR}/src}"
FRAMEWORK_BIN_DIR="${FRAMEWORK_BIN_DIR:-${FRAMEWORK_ROOT_DIR}/bin}"
FRAMEWORK_VENDOR_DIR="${FRAMEWORK_VENDOR_DIR:-${FRAMEWORK_ROOT_DIR}/vendor}"
FRAMEWORK_VENDOR_BIN_DIR="${FRAMEWORK_VENDOR_BIN_DIR:-${FRAMEWORK_ROOT_DIR}/vendor/bin}"

# describe the functions that will be skipped from being imported
FRAMEWORK_FUNCTIONS_IGNORE_REGEXP="${FRAMEWORK_FUNCTIONS_IGNORE_REGEXP:-^(Namespace::functions|Functions::myFunction|Namespace::requireSomething|Acquire::ForceIPv4)$}"
# describe the files that do not contain function to be imported
NON_FRAMEWORK_FILES_REGEXP="${NON_FRAMEWORK_FILES_REGEXP:-(^bin/|.framework-config|.bats$|/testsData/|^manualTests/|/_.sh$|/ZZZ.sh$|/__all.sh$|^src/_binaries|^src/_includes|^src/batsHeaders.sh$|^src/_standalone)}"
# describe the files that are allowed to not have an associated bats file
BATS_FILE_NOT_NEEDED_REGEXP="${BATS_FILE_NOT_NEEDED_REGEXP:-(^bin/|.framework-config|.bats$|/testsData/|^manualTests/|/_.sh$|/ZZZ.sh$|/__all.sh$|^src/batsHeaders.sh$|^src/_includes)}"
# describe the files that are allowed to not have a function matching the filename
FRAMEWORK_FILES_FUNCTION_MATCHING_IGNORE_REGEXP="${FRAMEWORK_FILES_FUNCTION_MATCHING_IGNORE_REGEXP:-^bin/|^\.framework-config$|\.tpl$|/testsData/|^manualTests/|\.bats$}"
# Source directories
if [[ ! -v FRAMEWORK_SRC_DIRS ]]; then
  FRAMEWORK_SRC_DIRS=(
    "${FRAMEWORK_ROOT_DIR}/src"
  )
fi

# export here all the variables that will be used in your templates
export REPOSITORY_URL="${REPOSITORY_URL:-https://github.com/fchastanet/bash-tools-framework}"

BASH_FRAMEWORK_THEME="${BASH_FRAMEWORK_THEME:-default}"
BASH_FRAMEWORK_LOG_LEVEL="${BASH_FRAMEWORK_LOG_LEVEL:-0}"
BASH_FRAMEWORK_DISPLAY_LEVEL="${BASH_FRAMEWORK_DISPLAY_LEVEL:-3}"
BASH_FRAMEWORK_LOG_FILE="${BASH_FRAMEWORK_LOG_FILE:-${FRAMEWORK_ROOT_DIR}/logs/${0##*/}.log}"
BASH_FRAMEWORK_LOG_FILE_MAX_ROTATION="${BASH_FRAMEWORK_LOG_FILE_MAX_ROTATION:-5}"
EOF
)"

overrideEnvFile="$(Framework::createTempFile "overrideEnvFile")"

commandOptionParseFinished() {
  # load default template framework config
  defaultEnvFile="${PERSISTENT_TMPDIR}/.framework-config"
  echo "${defaultFrameworkConfig}" > "${defaultEnvFile}"
  local -a files=("${defaultEnvFile}")
  if [[ -f "${envFile}" ]]; then
    files+=("${envFile}")
  fi
  # shellcheck disable=SC2154
  if [[ -f "${optionBashFrameworkConfig}" ]]; then
    files+=("${optionBashFrameworkConfig}")
  fi
  files+=("${overrideEnvFile}")
  Env::requireLoad "${files[@]}"
  Log::requireLoad
  # shellcheck disable=SC2154
  if [[ "${optionConfig}" = "1" ]]; then
    displayConfig
  fi
}

export SKIP_INSTALL
export SKIP_CONFIGURE
export SKIP_TEST
export SKIP_DEPENDENCIES

installScriptCommand() {
  local options_parse_cmd="$1"
  shift || true

  if [[ "${options_parse_cmd}" = "parse" ]]; then
    SKIP_CONFIGURE="0"
    local -i options_parse_optionParsedCountSKIP_CONFIGURE
    ((options_parse_optionParsedCountSKIP_CONFIGURE = 0)) || true
    SKIP_INSTALL="0"
    local -i options_parse_optionParsedCountSKIP_INSTALL
    ((options_parse_optionParsedCountSKIP_INSTALL = 0)) || true
    SKIP_TEST="0"
    local -i options_parse_optionParsedCountSKIP_TEST
    ((options_parse_optionParsedCountSKIP_TEST = 0)) || true
    SKIP_DEPENDENCIES="0"
    local -i options_parse_optionParsedCountSKIP_DEPENDENCIES
    ((options_parse_optionParsedCountSKIP_DEPENDENCIES = 0)) || true
    local -i options_parse_optionParsedCountOptionBashFrameworkConfig
    ((options_parse_optionParsedCountOptionBashFrameworkConfig = 0)) || true
    optionConfig="0"
    local -i options_parse_optionParsedCountOptionConfig
    ((options_parse_optionParsedCountOptionConfig = 0)) || true
    optionInfoVerbose="0"
    local -i options_parse_optionParsedCountOptionInfoVerbose
    ((options_parse_optionParsedCountOptionInfoVerbose = 0)) || true
    optionDebugVerbose="0"
    local -i options_parse_optionParsedCountOptionDebugVerbose
    ((options_parse_optionParsedCountOptionDebugVerbose = 0)) || true
    optionTraceVerbose="0"
    local -i options_parse_optionParsedCountOptionTraceVerbose
    ((options_parse_optionParsedCountOptionTraceVerbose = 0)) || true
    optionNoColor="0"
    local -i options_parse_optionParsedCountOptionNoColor
    ((options_parse_optionParsedCountOptionNoColor = 0)) || true
    optionTheme="default"
    local -i options_parse_optionParsedCountOptionTheme
    ((options_parse_optionParsedCountOptionTheme = 0)) || true
    optionHelp="0"
    local -i options_parse_optionParsedCountOptionHelp
    ((options_parse_optionParsedCountOptionHelp = 0)) || true
    optionVersion="0"
    local -i options_parse_optionParsedCountOptionVersion
    ((options_parse_optionParsedCountOptionVersion = 0)) || true
    optionQuiet="0"
    local -i options_parse_optionParsedCountOptionQuiet
    ((options_parse_optionParsedCountOptionQuiet = 0)) || true
    local -i options_parse_optionParsedCountOptionLogLevel
    ((options_parse_optionParsedCountOptionLogLevel = 0)) || true
    local -i options_parse_optionParsedCountOptionLogFile
    ((options_parse_optionParsedCountOptionLogFile = 0)) || true
    local -i options_parse_optionParsedCountOptionDisplayLevel
    ((options_parse_optionParsedCountOptionDisplayLevel = 0)) || true
    # shellcheck disable=SC2034
    local -i options_parse_parsedArgIndex=0
    while (($# > 0)); do
      local options_parse_arg="$1"
      local argOptDefaultBehavior=0
      case "${options_parse_arg}" in
        # Option 1/18
        # Option SKIP_CONFIGURE --skip-config|--skip-configure|--skip-configuration variableType Boolean min 0 max 1 authorizedValues '' regexp ''
        --skip-config | --skip-configure | --skip-configuration)
          # shellcheck disable=SC2034
          SKIP_CONFIGURE="1"
          if ((options_parse_optionParsedCountSKIP_CONFIGURE >= 1)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
            return 1
          fi
          ((++options_parse_optionParsedCountSKIP_CONFIGURE))
          ;;
        # Option 2/18
        # Option SKIP_INSTALL --skip-install|--skip-installation variableType Boolean min 0 max 1 authorizedValues '' regexp ''
        --skip-install | --skip-installation)
          # shellcheck disable=SC2034
          SKIP_INSTALL="1"
          if ((options_parse_optionParsedCountSKIP_INSTALL >= 1)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
            return 1
          fi
          ((++options_parse_optionParsedCountSKIP_INSTALL))
          ;;
        # Option 3/18
        # Option SKIP_TEST --skip-test|--skip-tests variableType Boolean min 0 max 1 authorizedValues '' regexp ''
        --skip-test | --skip-tests)
          # shellcheck disable=SC2034
          SKIP_TEST="1"
          if ((options_parse_optionParsedCountSKIP_TEST >= 1)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
            return 1
          fi
          ((++options_parse_optionParsedCountSKIP_TEST))
          ;;
        # Option 4/18
        # Option SKIP_DEPENDENCIES --skip-dependencies|--skip-deps variableType Boolean min 0 max 1 authorizedValues '' regexp ''
        --skip-dependencies | --skip-deps)
          # shellcheck disable=SC2034
          SKIP_DEPENDENCIES="1"
          if ((options_parse_optionParsedCountSKIP_DEPENDENCIES >= 1)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
            return 1
          fi
          ((++options_parse_optionParsedCountSKIP_DEPENDENCIES))
          ;;
        # Option 5/18
        # Option optionBashFrameworkConfig --bash-framework-config variableType String min 0 max 1 authorizedValues '' regexp ''
        --bash-framework-config)
          shift
          if (($# == 0)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - a value needs to be specified"
            return 1
          fi
          if ((options_parse_optionParsedCountOptionBashFrameworkConfig >= 1)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
            return 1
          fi
          ((++options_parse_optionParsedCountOptionBashFrameworkConfig))
          # shellcheck disable=SC2034
          optionBashFrameworkConfig="$1"
          optionBashFrameworkConfigCallback "${options_parse_arg}" "${optionBashFrameworkConfig}"
          ;;
        # Option 6/18
        # Option optionConfig --config variableType Boolean min 0 max 1 authorizedValues '' regexp ''
        --config)
          # shellcheck disable=SC2034
          optionConfig="1"
          if ((options_parse_optionParsedCountOptionConfig >= 1)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
            return 1
          fi
          ((++options_parse_optionParsedCountOptionConfig))
          ;;
        # Option 7/18
        # Option optionInfoVerbose --verbose|-v variableType Boolean min 0 max 1 authorizedValues '' regexp ''
        --verbose | -v)
          # shellcheck disable=SC2034
          optionInfoVerbose="1"
          if ((options_parse_optionParsedCountOptionInfoVerbose >= 1)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
            return 1
          fi
          ((++options_parse_optionParsedCountOptionInfoVerbose))
          optionInfoVerboseCallback "${options_parse_arg}"
          updateArgListInfoVerboseCallback "${options_parse_arg}"
          ;;
        # Option 8/18
        # Option optionDebugVerbose -vv variableType Boolean min 0 max 1 authorizedValues '' regexp ''
        -vv)
          # shellcheck disable=SC2034
          optionDebugVerbose="1"
          if ((options_parse_optionParsedCountOptionDebugVerbose >= 1)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
            return 1
          fi
          ((++options_parse_optionParsedCountOptionDebugVerbose))
          optionDebugVerboseCallback "${options_parse_arg}"
          updateArgListDebugVerboseCallback "${options_parse_arg}"
          ;;
        # Option 9/18
        # Option optionTraceVerbose -vvv variableType Boolean min 0 max 1 authorizedValues '' regexp ''
        -vvv)
          # shellcheck disable=SC2034
          optionTraceVerbose="1"
          if ((options_parse_optionParsedCountOptionTraceVerbose >= 1)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
            return 1
          fi
          ((++options_parse_optionParsedCountOptionTraceVerbose))
          optionTraceVerboseCallback "${options_parse_arg}"
          updateArgListTraceVerboseCallback "${options_parse_arg}"
          ;;
        # Option 10/18
        # Option optionEnvFiles --env-file variableType StringArray min 0 max -1 authorizedValues '' regexp ''
        --env-file)
          shift
          if (($# == 0)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - a value needs to be specified"
            return 1
          fi
          ((++options_parse_optionParsedCountOptionEnvFiles))
          optionEnvFiles+=("$1")
          optionEnvFileCallback "${options_parse_arg}" "${optionEnvFiles[@]}"
          updateArgListEnvFileCallback "${options_parse_arg}" "${optionEnvFiles[@]}"
          ;;
        # Option 11/18
        # Option optionNoColor --no-color variableType Boolean min 0 max 1 authorizedValues '' regexp ''
        --no-color)
          # shellcheck disable=SC2034
          optionNoColor="1"
          if ((options_parse_optionParsedCountOptionNoColor >= 1)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
            return 1
          fi
          ((++options_parse_optionParsedCountOptionNoColor))
          optionNoColorCallback "${options_parse_arg}"
          updateArgListNoColorCallback "${options_parse_arg}"
          ;;
        # Option 12/18
        # Option optionTheme --theme variableType String min 0 max 1 authorizedValues 'default|default-force|noColor' regexp ''
        --theme)
          shift
          if (($# == 0)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - a value needs to be specified"
            return 1
          fi
          if [[ ! "$1" =~ default|default-force|noColor ]]; then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - value '$1' is not part of authorized values(default|default-force|noColor)"
            return 1
          fi
          if ((options_parse_optionParsedCountOptionTheme >= 1)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
            return 1
          fi
          ((++options_parse_optionParsedCountOptionTheme))
          # shellcheck disable=SC2034
          optionTheme="$1"
          optionThemeCallback "${options_parse_arg}" "${optionTheme}"
          updateArgListThemeCallback "${options_parse_arg}" "${optionTheme}"
          ;;
        # Option 13/18
        # Option optionHelp --help|-h variableType Boolean min 0 max 1 authorizedValues '' regexp ''
        --help | -h)
          # shellcheck disable=SC2034
          optionHelp="1"
          if ((options_parse_optionParsedCountOptionHelp >= 1)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
            return 1
          fi
          ((++options_parse_optionParsedCountOptionHelp))
          optionHelpCallback "${options_parse_arg}"
          ;;
        # Option 14/18
        # Option optionVersion --version variableType Boolean min 0 max 1 authorizedValues '' regexp ''
        --version)
          # shellcheck disable=SC2034
          optionVersion="1"
          if ((options_parse_optionParsedCountOptionVersion >= 1)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
            return 1
          fi
          ((++options_parse_optionParsedCountOptionVersion))
          optionVersionCallback "${options_parse_arg}"
          ;;
        # Option 15/18
        # Option optionQuiet --quiet|-q variableType Boolean min 0 max 1 authorizedValues '' regexp ''
        --quiet | -q)
          # shellcheck disable=SC2034
          optionQuiet="1"
          if ((options_parse_optionParsedCountOptionQuiet >= 1)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
            return 1
          fi
          ((++options_parse_optionParsedCountOptionQuiet))
          optionQuietCallback "${options_parse_arg}"
          updateArgListQuietCallback "${options_parse_arg}"
          ;;
        # Option 16/18
        # Option optionLogLevel --log-level variableType String min 0 max 1 authorizedValues 'OFF|ERR|ERROR|WARN|WARNING|INFO|DEBUG|TRACE' regexp ''
        --log-level)
          shift
          if (($# == 0)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - a value needs to be specified"
            return 1
          fi
          if [[ ! "$1" =~ OFF|ERR|ERROR|WARN|WARNING|INFO|DEBUG|TRACE ]]; then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - value '$1' is not part of authorized values(OFF|ERR|ERROR|WARN|WARNING|INFO|DEBUG|TRACE)"
            return 1
          fi
          if ((options_parse_optionParsedCountOptionLogLevel >= 1)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
            return 1
          fi
          ((++options_parse_optionParsedCountOptionLogLevel))
          # shellcheck disable=SC2034
          optionLogLevel="$1"
          optionLogLevelCallback "${options_parse_arg}" "${optionLogLevel}"
          updateArgListLogLevelCallback "${options_parse_arg}" "${optionLogLevel}"
          ;;
        # Option 17/18
        # Option optionLogFile --log-file variableType String min 0 max 1 authorizedValues '' regexp ''
        --log-file)
          shift
          if (($# == 0)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - a value needs to be specified"
            return 1
          fi
          if ((options_parse_optionParsedCountOptionLogFile >= 1)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
            return 1
          fi
          ((++options_parse_optionParsedCountOptionLogFile))
          # shellcheck disable=SC2034
          optionLogFile="$1"
          optionLogFileCallback "${options_parse_arg}" "${optionLogFile}"
          updateArgListLogFileCallback "${options_parse_arg}" "${optionLogFile}"
          ;;
        # Option 18/18
        # Option optionDisplayLevel --display-level variableType String min 0 max 1 authorizedValues 'OFF|ERR|ERROR|WARN|WARNING|INFO|DEBUG|TRACE' regexp ''
        --display-level)
          shift
          if (($# == 0)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - a value needs to be specified"
            return 1
          fi
          if [[ ! "$1" =~ OFF|ERR|ERROR|WARN|WARNING|INFO|DEBUG|TRACE ]]; then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - value '$1' is not part of authorized values(OFF|ERR|ERROR|WARN|WARNING|INFO|DEBUG|TRACE)"
            return 1
          fi
          if ((options_parse_optionParsedCountOptionDisplayLevel >= 1)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
            return 1
          fi
          ((++options_parse_optionParsedCountOptionDisplayLevel))
          # shellcheck disable=SC2034
          optionDisplayLevel="$1"
          optionDisplayLevelCallback "${options_parse_arg}" "${optionDisplayLevel}"
          updateArgListDisplayLevelCallback "${options_parse_arg}" "${optionDisplayLevel}"
          ;;
        -*)
          if [[ "${argOptDefaultBehavior}" = "0" ]]; then
            Log::displayError "Command ${SCRIPT_NAME} - Invalid option ${options_parse_arg}"
            return 1
          fi
          ;;
        *)
          if [[ "${argOptDefaultBehavior}" = "0" ]]; then
            Log::displayError "Command ${SCRIPT_NAME} - Argument - too much arguments provided"
            return 1
          fi
          ;;
      esac
      shift || true
    done
    commandOptionParseFinished
    InstallScripts::command
    Log::displayDebug "Command ${SCRIPT_NAME} - parse arguments: ${BASH_FRAMEWORK_ARGV[*]}"
    Log::displayDebug "Command ${SCRIPT_NAME} - parse filtered arguments: ${BASH_FRAMEWORK_ARGV_FILTERED[*]}"
  elif [[ "${options_parse_cmd}" = "help" ]]; then
    Array::wrap2 ' ' 80 0 "\e[1;37mDESCRIPTION:\e[0m" "$(helpDescriptionCallback)"
    echo

    echo -e "$(Array::wrap2 " " 80 2 "${__HELP_TITLE_COLOR}USAGE:${__RESET_COLOR}" "${SCRIPT_NAME}" "[OPTIONS]")"
    echo -e "$(Array::wrap2 " " 80 2 "${__HELP_TITLE_COLOR}USAGE:${__RESET_COLOR}" \
      "${SCRIPT_NAME}" \
      "[--skip-config|--skip-configure|--skip-configuration]" "[--skip-install|--skip-installation]" "[--skip-test|--skip-tests]" "[--skip-dependencies|--skip-deps]" "[--bash-framework-config <String>]" "[--config]" "[--verbose|-v]" "[-vv]" "[-vvv]" "[--env-file <String>]" "[--no-color]" "[--theme <String>]" "[--help|-h]" "[--version]" "[--quiet|-q]" "[--log-level <String>]" "[--log-file <String>]" "[--display-level <String>]")"
    echo
    echo -e "${__HELP_TITLE_COLOR}OPTIONS:${__RESET_COLOR}"
    echo -e "  ${__HELP_OPTION_COLOR}--skip-config${__HELP_NORMAL}, ${__HELP_OPTION_COLOR}--skip-configure${__HELP_NORMAL}, ${__HELP_OPTION_COLOR}--skip-configuration${__HELP_NORMAL} {single}"
    local -a helpArray
    # shellcheck disable=SC2054
    helpArray=(skip\ software\ configuration)
    echo -e "    $(Array::wrap2 " " 76 4 "${helpArray[@]}")"
    echo -e "  ${__HELP_OPTION_COLOR}--skip-install${__HELP_NORMAL}, ${__HELP_OPTION_COLOR}--skip-installation${__HELP_NORMAL} {single}"
    local -a helpArray
    # shellcheck disable=SC2054
    helpArray=(skip\ software\ installation)
    echo -e "    $(Array::wrap2 " " 76 4 "${helpArray[@]}")"
    echo -e "  ${__HELP_OPTION_COLOR}--skip-test${__HELP_NORMAL}, ${__HELP_OPTION_COLOR}--skip-tests${__HELP_NORMAL} {single}"
    local -a helpArray
    # shellcheck disable=SC2054
    helpArray=(skip\ software\ installation\ test)
    echo -e "    $(Array::wrap2 " " 76 4 "${helpArray[@]}")"
    echo -e "  ${__HELP_OPTION_COLOR}--skip-dependencies${__HELP_NORMAL}, ${__HELP_OPTION_COLOR}--skip-deps${__HELP_NORMAL} {single}"
    local -a helpArray
    # shellcheck disable=SC2054
    helpArray=(install\ the\ software\ requested\ without\ resolving\ dependencies)
    echo -e "    $(Array::wrap2 " " 76 4 "${helpArray[@]}")"
    echo
    echo -e "${__HELP_TITLE_COLOR}GLOBAL OPTIONS:${__RESET_COLOR}"
    echo -e "  ${__HELP_OPTION_COLOR}--bash-framework-config <String>${__HELP_NORMAL} {single}"
    local -a helpArray
    # shellcheck disable=SC2054
    helpArray=(use\ alternate\ bash\ framework\ configuration.)
    echo -e "    $(Array::wrap2 " " 76 4 "${helpArray[@]}")"
    echo -e "  ${__HELP_OPTION_COLOR}--config${__HELP_NORMAL} {single}"
    local -a helpArray
    # shellcheck disable=SC2054
    helpArray=(Display\ configuration)
    echo -e "    $(Array::wrap2 " " 76 4 "${helpArray[@]}")"
    echo -e "  ${__HELP_OPTION_COLOR}--verbose${__HELP_NORMAL}, ${__HELP_OPTION_COLOR}-v${__HELP_NORMAL} {single}"
    local -a helpArray
    # shellcheck disable=SC2054
    helpArray=(info\ level\ verbose\ mode\ \(alias\ of\ --display-level\ INFO\))
    echo -e "    $(Array::wrap2 " " 76 4 "${helpArray[@]}")"
    echo -e "  ${__HELP_OPTION_COLOR}-vv${__HELP_NORMAL} {single}"
    local -a helpArray
    # shellcheck disable=SC2054
    helpArray=(debug\ level\ verbose\ mode\ \(alias\ of\ --display-level\ DEBUG\))
    echo -e "    $(Array::wrap2 " " 76 4 "${helpArray[@]}")"
    echo -e "  ${__HELP_OPTION_COLOR}-vvv${__HELP_NORMAL} {single}"
    local -a helpArray
    # shellcheck disable=SC2054
    helpArray=(trace\ level\ verbose\ mode\ \(alias\ of\ --display-level\ TRACE\))
    echo -e "    $(Array::wrap2 " " 76 4 "${helpArray[@]}")"
    echo -e "  ${__HELP_OPTION_COLOR}--env-file <String>${__HELP_NORMAL} {list} (optional)"
    local -a helpArray
    # shellcheck disable=SC2054
    helpArray=(Load\ the\ specified\ env\ file\ \(deprecated\,\ please\ use\ --bash-framework-config\ option\ instead\))
    echo -e "    $(Array::wrap2 " " 76 4 "${helpArray[@]}")"
    echo -e "  ${__HELP_OPTION_COLOR}--no-color${__HELP_NORMAL} {single}"
    local -a helpArray
    # shellcheck disable=SC2054
    helpArray=(Produce\ monochrome\ output.\ alias\ of\ --theme\ noColor.)
    echo -e "    $(Array::wrap2 " " 76 4 "${helpArray[@]}")"
    echo -e "  ${__HELP_OPTION_COLOR}--theme <String>${__HELP_NORMAL} {single}"
    local -a helpArray
    # shellcheck disable=SC2054
    helpArray=(choose\ color\ theme\ -\ default-force\ means\ colors\ will\ be\ produced\ even\ if\ command\ is\ piped)
    echo -e "    $(Array::wrap2 " " 76 4 "${helpArray[@]}")"
    echo '    Default value: default'
    echo '    Possible values: default|default-force|noColor'
    echo -e "  ${__HELP_OPTION_COLOR}--help${__HELP_NORMAL}, ${__HELP_OPTION_COLOR}-h${__HELP_NORMAL} {single}"
    local -a helpArray
    # shellcheck disable=SC2054
    helpArray=(Display\ this\ command\ help)
    echo -e "    $(Array::wrap2 " " 76 4 "${helpArray[@]}")"
    echo -e "  ${__HELP_OPTION_COLOR}--version${__HELP_NORMAL} {single}"
    local -a helpArray
    # shellcheck disable=SC2054
    helpArray=(Print\ version\ information\ and\ quit)
    echo -e "    $(Array::wrap2 " " 76 4 "${helpArray[@]}")"
    echo -e "  ${__HELP_OPTION_COLOR}--quiet${__HELP_NORMAL}, ${__HELP_OPTION_COLOR}-q${__HELP_NORMAL} {single}"
    local -a helpArray
    # shellcheck disable=SC2054
    helpArray=(quiet\ mode\,\ doesn\'t\ display\ any\ output)
    echo -e "    $(Array::wrap2 " " 76 4 "${helpArray[@]}")"
    echo -e "  ${__HELP_OPTION_COLOR}--log-level <String>${__HELP_NORMAL} {single}"
    local -a helpArray
    # shellcheck disable=SC2054
    helpArray=(Set\ log\ level)
    echo -e "    $(Array::wrap2 " " 76 4 "${helpArray[@]}")"
    echo '    Possible values: OFF|ERR|ERROR|WARN|WARNING|INFO|DEBUG|TRACE'
    echo -e "  ${__HELP_OPTION_COLOR}--log-file <String>${__HELP_NORMAL} {single}"
    local -a helpArray
    # shellcheck disable=SC2054
    helpArray=(Set\ log\ file)
    echo -e "    $(Array::wrap2 " " 76 4 "${helpArray[@]}")"
    echo -e "  ${__HELP_OPTION_COLOR}--display-level <String>${__HELP_NORMAL} {single}"
    local -a helpArray
    # shellcheck disable=SC2054
    helpArray=(set\ display\ level)
    echo -e "    $(Array::wrap2 " " 76 4 "${helpArray[@]}")"
    echo '    Possible values: OFF|ERR|ERROR|WARN|WARNING|INFO|DEBUG|TRACE'
    Array::wrap2 ' ' 76 0 "$(helpLongDescriptionCallback)"
    echo
    echo -n -e "${__HELP_TITLE_COLOR}VERSION: ${__RESET_COLOR}"
    echo '1.0'
    echo
    echo -e "${__HELP_TITLE_COLOR}AUTHOR:${__RESET_COLOR}"
    echo '[Franois Chastanet](https://github.com/fchastanet)'
    echo
    echo -e "${__HELP_TITLE_COLOR}SOURCE FILE:${__RESET_COLOR}"
    echo 'https://github.com/fchastanet/bash-dev-env/tree/master/src/_binaries/ShellZsh/ShellZsh.sh'
    echo
    echo -e "${__HELP_TITLE_COLOR}LICENSE:${__RESET_COLOR}"
    echo 'MIT License'
    echo
    Array::wrap2 ' ' 76 4 "$(copyrightCallback)"
  else
    Log::displayError "Command ${SCRIPT_NAME} - Option command invalid: '${options_parse_cmd}'"
    return 1
  fi
}

# default action called by the facade if no interface action recognized
defaultFacadeAction() {
  installScriptCommand parse "${BASH_FRAMEWORK_ARGV[@]}"
}

stringOrNone() {
  local string="$1"
  echo -e "${string:-${__HELP_EXAMPLE}None${__HELP_NORMAL}}"
}

helpDescriptionCallback() {
  helpDescription
  echo
}

helpLongDescriptionCallback() {
  helpDescription
  echo

  echo -e "${__HELP_TITLE}List of needed variables:${__HELP_NORMAL}"
  stringOrNone "$(helpVariables)"

  echo -e "${__HELP_TITLE}List of dependencies:${__HELP_NORMAL}"
  stringOrNone "$(dependencies)"
}

isInstallImplemented() {
  ! InstallScripts::scriptFunctionEmpty install
}

isTestInstallImplemented() {
  ! InstallScripts::scriptFunctionEmpty testInstall
}

isConfigureImplemented() {
  ! InstallScripts::scriptFunctionEmpty configure
}

isTestConfigureImplemented() {
  ! InstallScripts::scriptFunctionEmpty testConfigure
}

scriptName() {
  echo "ShellZsh"
}

helpDescription() {
  echo "Default Zsh configuration"
}

dependencies() {
  echo ShellBash
}

listVariables() {
  echo "HOME"
  echo "USERNAME"
  echo "USERGROUP"
}

fortunes() {
  if [[ "${USER_SHELL}" = "/usr/bin/zsh" ]]; then
    echo "$(scriptName) - Zsh ref card manual <http://www.bash2zsh.com/zsh_refcard/refcard.pdf>"
    echo "%"
    if [[ "${ZSH_PREFERRED_THEME:-${ZSH_DEFAULT_THEME}}" != "powerlevel10k/powerlevel10k" ]]; then
      echo "$(scriptName) - Powerlevel10k - use this command 'p10k configure' to customize shell prompt"
      echo "%"
    fi
  else
    if command -v zsh &>/dev/null; then
      echo "$(scriptName) - ${USER_SHELL} is set as default shell, you can switch to zsh using 'chsh -s /usr/bin/zsh'"
      echo "%"
    else
      echo "$(scriptName) - Zsh is not set as your default shell, you can give it a try using 'installAndConfigure ZshProfile'"
      echo "%"
    fi
  fi
}

# jscpd:ignore-start
helpVariables() { :; }
defaultVariables() { :; }
checkVariables() { :; }
breakOnConfigFailure() { :; }
breakOnTestFailure() { :; }
# jscpd:ignore-end

install() {
  Linux::Apt::installIfNecessary --no-install-recommends \
    zsh

  Log::displayInfo "install plugin manager"
  if command -v zinit &>/dev/null; then
    zinit self-update
    zinit update --all --parallel
  else
    bash -c "$(
      NO_EDIT=1 NO_INPUT=1 curl \
        --fail --show-error --silent \
        --location https://raw.githubusercontent.com/zdharma-continuum/zinit/HEAD/scripts/install.sh
    )"
  fi
}

assertZshFunctionExists() {
  local functionName="$1"
  zsh -i -c "typeset -f '${functionName}' &>/dev/null" || {
    Log::displayError "Zsh function ${functionName} does not exist"
    return 1
  }
}

testInstall() {
  local -i failures=0
  Assert::commandExists zsh || ((++failures))
  assertZshFunctionExists zinit || ((++failures))
  return "${failures}"
}

configure() {
  if [[ "${PREFERRED_SHELL}" = "ShellZsh" ]]; then
    if [[ "${USER_SHELL}" != "/usr/bin/zsh" ]]; then
      sudo usermod --shell /usr/bin/zsh "${USERNAME}"
      USER_SHELL="/usr/bin/zsh"
      Log::displayHelp "You have to log in/log out to make zsh by default"
    fi
    Log::displayHelp "Zsh is set as default shell, you can switch back to bash using 'chsh -s /usr/bin/bash'"
  fi
  # shellcheck disable=SC2154
  Conf::copyStructure \
    "${embed_dir_conf_dir}" \
    "${CONF_OVERRIDE_DIR}/$(scriptName)" \
    ".bash-dev-env"

  Conf::copyStructure \
    "${embed_dir_conf_dir}" \
    "${CONF_OVERRIDE_DIR}/$(scriptName)" \
    "home" \
    "${HOME}"

  # shellcheck disable=SC2154
  OVERWRITE_CONFIG_FILES=1 Install::file \
    "${embed_file_loadConfigFiles}" \
    "${HOME}/.bash-dev-env/loadConfigFiles"
}

declare -a confFiles=(
  "${HOME}/.bash-dev-env/interactive.d/zsh-autosuggestions.zsh"
  "${HOME}/.bash-dev-env/interactive.d/zsh-beep.zsh"
  "${HOME}/.bash-dev-env/interactive.d/zsh-history.zsh"
  "${HOME}/.bash-dev-env/interactive.d/zsh-ls-colors.zsh"
  "${HOME}/.bash-dev-env/interactive.d/zsh-ssh.zsh"
  "${HOME}/.bash-dev-env/interactive.d/zsh-syntax-highlighting.zsh"
  "${HOME}/.bash-dev-env/interactive.d/zsh-z.zsh"
  "${HOME}/.bash-dev-env/themes.d/powerlevel10k.zsh"
  "${HOME}/.bash-dev-env/themes.d/pure.zsh"
  "${HOME}/.bash-dev-env/themes.d/starship.zsh"
  "${HOME}/.bash-dev-env/loadConfigFiles"
  "${HOME}/.zshrc"
  "${HOME}/.zprofile"
  "${HOME}/.p10k.zsh"
)
testConfigure() {
  local -i failures=0
  local file
  for file in "${confFiles[@]}"; do
    Assert::fileExists "${file}" || ((++failures))
  done
  Log::displayInfo "Try to load .zshrc"
  (zsh -i -c 'echo "Hello Zsh"' || exit 1) || {
    Log::displayError "something goes bad while loading ~/.zshrc"
    ((++failures))
  }

  return "${failures}"
}

local action=$1
shift || true
case ${action} in
  scriptName)
    scriptName "$@"
    ;;
  helpDescription)
    helpDescription "$@"
    ;;
  helpVariables)
    helpVariables "$@"
    ;;
  listVariables)
    listVariables "$@"
    ;;
  defaultVariables)
    defaultVariables "$@"
    ;;
  checkVariables)
    checkVariables "$@"
    ;;
  fortunes)
    fortunes "$@"
    ;;
  dependencies)
    dependencies "$@"
    ;;
  breakOnTestFailure)
    breakOnTestFailure "$@"
    ;;
  breakOnConfigFailure)
    breakOnConfigFailure "$@"
    ;;
  install)
    install "$@"
    ;;
  isInstallImplemented)
    isInstallImplemented "$@"
    ;;
  testInstall)
    testInstall "$@"
    ;;
  isTestInstallImplemented)
    isTestInstallImplemented "$@"
    ;;
  configure)
    configure "$@"
    ;;
  isConfigureImplemented)
    isConfigureImplemented "$@"
    ;;
  testConfigure)
    testConfigure "$@"
    ;;
  isTestConfigureImplemented)
    isTestConfigureImplemented "$@"
    ;;
  *)
    if Assert::functionExists defaultFacadeAction; then
      defaultFacadeAction "$1" "$@"
    else
      Log::displayError "invalid action requested: ${action}"
      exit 1
    fi
    ;;
esac
exit 0
}

facade_main_ShellZshsh "$@"
