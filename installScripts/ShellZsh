#!/usr/bin/env bash
###############################################################################
# GENERATED FACADE FROM https://github.com/fchastanet/bash-dev-env/tree/master/src/_binaries/ShellZsh/ShellZsh.sh
# DO NOT EDIT IT
# @generated
###############################################################################
# shellcheck disable=SC2288,SC2034
# BIN_FILE=${BASH_DEV_ENV_ROOT_DIR}/installScripts/ShellZsh

# ensure that no user aliases could interfere with
# commands used in this script
unalias -a || true
shopt -u expand_aliases

# shellcheck disable=SC2034
((failures = 0)) || true

# Bash will remember & return the highest exit code in a chain of pipes.
# This way you can catch the error inside pipes, e.g. mysqldump | gzip
set -o pipefail
set -o errexit

# Command Substitution can inherit errexit option since bash v4.4
shopt -s inherit_errexit || true

# if set, and job control is not active, the shell runs the last command
# of a pipeline not executed in the background in the current shell
# environment.
shopt -s lastpipe

# a log is generated when a command fails
set -o errtrace

# use nullglob so that (file*.php) will return an empty array if no file
# matches the wildcard
shopt -s nullglob

# ensure regexp are interpreted without accentuated characters
export LC_ALL=POSIX

export TERM=xterm-256color

# avoid interactive install
export DEBIAN_FRONTEND=noninteractive
export DEBCONF_NONINTERACTIVE_SEEN=true

# store command arguments for later usage
# shellcheck disable=SC2034
declare -a BASH_FRAMEWORK_ARGV=("$@")
# shellcheck disable=SC2034
declare -a ORIGINAL_BASH_FRAMEWORK_ARGV=("$@")

# @see https://unix.stackexchange.com/a/386856
# shellcheck disable=SC2317
interruptManagement() {
  # restore SIGINT handler
  trap - INT
  # ensure that Ctrl-C is trapped by this script and not by sub process
  # report to the parent that we have indeed been interrupted
  kill -s INT "$$"
}
trap interruptManagement INT
SCRIPT_NAME=${0##*/}
REAL_SCRIPT_FILE="$(readlink -e "$(realpath "${BASH_SOURCE[0]}")")"
if [[ -n "${EMBED_CURRENT_DIR}" ]]; then
  CURRENT_DIR="${EMBED_CURRENT_DIR}"
else
  CURRENT_DIR="${REAL_SCRIPT_FILE%/*}"
fi

################################################
# Temp dir management
################################################

KEEP_TEMP_FILES="${KEEP_TEMP_FILES:-0}"
export KEEP_TEMP_FILES

# PERSISTENT_TMPDIR is not deleted by traps
PERSISTENT_TMPDIR="${TMPDIR:-/tmp}/bash-framework"
export PERSISTENT_TMPDIR
if [[ ! -d "${PERSISTENT_TMPDIR}" ]]; then
  mkdir -p "${PERSISTENT_TMPDIR}"
fi

# shellcheck disable=SC2034
TMPDIR="$(mktemp -d -p "${PERSISTENT_TMPDIR:-/tmp}" -t bash-framework-$$-XXXXXX)"
export TMPDIR

# temp dir cleaning
# shellcheck disable=SC2317
cleanOnExit() {
  local rc=$?
  if [[ "${KEEP_TEMP_FILES:-0}" = "1" ]]; then
    Log::displayInfo "KEEP_TEMP_FILES=1 temp files kept here '${TMPDIR}'"
  elif [[ -n "${TMPDIR+xxx}" ]]; then
    Log::displayDebug "KEEP_TEMP_FILES=0 removing temp files '${TMPDIR}'"
    rm -Rf "${TMPDIR:-/tmp/fake}" >/dev/null 2>&1
  fi
  exit "${rc}"
}
trap cleanOnExit EXIT HUP QUIT ABRT TERM

# @description Log namespace provides 2 kind of functions
# - Log::display* allows to display given message with
#   given display level
# - Log::log* allows to log given message with
#   given log level
# Log::display* functions automatically log the message too
# @see Env::requireLoad to load the display and log level from .env file

# @description log level off
export __LEVEL_OFF=0
# @description log level error
export __LEVEL_ERROR=1
# @description log level warning
export __LEVEL_WARNING=2
# @description log level info
export __LEVEL_INFO=3
# @description log level success
export __LEVEL_SUCCESS=3
# @description log level debug
export __LEVEL_DEBUG=4

# @description verbose level off
export __VERBOSE_LEVEL_OFF=0
# @description verbose level info
export __VERBOSE_LEVEL_INFO=1
# @description verbose level info
export __VERBOSE_LEVEL_DEBUG=2
# @description verbose level info
export __VERBOSE_LEVEL_TRACE=3

# @description Display message using info color (bg light blue/fg white)
# @arg $1 message:String the message to display
# @env DISPLAY_DURATION int (default 0) if 1 display elapsed time information between 2 info logs
Log::displayInfo() {
  local type="${2:-INFO}"
  if ((BASH_FRAMEWORK_DISPLAY_LEVEL >= __LEVEL_INFO)); then
    Log::computeDuration
    echo -e "${__INFO_COLOR}${type}    - ${LOG_CONTEXT:-}${LOG_LAST_DURATION_STR:-}${1}${__RESET_COLOR}" >&2
  fi
  Log::logInfo "$1" "${type}"
}

# @description Display message using debug color (grey)
# @arg $1 message:String the message to display
Log::displayDebug() {
  if ((BASH_FRAMEWORK_DISPLAY_LEVEL >= __LEVEL_DEBUG)); then
    Log::computeDuration
    echo -e "${__DEBUG_COLOR}DEBUG   - ${LOG_CONTEXT:-}${LOG_LAST_DURATION_STR:-}${1}${__RESET_COLOR}" >&2
  fi
  Log::logDebug "$1"
}

# @description convert base64 encoded back to target dir
# it is advised to include the md5sum of the binFile in the path of the target dir
#
# @arg $1 targetDir:string the directory in which tar archive will be untarred
# @arg $2 base64:string the base64 encoded tar czf archive
# @stderr diagnostics information is displayed
# @require Linux::requireTarCommand
Compiler::Embed::extractDirFromBase64() {
  local targetDir="$1"
  local base64="$2"

  if [[ ! -d "${targetDir}" ]]; then
    mkdir -p "${targetDir}"
    (
      cd "${targetDir}" || exit 1
      base64 -d <<<"${base64}" | tar -xzf - 2>/dev/null || {
        Log::displayError "untar failure, invalid base64 string"
        exit 1
      }
    ) || return 1
  fi
}

# @description convert base64 encoded back to target file
# if target file is executable prepend dir of target
# file to PATH to make binary available everywhere
# it is advised to include in the path of the target file
# the md5sum of the binFile
#
# @arg $1 targetFile:String the file to write
# @arg $2 binFileBase64:String the base64 encoded file
# @arg $3 fileMode:String the chmod to set on the file
# @set PATH String prepend target embedded file binary directory to PATH variable if binary executable
Compiler::Embed::extractFileFromBase64() {
  local targetFile="$1"
  local binFileBase64="$2"
  local fileMode="${3:-+x}"
  local targetDir="${targetFile%/*}"

  if [[ ! -f "${targetFile}" ]]; then
    if [[ ! -d "${targetDir}" ]]; then
      mkdir -p "${targetDir}"
    fi
    base64 -d >"${targetFile}" <<<"${binFileBase64}"
    chmod "${fileMode}" "${targetFile}"
  fi

  if [[ -x "${targetFile}" ]]; then
    Env::pathPrepend "${targetDir}"
  fi
}

# @description checks if function name provided exists
# @arg $1 functionName:String
# @exitcode 1 if function name doesn't exist
Assert::functionExists() {
  declare -F "$1" >/dev/null
}

envFileTemplate="$(
  cat <<'EOF'
# shellcheck disable=SC2034

# -----------------------------------------------------------------------------
# General information
# -----------------------------------------------------------------------------

# wsl username with default password wsl
USERNAME="wsl"

HOME="/home/wsl"

WINDOWS_USERNAME="fchastanet"

# -----------------------------------------------------------------------------
# Git & SSH information
# -----------------------------------------------------------------------------

# if 1, it indicates you accept that your git key will be loaded.
# if 0, configurations that need to be authenticated will be skipped.
# Distro mode: in any case, your key is not copied.
AUTHORIZE_SSH_KEY_USAGE=1

# your login to connect to ssh servers if any
SSH_LOGIN=""

# your git full name 'FirstName LastName'
GIT_USERNAME=""

# email used for git 'ldap@domain.com'
GIT_USER_MAIL=""

# -----------------------------------------------------------------------------
# AWS information
# -----------------------------------------------------------------------------

# email used to connect to aws
AWS_USER_MAIL="fchastanet@gmail.com"

# app id to connect to aws account
AWS_APP_ID=""

AWS_PROFILE=""
AWS_DEFAULT_REGION=""
AWS_TEST_SECRET_ID=""
AWS_DEFAULT_DOCKER_REGISTRY_ID=""

# -----------------------------------------------------------------------------
# K8S information
# -----------------------------------------------------------------------------

# KubeDefaultConfig ~/.kube/config generation
# aws region of the cluster (Eg: us-east-1)
KUBE_CONFIG_REGION_CODE=

# aws arn of the cluster.
# Eg: arn:aws:ecs:region:aws_account_id:cluster/MyCluster
KUBE_CONFIG_CLUSTER_ARN=

# -----------------------------------------------------------------------------
# Directories
# -----------------------------------------------------------------------------

# overridden conf directory that will be used to override
# the default configuration that are embedded in binaries
CONF_OVERRIDE_DIR="${BASH_DEV_ENV_ROOT_DIR}/conf.override"

# where to install bash-tools, ...
# shellcheck disable=SC2153
PROJECTS_DIR="${HOME}/projects"

# where overridden config files will be backed up
BACKUP_DIR="${BASH_DEV_ENV_ROOT_DIR}/backup"
# backup files/dirs before installing new file (usually 1, but 0 if using distro)
BACKUP_BEFORE_INSTALL=1

# logs directory
LOGS_DIR="${BASH_DEV_ENV_ROOT_DIR}/logs"

# installScripts root dir
INSTALL_SCRIPTS_ROOT_DIR="${BASH_DEV_ENV_ROOT_DIR}"

# -----------------------------------------------------------------------------
# Installation configuration
# -----------------------------------------------------------------------------

# Configuration files are overwritten even if exists
# !!!! First time initialization: let this value to 1 !!!!
# Value 0:
# - If target configuration file exists, displays a message and do not overwrite the file
# - If target configuration file doesn't exist, installs the file
# Value 1
# - install or overwrite the file without checking existence
OVERWRITE_CONFIG_FILES=1

# Windows files can be overridden if 1
# if 0
# - skip changes to %USERPROFILE%/.wslconfig
# - skip copying fonts
CHANGE_WINDOWS_FILES=1

# Indicate that install script can warn you using speaker when your input is needed
CAN_TALK_DURING_INSTALLATION=1

# if 0 install script will skip all interactive activity (saml2aws, ...),
# so dependent installation will be skipped as well
INSTALL_INTERACTIVE=1

# display elapsed time since last log
DISPLAY_DURATION=1

# 0   => no upgrade at all
# lts => UPGRADE to latest ubuntu lts version
# dev => UPGRADE to latest ubuntu dev version
# Use if you know what you are doing,
# could cause some packages to not being available yet
UPGRADE_UBUNTU_VERSION=0

# -----------------------------------------------------------------------------
# Profile configuration
# -----------------------------------------------------------------------------

# Choose your preferred shell
# possible choices: ShellBash (Legacy experience), ShellZsh (Recommended experience)
PREFERRED_SHELL="ShellZsh"

# Zsh theme to use
# possible choices: powerlevel10k/powerlevel10k, sindresorhus/pure, starship/starship
ZSH_PREFERRED_THEME="powerlevel10k/powerlevel10k"

# Display Fortune tooltip at bash/zsh session open
SHOW_FORTUNES=1

# Display MOTD at bash/zsh session open
SHOW_MOTD=1

# -----------------------------------------------------------------------------
# WSLCONFIG
# These parameters automatically configure %USERPROFILE%/.wslconfig file.
# @see https://docs.microsoft.com/en-us/windows/wsl/wsl-config
# -----------------------------------------------------------------------------

# Recommended 50% of total memory
WSLCONFIG_MAX_MEMORY=8GB

# personally I prefer run out of memory instead of beginning swapping
# So I know immediately if some processes have to be stopped
WSLCONFIG_SWAP=0

# -----------------------------------------------------------------------------
# Hacks
# on some configurations we have to force path of some windows commands
# -----------------------------------------------------------------------------

#POWERSHELL_BIN=/mnt/c/Windows/System32/WindowsPowerShell/v1.0/powershell.exe
#IPCONFIG_BIN=/mnt/c/Windows/system32/ipconfig.exe
#WSL_EXE_BIN=/mnt/c/Windows/system32/wsl.exe

# -----------------------------------------------------------------------------
# General distribution information
# -----------------------------------------------------------------------------

# hostname of the distro
DISTRO_HOSTNAME="wslHost"
EOF
)"

# @description load .env file
# @arg $1 envFile:String the file to load
Engine::Config::loadConfig() {
  if [[ "${BASH_DEV_ENV_CONFIG_LOADED:-0}" = "1" ]]; then
    return 0
  fi
  local envFile="${BASH_DEV_ENV_ROOT_DIR}/.env"
  Engine::Config::createEnvFileFromTemplate \
    "${envFile}" "${envFileTemplate}" || exit 1
  set -o allexport
  # shellcheck source=/.env.template
  source <(echo "${envFileTemplate}")
  # shellcheck source=/.env
  source "${BASH_DEV_ENV_ROOT_DIR}/.env"
  set +o allexport
  export STATS_DIR="${LOGS_DIR}/stats"
  if [[ ! -d "${STATS_DIR}" ]]; then
    mkdir -p "${STATS_DIR}" || true
  fi
  export LOGS_INSTALL_SCRIPTS_DIR="${LOGS_DIR}/installScripts"
  if [[ ! -d "${LOGS_INSTALL_SCRIPTS_DIR}" ]]; then
    mkdir -p "${LOGS_INSTALL_SCRIPTS_DIR}" || true
  fi

  # load environment variables ID, VERSION_CODENAME
  Engine::Config::loadOsRelease
  Engine::Config::loadUserVariables

  if ! Engine::Config::checkEnv "${BASH_DEV_ENV_ROOT_DIR}/.env"; then
    Log::displayError "one or more variables are invalid, check above logs and fix '${envFile}' file accordingly"
    return 1
  fi

  Engine::Config::loadHostIp

  Engine::Config::requireWslu

  #Linux::Wsl::initEnv
  Engine::Config::loadWslVariables

  Log::requireLoad

  Engine::Config::loadSshKey

  Engine::Config::loadLocaleConfig

  export BASH_DEV_ENV_CONFIG_LOADED=1
}

# @description Display message using warning color (yellow)
# @arg $1 message:String the message to display
Log::displayWarning() {
  if ((BASH_FRAMEWORK_DISPLAY_LEVEL >= __LEVEL_WARNING)); then
    Log::computeDuration
    echo -e "${__WARNING_COLOR}WARN    - ${LOG_CONTEXT:-}${LOG_LAST_DURATION_STR:-}${1}${__RESET_COLOR}" >&2
  fi
  Log::logWarning "$1"
}

# @description Display message using error color (red)
# @arg $1 message:String the message to display
Log::displayError() {
  if ((BASH_FRAMEWORK_DISPLAY_LEVEL >= __LEVEL_ERROR)); then
    Log::computeDuration
    echo -e "${__ERROR_COLOR}ERROR   - ${LOG_CONTEXT:-}${LOG_LAST_DURATION_STR:-}${1}${__RESET_COLOR}" >&2
  fi
  Log::logError "$1"
}

# @description load colors theme constants
# @warning if tty not opened, noColor theme will be chosen
# @arg $1 theme:String the theme to use (default, noColor)
# @arg $@ args:String[]
# @set __ERROR_COLOR String indicate error status
# @set __INFO_COLOR String indicate info status
# @set __SUCCESS_COLOR String indicate success status
# @set __WARNING_COLOR String indicate warning status
# @set __SKIPPED_COLOR String indicate skipped status
# @set __DEBUG_COLOR String indicate debug status
# @set __HELP_COLOR String indicate help status
# @set __TEST_COLOR String not used
# @set __TEST_ERROR_COLOR String not used
# @set __HELP_TITLE_COLOR String used to display help title in help strings
# @set __HELP_OPTION_COLOR String used to display highlight options in help strings
#
# @set __RESET_COLOR String reset default color
#
# @set __HELP_EXAMPLE String to remove
# @set __HELP_TITLE String to remove
# @set __HELP_NORMAL String to remove
# shellcheck disable=SC2034
UI::theme() {
  local theme="${1-default}"
  if [[ ! "${theme}" =~ -force$ ]] && ! Assert::tty; then
    theme="noColor"
  fi
  case "${theme}" in
    default | default-force)
      theme="default"
      ;;
    noColor) ;;
    *)
      Log::fatal "invalid theme provided"
      ;;
  esac
  if [[ "${theme}" = "default" ]]; then
    BASH_FRAMEWORK_THEME="default"
    # check colors applicable https://misc.flogisoft.com/bash/tip_colors_and_formatting
    __ERROR_COLOR='\e[31m'         # Red
    __INFO_COLOR='\e[44m'          # white on lightBlue
    __SUCCESS_COLOR='\e[32m'       # Green
    __WARNING_COLOR='\e[33m'       # Yellow
    __SKIPPED_COLOR='\e[33m'       # Yellow
    __DEBUG_COLOR='\e[37m'         # Grey
    __HELP_COLOR='\e[7;49;33m'     # Black on Gold
    __TEST_COLOR='\e[100m'         # Light magenta
    __TEST_ERROR_COLOR='\e[41m'    # white on red
    __HELP_TITLE_COLOR="\e[1;37m"  # Bold
    __HELP_OPTION_COLOR="\e[1;34m" # Blue
    # Internal: reset color
    __RESET_COLOR='\e[0m' # Reset Color
    # shellcheck disable=SC2155,SC2034
    __HELP_EXAMPLE="$(echo -e "\e[2;97m")"
    # shellcheck disable=SC2155,SC2034
    __HELP_TITLE="$(echo -e "\e[1;37m")"
    # shellcheck disable=SC2155,SC2034
    __HELP_NORMAL="$(echo -e "\033[0m")"
  else
    BASH_FRAMEWORK_THEME="noColor"
    # check colors applicable https://misc.flogisoft.com/bash/tip_colors_and_formatting
    __ERROR_COLOR=''
    __INFO_COLOR=''
    __SUCCESS_COLOR=''
    __WARNING_COLOR=''
    __SKIPPED_COLOR=''
    __DEBUG_COLOR=''
    __HELP_COLOR=''
    __TEST_COLOR=''
    __TEST_ERROR_COLOR=''
    __HELP_TITLE_COLOR=''
    __HELP_OPTION_COLOR=''
    # Internal: reset color
    __RESET_COLOR=''
    __HELP_EXAMPLE=''
    __HELP_TITLE=''
    __HELP_NORMAL=''
  fi
}

# @description draw a line with the character passed in parameter repeated depending on terminal width
# @arg $1 character:String character to use as separator (default value #)
UI::drawLine() {
  local character="${1:-#}"
  printf -- "${character}%.0s" $(seq "${COLUMNS:-$([[ -t 0 ]] && tput cols || echo '80')}")
}

# @description Display message using error color (red) and exit immediately with error status 1
# @arg $1 message:String the message to display
Log::fatal() {
  Log::computeDuration
  echo -e "${__ERROR_COLOR}FATAL   - ${LOG_CONTEXT:-}${LOG_LAST_DURATION_STR:-}${1}${__RESET_COLOR}" >&2
  Log::logFatal "$1"
  exit 1
}

# @description create a temp file using default TMPDIR variable
# initialized in _includes/_commonHeader.sh
# @env TMPDIR String (default value /tmp)
# @arg $1 templateName:String template name to use(optional)
Framework::createTempFile() {
  mktemp -p "${TMPDIR:-/tmp}" -t "${1:-}.XXXXXXXXXXXX"
}

# @description ensure env files are loaded
# @arg $@ list of default files to load at the end
# @exitcode 1 if one of env files fails to load
# @stderr diagnostics information is displayed
# shellcheck disable=SC2120
Env::requireLoad() {
  local -a defaultFiles=("$@")
  # get list of possible config files
  local -a configFiles=()
  if [[ -n "${BASH_FRAMEWORK_ENV_FILES[0]+1}" ]]; then
    # BASH_FRAMEWORK_ENV_FILES is an array
    configFiles+=("${BASH_FRAMEWORK_ENV_FILES[@]}")
  fi
  local localFrameworkConfigFile
  localFrameworkConfigFile="$(pwd)/.framework-config"
  if [[ -f "${localFrameworkConfigFile}" ]]; then
    configFiles+=("${localFrameworkConfigFile}")
  fi
  if [[ -f "${FRAMEWORK_ROOT_DIR}/.framework-config" ]]; then
    configFiles+=("${FRAMEWORK_ROOT_DIR}/.framework-config")
  fi
  configFiles+=("${optionEnvFiles[@]}")
  configFiles+=("${defaultFiles[@]}")

  for file in "${configFiles[@]}"; do
    # shellcheck source=/.framework-config
    CURRENT_LOADED_ENV_FILE="${file}" source "${file}" || {
      Log::displayError "while loading config file: ${file}"
      return 1
    }
  done
}

# @description activate or not Log::display* and Log::log* functions
# based on BASH_FRAMEWORK_DISPLAY_LEVEL and BASH_FRAMEWORK_LOG_LEVEL
# environment variables loaded by Env::requireLoad
# try to create log file and rotate it if necessary
# @noargs
# @set BASH_FRAMEWORK_LOG_LEVEL int to OFF level if BASH_FRAMEWORK_LOG_FILE is empty or not writable
# @env BASH_FRAMEWORK_DISPLAY_LEVEL int
# @env BASH_FRAMEWORK_LOG_LEVEL int
# @env BASH_FRAMEWORK_LOG_FILE String
# @env BASH_FRAMEWORK_LOG_FILE_MAX_ROTATION int do log rotation if > 0
# @exitcode 0 always successful
# @stderr diagnostics information about log file is displayed
# @require Env::requireLoad
# @require UI::requireTheme
Log::requireLoad() {
  if [[ -z "${BASH_FRAMEWORK_LOG_FILE:-}" ]]; then
    BASH_FRAMEWORK_LOG_LEVEL=${__LEVEL_OFF}
    export BASH_FRAMEWORK_LOG_LEVEL
  fi

  if ((BASH_FRAMEWORK_LOG_LEVEL > __LEVEL_OFF)); then
    if [[ ! -f "${BASH_FRAMEWORK_LOG_FILE}" ]]; then
      if [[ ! -d "${BASH_FRAMEWORK_LOG_FILE%/*}" ]]; then
        if ! mkdir -p "${BASH_FRAMEWORK_LOG_FILE%/*}" 2>/dev/null; then
          BASH_FRAMEWORK_LOG_LEVEL=${__LEVEL_OFF}
          echo -e "${__ERROR_COLOR}ERROR   - directory ${BASH_FRAMEWORK_LOG_FILE%/*} is not writable${__RESET_COLOR}" >&2
        fi
      elif ! touch --no-create "${BASH_FRAMEWORK_LOG_FILE}" 2>/dev/null; then
        BASH_FRAMEWORK_LOG_LEVEL=${__LEVEL_OFF}
        echo -e "${__ERROR_COLOR}ERROR   - File ${BASH_FRAMEWORK_LOG_FILE} is not writable${__RESET_COLOR}" >&2
      fi
    elif [[ ! -w "${BASH_FRAMEWORK_LOG_FILE}" ]]; then
      BASH_FRAMEWORK_LOG_LEVEL=${__LEVEL_OFF}
      echo -e "${__ERROR_COLOR}ERROR   - File ${BASH_FRAMEWORK_LOG_FILE} is not writable${__RESET_COLOR}" >&2
    fi
  fi

  if ((BASH_FRAMEWORK_LOG_LEVEL > __LEVEL_OFF)); then
    # will always be created even if not in info level
    Log::logMessage "INFO" "Logging to file ${BASH_FRAMEWORK_LOG_FILE} - Log level ${BASH_FRAMEWORK_LOG_LEVEL}"
    if ((BASH_FRAMEWORK_LOG_FILE_MAX_ROTATION > 0)); then
      Log::rotate "${BASH_FRAMEWORK_LOG_FILE}" "${BASH_FRAMEWORK_LOG_FILE_MAX_ROTATION}"
    fi
  fi
}

# @description the command launch different actions(install, configure, test)
# depending on the options selected
# @see src/_includes/install.skip.options.tpl
# @env SKIP_INSTALL
# @env SKIP_CONFIGURE
# @env SKIP_TEST
# @env STATS_DIR
# @env LOGS_INSTALL_SCRIPTS_DIR
InstallScripts::command() {
  local logsDir="${LOGS_INSTALL_SCRIPTS_DIR:-#}"
  local statsDir="${STATS_DIR:-#}"
  local fullScriptName
  fullScriptName="$(fullScriptName)"
  local scriptName="${fullScriptName//\//@}"
  rm -f "${statsDir}/${scriptName}-"* || true

  # shellcheck disable=SC2317
  onInterrupt() {
    Log::displayError "${scriptName} aborted"
    exit 1
  }
  trap onInterrupt INT TERM ABRT

  local startDate logFile statsFile
  local installStatus="0"
  sourceHook() {
    local hookName="$1"
    # shellcheck disable=SC2154
    hook="$(IGNORE_ERROR=1 Conf::dynamicConfFile "${scriptName}/${hookName}.sh" "${embed_dir_hooks_dir}/${hookName}.sh")"
    if [[ -n "${hook}" && -f "${hook}" && -x "${hook}" ]]; then
      # shellcheck source=src/_binaries/SimpleTest/hooks/preInstall.sh
      source "${hook}" || {
        Log::displayError "${scriptName} - unable to load hook '${hook}'"
        exit 1
      }
    fi
  }
  local globalStatsFile="${statsDir}/${scriptName}-global.stat"
  local hook
  if [[ "${SKIP_INSTALL}" = "0" ]] && ! InstallScripts::scriptFunctionEmpty install; then
    LOG_CONTEXT="${scriptName} - " Log::headLine "INSTALL" "Installing ${scriptName}"
    logFile="${logsDir}/${scriptName}-install.log"
    statsFile="${statsDir}/${scriptName}-install.stat"

    # break at first install error
    (
      startDate="$(date +%s)"
      # shellcheck disable=SC2317
      computeStats() {
        local rc=$1
        LOG_CONTEXT="${scriptName} - " Stats::statusLine "${statsFile}" "Installation"
        Stats::computeFromLog \
          "${logFile}" "${rc}" "${statsFile}" "${startDate}"
        Stats::aggregateGlobalStats \
          "${globalStatsFile}" "1" "${statsFile}"
        exit "${rc}"
      }
      trap 'computeStats "$?"' EXIT INT TERM ABRT

      local -i failures=0
      sourceHook preInstall || ((++failures))
      install || ((++failures))
      sourceHook postInstall || ((++failures))
      exit "${failures}"
    ) 2>&1 | tee "${logFile}"
  fi

  local testInstallStatus="0"
  if [[ "${SKIP_TEST}" = "0" && "${installStatus}" = "0" ]] &&
    ! InstallScripts::scriptFunctionEmpty testInstall; then
    Log::headLine "TEST" "Testing ${scriptName} installation"
    logFile="${logsDir}/${scriptName}-test-install.log"
    statsFile="${statsDir}/${scriptName}-test-install.stat"
    (
      startDate="$(date +%s)"
      # shellcheck disable=SC2317
      computeStats() {
        local rc=$1
        Stats::statusLine "${statsFile}" "Test Install ${scriptName}"
        Stats::computeFromLog \
          "${logFile}" "${rc}" "${statsFile}" "${startDate}"
        Stats::aggregateGlobalStats \
          "${globalStatsFile}" "1" "${statsFile}"
        exit "${rc}"
      }
      trap 'computeStats "$?"' EXIT INT TERM ABRT

      local -i failures=0
      sourceHook preTestInstall || ((++failures))
      testInstall || ((++failures))
      sourceHook postTestInstall || ((++failures))
      exit "${failures}"
    ) 2>&1 | tee "${logFile}" || testInstallStatus="$?" || true
    if [[ "${testInstallStatus}" != "0" ]] && breakOnTestFailure; then
      # break if test script error
      exit "${testInstallStatus}"
    fi
  fi

  local configStatus="0"
  if [[ "${SKIP_CONFIGURE}" = "0" && "${installStatus}" = "0" ]] &&
    ! InstallScripts::scriptFunctionEmpty configure; then
    Log::headLine "CONFIG" "Configuring ${scriptName}"
    logFile="${logsDir}/${scriptName}-config.log"
    statsFile="${statsDir}/${scriptName}-config.stat"
    (
      startDate="$(date +%s)"
      # shellcheck disable=SC2317
      computeStats() {
        local rc=$1
        Stats::statusLine "${statsFile}" "Configuration ${scriptName}"
        Stats::computeFromLog \
          "${logFile}" "${rc}" "${statsFile}" "${startDate}"
        Stats::aggregateGlobalStats \
          "${globalStatsFile}" "1" "${statsFile}"
        exit "${rc}"
      }
      trap 'computeStats "$?"' EXIT INT TERM ABRT

      local -i failures=0
      sourceHook preConfigure || ((++failures))
      configure || ((++failures))
      sourceHook postConfigure || ((++failures))
      exit "${failures}"
    ) 2>&1 | tee "${logFile}" || configStatus="$?" || true

    if [[ "${configStatus}" != "0" ]] && breakOnConfigFailure; then
      # break if config script error
      exit "${configStatus}"
    fi
  fi

  local testConfigStatus="0"
  if [[ "${SKIP_TEST}" = "0" && "${installStatus}" = "0" && "${configStatus}" = "0" ]] &&
    ! InstallScripts::scriptFunctionEmpty configure; then
    Log::headLine "TEST" "Testing ${scriptName} configuration"
    logFile="${logsDir}/${scriptName}-test-configuration.log"
    statsFile="${statsDir}/${scriptName}-test-configuration.stat"
    (
      startDate="$(date +%s)"
      # shellcheck disable=SC2317
      computeStats() {
        local rc=$1
        Stats::statusLine "${statsFile}" "Test Configuration ${scriptName}"
        Stats::computeFromLog \
          "${logFile}" "${rc}" "${statsFile}" "${startDate}"
        Stats::aggregateGlobalStats \
          "${globalStatsFile}" "1" "${statsFile}"
        exit "${rc}"
      }
      trap 'computeStats "$?"' EXIT INT TERM ABRT

      local -i failures=0
      sourceHook preTestConfigure || ((++failures))
      testConfigure || ((++failures))
      sourceHook postTestConfigure || ((++failures))
      exit "${failures}"
    ) 2>&1 | tee "${logFile}" || testConfigStatus="$?" || true
    if [[ "${testConfigStatus}" != "0" ]] && breakOnTestFailure; then
      # break if test script error
      exit "${testConfigStatus}"
    fi
  fi
}

# @description concat each element of an array with a separator
# but wrapping text when line length is more than provided argument
# The algorithm will try not to cut the array element if it can.
# - if an arg can be placed on current line it will be,
#   otherwise current line is printed and arg is added to the new
#   current line
# - Empty arg is interpreted as a new line.
# - Add \r to arg in order to force break line and avoid following
#   arg to be concatenated with current arg.
#
# @arg $1 glue:String
# @arg $2 maxLineLength:int
# @arg $3 indentNextLine:int
# @arg $@ array:String[]
Array::wrap2() {
  local glue="${1-}"
  local -i glueLength="${#glue}"
  shift || true
  local -i maxLineLength=$1
  shift || true
  local -i indentNextLine=$1
  shift || true
  local indentStr=""
  if ((indentNextLine > 0)); then
    indentStr="$(head -c "${indentNextLine}" </dev/zero | tr '\0' " ")"
  fi
  if (($# == 0)); then
    return 0
  fi

  printCurrentLine() {
    if ((isNewline == 0)) || ((previousLineEmpty == 1)); then
      echo
    fi
    ((isNewline = 1))
    echo -en "${indentStr}"
    ((currentLineLength = indentNextLine)) || true
  }
  appendToCurrentLine() {
    local text="$1"
    local -i length=$2
    ((currentLineLength += length)) || true
    ((isNewline = 0)) || true
    if [[ "${text: -1}" = $'\r' ]]; then
      text="${text:0:-1}"
      echo -en "${text%%+([[:blank:]])}"
      printCurrentLine
    else
      echo -en "${text%%+([[:blank:]])}"
    fi
  }

  (
    local currentLine
    local -i currentLineLength=0 isNewline=1 argLength=0
    local -a additionalLines
    local -i previousLineEmpty=0
    local arg=""

    while (($# > 0)); do
      arg="$1"
      shift || true

      # replace tab by 2 spaces
      arg="${arg//$'\t'/  }"
      # remove trailing spaces
      arg="${arg%[[:blank:]]}"
      if [[ "${arg}" = $'\n' || -z "${arg}" ]]; then
        printCurrentLine
        ((previousLineEmpty = 1))
        continue
      else
        if ((previousLineEmpty == 1)); then
          printCurrentLine
        fi
        ((previousLineEmpty = 0)) || true
      fi
      # convert eol to args
      mapfile -t additionalLines <<<"${arg}"
      if ((${#additionalLines[@]} > 1)); then
        set -- "${additionalLines[@]}" "$@"
        continue
      fi

      ((argLength = ${#arg})) || true

      # empty arg
      if ((argLength == 0)); then
        if ((isNewline == 0)); then
          # isNewline = 0 means currentLine is not empty
          printCurrentLine
        fi
        continue
      fi

      if ((isNewline == 0)); then
        glueLength="${#glue}"
      else
        glueLength="0"
      fi
      if ((currentLineLength + argLength + glueLength > maxLineLength)); then
        if ((argLength + glueLength > maxLineLength)); then
          # arg is too long to even fit on one line
          # we have to split the arg on current and next line
          local -i remainingLineLength
          ((remainingLineLength = maxLineLength - currentLineLength - glueLength))
          appendToCurrentLine "${glue:0:${glueLength}}${arg:0:${remainingLineLength}}" "$((glueLength + remainingLineLength))"
          printCurrentLine
          arg="${arg:${remainingLineLength}}"
          # remove leading spaces
          arg="${arg##[[:blank:]]}"

          set -- "${arg}" "$@"
        else
          # the arg can fit on next line
          printCurrentLine
          appendToCurrentLine "${arg}" "${argLength}"
        fi
      else
        appendToCurrentLine "${glue:0:${glueLength}}${arg}" "$((glueLength + argLength))"
      fi
    done
    if [[ "${currentLine}" != "" ]] && [[ ! "${currentLine}" =~ ^[\ \t]+$ ]]; then
      printCurrentLine
    fi
  ) | sed -E -e 's/[[:blank:]]+$//'
}

# @description check if function is empty
# @arg $1 function:Function
# @exitcode 0 if function is considered empty (body with : or true)
InstallScripts::scriptFunctionEmpty() {
  local pattern="^[ \t]+(:|true)"
  [[ "$(declare -f "$1" | sed '3q;d')" =~ ${pattern} && "$(declare -f "$1" | sed '4q;d')" = "}" ]]
}

# @description print the resolved path relative to DIR
# do not check for path existence
# @arg $1 srcFile:String the file to resolve
# @arg $2 relativeTo:String the directory
# @stdout the resolved path relative to DIR
File::relativeToDir() {
  local srcFile="$1"
  local relativeTo="$2"

  realpath -m --relative-to="${relativeTo}" "${srcFile}"
}

# @description apt-get install if package is not installed yet
# @arg $@ packages:String[] list of packages to install
# @feature Retry::default
# Linux::requireSudoCommand
# @require Linux::requireUbuntu
# @env SKIP_APT_GET_UPDATE
# @stdout diagnostics logs
Linux::Apt::installIfNecessary() {
  local -a packages=("$@")
  local package
  local -i installNeeded=0
  for package in "${packages[@]}"; do
    if [[ "${package}" =~ ^-- ]]; then
      continue
    fi
    if ! Linux::Apt::isPackageInstalled "${package}"; then
      Log::displayInfo "Package ${package} is not installed"
      installNeeded=1
    fi
  done
  if ((installNeeded == 1)); then
    if [[ "${SKIP_APT_GET_UPDATE:-0}" = "0" ]]; then
      Linux::Apt::update
    fi
    Linux::Apt::install "${packages[@]}"
    for package in "${packages[@]}"; do
      if [[ "${package}" =~ ^-- ]]; then
        continue
      fi
      if ! Linux::Apt::isPackageInstalled "${package}"; then
        Log::displayWarning "Package ${package} does not appear to have been installed, check if you could have chosen the wrong package name (Eg: python3.9-distutils instead of python3-distutils)"
      fi
    done
  else
    Log::displayInfo "Apt install avoided as packages are already installed : ${packages[*]}"
  fi
}

# @description check if command specified exists or return 1
# with error and message if not
#
# @arg $1 commandName:String on which existence must be checked
# @arg $2 helpIfNotExists:String a help command to display if the command does not exist
#
# @exitcode 1 if the command specified does not exist
# @stderr diagnostic information + help if second argument is provided
Assert::commandExists() {
  local commandName="$1"
  local helpIfNotExists="$2"

  "${BASH_FRAMEWORK_COMMAND:-command}" -v "${commandName}" >/dev/null 2>/dev/null || {
    Log::displayError "${commandName} is not installed, please install it"
    if [[ -n "${helpIfNotExists}" ]]; then
      Log::displayInfo "${helpIfNotExists}"
    fi
    return 1
  }
  return 0
}

# @description Display message using info color (bg light blue/fg white)
# @arg $1 message:String the message to display
Log::displayHelp() {
  local type="${2:-HELP}"
  if ((BASH_FRAMEWORK_DISPLAY_LEVEL >= __LEVEL_INFO)); then
    Log::computeDuration
    echo -e "${__HELP_COLOR}${type}    - ${LOG_CONTEXT:-}${LOG_LAST_DURATION_STR:-}${1}${__RESET_COLOR}" >&2
  fi
  Log::logHelp "$1" "${type}"
}

# @description copy folder structure to target directory
# merge embedDir with overridden directory if provided and available
# @arg $1 embedDir:String the path embedded
# @arg $2 overrideDir:String the path overridden
# @arg $3 subDir:String the sub-directory to copy from embedDir and/or overrideDir
# @arg $4 targetDir:String the target directory (default: ${HOME}/${subDir})
# @env SUDO String allows to use custom sudo prefix command
# @env HOME used for default value of targetDir arg
# @env OVERWRITE_CONFIG_FILES indicates if target directory should be overwritten if it exists
# @env PRETTY_ROOT_DIR used to make paths relative to this directory to reduce length of messages
# @env IGNORE_MISSING_SOURCE_DIR
Conf::copyStructure() {
  local embedDir="$1"
  local overrideDir="$2"
  local subDir="$3"
  local targetDir="${4:-${HOME}/${subDir}}"

  local configDir
  # shellcheck disable=SC2154
  configDir="$(Conf::getOverriddenDir "${embedDir}" "${overrideDir}")"
  if [[ -d "${configDir}/${subDir}" ]]; then
    # shellcheck disable=SC2154
    OVERWRITE_CONFIG_FILES=${OVERWRITE_CONFIG_FILES:-1} \
      PRETTY_ROOT_DIR="${embedDir%/*}" \
      Install::structure "${configDir}/${subDir}" "${targetDir}"
  elif [[ "${IGNORE_MISSING_SOURCE_DIR:-0}" = "1" ]]; then
    return 0
  else
    Log::displayError "Directory ${subDir} does not exists in '${embedDir}' or '${overrideDir}'"
    return 1
  fi
}

# @description installs file to given directory
#
# callbacks parameters `${fromFile} ${targetFile} $@`
# @arg $1 fromFile - original file to copy
# @arg $2 targetFile - target file
# @arg $3 userName:String (optional) (default: ${USERNAME}) the user name that will be used to set target files ownership
# @arg $4 userGroup:String (optional) (default: ${USERNAME}) the group name that will be used to set target files ownership
# @arg $5 successCallback:Function the callback to call when file is installed successfully, by default setUserRights callback is called
# @arg $6 failureCallback:Function the callback to call when file installation has failed, by default unableToCopyCallback callback is called
# @arg $@ callbacksParams:String[] additional parameters passed to callbacks
# @exitcode 1 if fromFile is not readable
# @exitcode 2 if backup file failure
# @exitcode 3 if copy failure
# @exitcode 0 on success or if OVERWRITE_CONFIG_FILES=0
# @exitcode 0 on success or if CHANGE_WINDOWS_FILES=0 and target file is a windows file
# @env OVERWRITE_CONFIG_FILES Boolean (default:0) if 1 will overwrite existing directory
# @env CHANGE_WINDOWS_FILES Boolean (default:0) if 1 and target file is in windows file system, overwrite it
# @env USERNAME (default: root) the user name that will be used to set target files ownership
# @env USERGROUP (default: root) the group name that will be used to set target files ownership
# @env BASE_MNT_C String windows C drive base PATH
# @env FRAMEWORK_ROOT_DIR used to make paths relative to this directory to reduce length of messages
# @env SUDO String allows to use custom sudo prefix command
# @env BACKUP_BEFORE_INSTALL Boolean (default: 1) backup file before installing the file
Install::file() {
  local fromFile="$1"
  local targetFile="$2"
  local userName="${3:-${USERNAME:-root}}"
  local userGroup="${4:-${USERGROUP:-root}}"
  local successCallback=${5:-Install::setUserRightsCallback}
  local failureCallback=${6:-Install::unableToCopyCallback}
  shift 6 || true

  if [[ ! -f "${fromFile}" || ! -r "${fromFile}" ]]; then
    Log::displayError "cannot read source file '${fromFile}'"
    return 1
  fi

  # skip if OVERWRITE_CONFIG_FILES is 0 and target file exists
  if [[ "${OVERWRITE_CONFIG_FILES}" = "0" && -f "${targetFile}" ]]; then
    Log::displayWarning "File '${targetFile}' exists - Skip install (because OVERWRITE_CONFIG_FILES=0 in .env file)"
    return 0
  fi

  # skip if CHANGE_WINDOWS_FILES is 0 and target dir is c drive
  if [[ "${CHANGE_WINDOWS_FILES}" = "0" && "${targetFile}" =~ ^${BASE_MNT_C} ]]; then
    Log::displayWarning "File '${targetFile}' - Skip install (because CHANGE_WINDOWS_FILES=0 in .env file)"
    return 0
  fi

  local targetDir="${targetFile%/*}"
  if ! ${SUDO} test -d "${targetDir}"; then
    ${SUDO:-} mkdir -p "${targetDir}"
    ${SUDO:-} chown "${userName}":"${userGroup}" "${targetDir}"
  fi
  local fromDir="${fromFile%/*}"
  local fromFilename="${fromFile##*/}"

  local prettyFromDir
  # shellcheck disable=SC2295
  prettyFromDir="${fromDir#${PRETTY_ROOT_DIR:-${FRAMEWORK_ROOT_DIR}}/}"
  if diff -q "${fromFile}" "${targetFile}" &>/dev/null; then
    Log::displayStatus "No changes detected. No need to update '${targetFile}' from '${prettyFromDir}/${fromFilename}'"
    return 0
  fi

  if [[ "${BACKUP_BEFORE_INSTALL:-1}" = "1" ]]; then
    Backup::file "${targetFile}" || return 2
  fi

  if ${SUDO:-} cp "${fromFile}" "${targetFile}"; then
    # shellcheck disable=SC2295
    Log::displaySuccess "Installed file '${targetFile}' from '${prettyFromDir}/${fromFilename}'"
    ${successCallback} "${fromFile}" "${targetFile}" "${userName}" "${userGroup}" "${prettyFromDir}" "${fromFilename}"
  else
    # shellcheck disable=SC2295
    Log::displayError "unable to copy file '${targetFile}' from '${fromDir#${FRAMEWORK_ROOT_DIR}/}/${fromFilename}'"
    ${failureCallback} "${fromFile}" "${targetFile}" "${userName}" "${userGroup}" "${prettyFromDir}" "${fromFilename}"
    return 3
  fi
}

# @description asserts that first argument is file that exists with specified ownership
# @arg $1 file:String
# @arg $2 user:String expected owner user name of the file (default: USERNAME or id -un command)
# @arg $3 group:String expected owner group name of the file (default: USERGROUP or id -gn command)
# @env USERNAME String if arg $2 is not provided
# @env USERGROUP String if arg $3 is not provided
# @env SUDO String allows to use custom sudo prefix command
# @exitcode 1 if missing file
# @exitcode 2 if incorrect user ownership
# @exitcode 3 if incorrect group ownership
# @stderr diagnostics information is displayed
Assert::fileExists() {
  local file="$1"
  local user="${2:-${USERNAME}}"
  local group="${3:-${USERGROUP}}"
  if [[ -n "${user}" ]]; then
    Log::displayInfo "Check ${file} exists with user ${user}:${group}"
  else
    Log::displayInfo "Check ${file} exists"
  fi
  if ! ${SUDO:-} test -f "${file}" &>/dev/null; then
    Log::displayError "missing file ${file}"
    return 1
  fi
  if [[ -n "${user}" && "${user}" != "$(${SUDO:-} stat -c '%U' "${file}")" ]]; then
    Log::displayError "incorrect user ownership on file ${file}"
    return 2
  fi
  if [[ -n "${group}" && "${group}" != "$(${SUDO:-} stat -c '%G' "${file}")" ]]; then
    Log::displayError "incorrect group ownership on file ${file}"
    return 3
  fi
}

# @description ensure COMMAND_BIN_DIR env var is set
# and PATH correctly prepared
# @noargs
# @set COMMAND_BIN_DIR string the directory where to find this command
# @set PATH string add directory where to find this command binary
Compiler::Facade::requireCommandBinDir() {
  COMMAND_BIN_DIR="${CURRENT_DIR}"
  Env::pathPrepend "${COMMAND_BIN_DIR}"
}

declare -g FIRST_LOG_DATE LOG_LAST_LOG_DATE LOG_LAST_LOG_DATE_INIT LOG_LAST_DURATION_STR
FIRST_LOG_DATE="${EPOCHREALTIME/[^0-9]/}"
LOG_LAST_LOG_DATE="${FIRST_LOG_DATE}"
LOG_LAST_LOG_DATE_INIT=1
LOG_LAST_DURATION_STR=""

# @description Display message using info color (bg light blue/fg white)
# @arg $1 message:String the message to display
# @env DISPLAY_DURATION int (default 0) if 1 display elapsed time information between 2 info logs
Log::computeDuration() {
  if ((DISPLAY_DURATION == 1)); then
    local -i duration=0
    local -i delta=0
    local -i currentLogDate
    currentLogDate="${EPOCHREALTIME/[^0-9]/}"
    if ((LOG_LAST_LOG_DATE_INIT == 1)); then
      LOG_LAST_LOG_DATE_INIT=0
      LOG_LAST_DURATION_STR="Ref"
    else
      duration=$(((currentLogDate - FIRST_LOG_DATE) / 1000000))
      delta=$(((currentLogDate - LOG_LAST_LOG_DATE) / 1000000))
      LOG_LAST_DURATION_STR="${duration}s/+${delta}s"
    fi
    LOG_LAST_LOG_DATE="${currentLogDate}"
    # shellcheck disable=SC2034
    local microSeconds="${EPOCHREALTIME#*.}"
    LOG_LAST_DURATION_STR="$(printf '%(%T)T.%03.0f\n' "${EPOCHSECONDS}" "${microSeconds:0:3}")(${LOG_LAST_DURATION_STR}) - "
  else
    # shellcheck disable=SC2034
    LOG_LAST_DURATION_STR=""
  fi
}

# @description log message to file
# @arg $1 message:String the message to display
Log::logInfo() {
  if ((BASH_FRAMEWORK_LOG_LEVEL >= __LEVEL_INFO)); then
    Log::logMessage "${2:-INFO}" "$1"
  fi
}

# @description log message to file
# @arg $1 message:String the message to display
Log::logDebug() {
  if ((BASH_FRAMEWORK_LOG_LEVEL >= __LEVEL_DEBUG)); then
    Log::logMessage "${2:-DEBUG}" "$1"
  fi
}

# @description prepend directories to the PATH environment variable
# @arg $@ args:String[] list of directories to prepend
# @set PATH update PATH with the directories prepended
Env::pathPrepend() {
  local arg
  for arg in "$@"; do
    if [[ -d "${arg}" && ":${PATH}:" != *":${arg}:"* ]]; then
      PATH="$(realpath "${arg}"):${PATH}"
    fi
  done
}

# @description if .env does not exist, initialize it with .env.template
Engine::Config::createEnvFileFromTemplate() {
  local envFile="$1"
  local envFileTemplate="$2"

  if [[ ! -f "${envFile}" ]]; then
    echo "${envFileTemplate}" >"${envFile}"
    Log::displayError "a default env file has been created, please edit ${envFile}"
    return 1
  fi
}

# @description load /etc/os-release file
# @set NAME
# @set VERSION
# @set ID
# @set ID_LIKE
# @set PRETTY_NAME
# @set VERSION_ID
# @set HOME_URL
# @set SUPPORT_URL
# @set BUG_REPORT_URL
# @set PRIVACY_POLICY_URL
# @set VERSION_CODENAME
# @set UBUNTU_CODENAME
Engine::Config::loadOsRelease() {
  if [[ ! -f /etc/os-release ]]; then
    Log::displayError "file /etc/os-release does not exists"
    return 1
  fi
  # This will load environment variables ID, VERSION_CODENAME, ...
  set -o allexport
  source /etc/os-release
  set +o allexport
}

# @description deduce HOME, USER_ID, USERGROUP_ID and USERGROUP from USERNAME
# @env USERNAME String the name of the user
# @set USER_ID String
# @set USERGROUP String
# @set USERGROUP_ID String
# @set USER_SHELL String current user shell
# @set HOME String
# @env REMOTE String prefix command to run commands remotely
Engine::Config::loadUserVariables() {
  # deduce user home and group
  local -a split
  local IFS=':'
  # shellcheck disable=SC2207
  split=($(${REMOTE:-} getent passwd "${USERNAME}"))
  USER_ID="${split[2]}"
  USERGROUP_ID="${split[3]}"
  HOME="${split[5]}"
  USER_SHELL="${split[6]}"
  USERGROUP="$(${REMOTE:-} id -gn "${USERNAME}")"

  if [[ -z "${USERGROUP}" || -z "${HOME}" ]]; then
    Log::displayError "USERNAME - unable to deduce USERGROUP, HOME from USERNAME"
    return 1
  fi

  export HOME
  export USER_ID
  export USERGROUP_ID
  export USERGROUP
  export USER_SHELL
}

# @description check validity of .env variables
# @env CHECK_ENV int 0 to avoid checking environment
# @noargs
Engine::Config::checkEnv() {
  local envFile="$1"
  if [[ "${CHECK_ENV:-1}" = "0" ]]; then
    return 0
  fi
  # avoid checks if .env file didn't changed
  local envFileMd5Cache="${PERSISTENT_TMPDIR:-/tmp}/bash-dev-env-enf-file-checksum"
  if md5sum -c "${envFileMd5Cache}" &>/dev/null; then
    return 0
  else
    md5sum "${envFile}" >"${envFileMd5Cache}"
  fi
  local errorCount=0 || true
  checkNotEmpty() {
    local var="$1"
    if ! Assert::varExistsAndNotEmpty "${var}"; then
      ((++errorCount))
      return 1
    fi
  }
  checkVarAndDir() {
    local var="$1"
    local mode="${2:-}"
    local status=0
    if checkNotEmpty "${var}"; then
      if [[ ! -d "${!var}" ]] && ! mkdir -p "${!var}"; then
        Log::displayError "variable ${var} - impossible to create the directory '${!var}'"
        ((errorCount++))
        return 1
      fi
      if [[ "${mode}" =~ w && ! -w "${!var}" ]]; then
        Log::displayError "variable ${var} - directory '${!var}' is not writable"
        ((status++))
        ((errorCount++))
      fi
      if [[ "${mode}" =~ r && ! -r "${!var}" ]]; then
        Log::displayError "variable ${var} - directory '${!var}' is not accessible"
        ((status++))
        ((errorCount++))
      fi
    fi

    return "${status}"
  }
  checkValidValues() {
    local var="$1"
    shift || true
    local -a validValues=("$@")
    if ! Array::contains "${!var}" "${validValues[@]}"; then
      Log::displayError "variable ${var} - value ${!var} is not part of the following values ${validValues[*]}"
      ((++errorCount))
    fi
  }

  if ! echo "${ID}" | grep -qEw 'debian|ubuntu'; then
    Log::fatal "This script is built to support only Debian or Ubuntu distributions. You are using ${ID}."
  fi

  if checkNotEmpty USERNAME && ! getent passwd "${USERNAME}" 2>/dev/null >/dev/null; then
    Log::displayError "USERNAME - user '${USERNAME}' does not exist"
    ((errorCount++))
  fi

  if [[ -n "${SSH_LOGIN:-}" ]] && ! Assert::ldapLogin "${SSH_LOGIN}"; then
    Log::displayError "SSH_LOGIN - invalid ldap login (format expected firstNameLastName) in ${BASH_DEV_ENV_ROOT_DIR}/.env file"
    ((errorCount++))
  fi

  if checkNotEmpty "GIT_USERNAME" && ! Assert::firstNameLastName "${GIT_USERNAME}"; then
    Log::displayError "GIT_USERNAME - invalid format, expected : firstName lastName"
    ((errorCount++))
  fi

  if checkNotEmpty "GIT_USER_MAIL" && ! Assert::emailAddress "${GIT_USER_MAIL}"; then
    Log::displayError "GIT_USER_MAIL - invalid email address"
    ((errorCount++))
  fi

  if checkNotEmpty "AWS_USER_MAIL" && ! Assert::emailAddress "${AWS_USER_MAIL}"; then
    Log::displayError "AWS_USER_MAIL - invalid email address"
    ((errorCount++))
  fi

  checkVarAndDir CONF_OVERRIDE_DIR r || true
  checkVarAndDir PROJECTS_DIR r || true
  checkVarAndDir BACKUP_DIR rw || true
  checkVarAndDir LOGS_DIR rw || true
  checkVarAndDir INSTALL_SCRIPTS_ROOT_DIR r || true
  checkVarAndDir HOME rw || true

  checkValidValues UPGRADE_UBUNTU_VERSION 0 lts dev
  checkValidValues PREFERRED_SHELL ShellBash ShellZsh
  checkValidValues ZSH_PREFERRED_THEME powerlevel10k/powerlevel10k sindresorhus/pure starship/starship

  checkValidValues SHOW_FORTUNES 0 1
  checkValidValues SHOW_MOTD 0 1
  checkValidValues OVERWRITE_CONFIG_FILES 0 1
  checkValidValues CHANGE_WINDOWS_FILES 0 1
  checkValidValues CAN_TALK_DURING_INSTALLATION 0 1
  checkValidValues INSTALL_INTERACTIVE 0 1

  checkNotEmpty WSLCONFIG_MAX_MEMORY
  checkValidValues WSLCONFIG_SWAP 0 1
  export CHECK_ENV=0
  return "${errorCount}"
}

# @description deduce wsl host ip
# @set HOST_IP exported env containing the IP
Engine::Config::loadHostIp() {
  HOST_IP="$(/sbin/ip route | awk '/default/ { print $3 }')"

  export HOST_IP
}

# @description install apt wslu if necessary providing wslvar, wslpath
Engine::Config::requireWslu() {
  if ! command -v wslvar &>/dev/null; then
    Log::displayInfo "Installing pre-requisite Wslu : wslvar, wslpath, ... commands"
    Linux::Apt::installIfNecessary --no-install-recommends wslu

    # @see https://github.com/microsoft/WSL/issues/8843#issuecomment-1792256894
    Log::displayInfo "Fix wsl interoperability due to wsl bug"
    if [[ ! -f /usr/lib/binfmt.d/WSLInterop.conf &&
      ! -f /etc/systemd/system/wsl-binfmt.service &&
      -f /run/systemd/generator.early/wsl-binfmt.service ]]; then
      sudo sh -c 'echo :WSLInterop:M::MZ::/init:PF > /usr/lib/binfmt.d/WSLInterop.conf'
      sudo ln -s /run/systemd/generator.early/wsl-binfmt.service /etc/systemd/system/wsl-binfmt.service
    fi
  fi
}

# @description load wsl env variables
# @set BASE_MNT_C
# @set WINDOWS_DIR
# @set WINDOWS_PROFILE_DIR
# @set LOCAL_APP_DATA
# @set WINDOW_PATH
# @set WSL_EXE_BIN
# @set IPCONFIG_BIN
# @set POWERSHELL_BIN
# @env WSL_EXE_BIN
# @env IPCONFIG_BIN
# @env POWERSHELL_BIN
Engine::Config::loadWslVariables() {
  if ! Assert::wsl; then
    # skip
    return 0
  fi

  local IFS=' '
  local -a split=()
  # shellcheck disable=SC2207
  split=($(grep -m 1 -E 'C:\\[^ ]+ ([^ ]+) ' /proc/mounts 2>/dev/null))
  # shellcheck disable=SC1003
  BASE_MNT_C="${split[1]}"
  export BASE_MNT_C

  Linux::Wsl::cachedWslpathFromWslVar2 WINDOWS_DIR SystemRoot
  WINDOWS_DIR="${WINDOWS_DIR:-${BASE_MNT_C:-/mnt/c}/Windows}"
  export WINDOWS_DIR

  Linux::Wsl::cachedWslpathFromWslVar2 WINDOWS_PROFILE_DIR USERPROFILE
  WINDOWS_PROFILE_DIR="${WINDOWS_PROFILE_DIR:-${BASE_MNT_C:-/mnt/c}/Users/${WINDOWS_USERNAME}}"
  export WINDOWS_PROFILE_DIR

  Linux::Wsl::cachedWslpathFromWslVar2 LOCAL_APP_DATA LOCALAPPDATA
  export LOCAL_APP_DATA

  # WINDOW_PATH
  Linux::Wsl::cachedWslvar2 WINDOW_PATH PATH
  WINDOW_PATH="${WINDOW_PATH//;/:}"
  WINDOW_PATH="${WINDOW_PATH//\\//}"
  WINDOW_PATH="${WINDOW_PATH//C:/${BASE_MNT_C:-/mnt/c}}"

  deduceBin() {
    local var="$1"
    local expectedFullPath="$2"
    local expectedBin="$3"
    if [[ -z "${!var+xxx}" ]]; then
      eval "${var}=${expectedFullPath}"
      if ! command -v "${!var}" >/dev/null 2>&1; then
        eval "${var}=$(command -v "${expectedBin}" 2>/dev/null)"
      fi
    fi
    if [[ -z "${!var:-}" ]] || ! command -v "${!var}" >/dev/null 2>&1; then
      Log::fatal "variable ${var} - command ${expectedBin} not found"
    fi
    # shellcheck disable=SC2163
    export "${var}"
  }

  checkBinary() {
    local var="$1"
    if [[ -z "${var}" || ! -x "${!var}" ]]; then
      Log::displayError "variable ${var} - binary '${!var}' does not exist or not executable"
      ((errorCount++))
    fi
  }

  local errorCount=0
  # IPCONFIG_BIN - which ipconfig.exe does not work when executed as root
  deduceBin IPCONFIG_BIN "${WINDOWS_DIR}/System32/ipconfig.exe" "ipconfig.exe"
  checkBinary IPCONFIG_BIN

  deduceBin WSL_EXE_BIN "${WINDOWS_DIR}/System32/wsl.exe" "wsl.exe"
  checkBinary WSL_EXE_BIN

  deduceBin POWERSHELL_BIN "${WINDOWS_DIR}/System32/WindowsPowerShell/v1.0/powershell.exe" "powershell.exe"
  checkBinary POWERSHELL_BIN

  return "${errorCount}"
}

# @description load pageant and ssh key
# you can provide ssh key by env variable SSH_PRIVATE_KEY
# or if empty, file ~/.ssh/id_rsa will be used if present
# @env SSH_PRIVATE_KEY ssh key provided by env variable
# @env AUTHORIZE_SSH_KEY_USAGE if 0, no ssh key is loaded
# @env LOAD_SSH_KEY feature flag used in distro mode
Engine::Config::loadSshKey() {
  if [[ "${LOAD_SSH_KEY:-1}" = "0" ]]; then
    # ignore in distro mode
    return 0
  fi
  if [[ "${AUTHORIZE_SSH_KEY_USAGE:-0}" = "0" ]]; then
    Log::displaySkipped "Ssh key will not be loaded as you set AUTHORIZE_SSH_KEY_USAGE to 0"
    return 0
  fi
  if [[ -n "${SSH_AUTH_SOCK}" && -n "${SSH_AGENT_PID}" ]]; then
    Log::displaySkipped "Ssh agent skipped as variables SSH_AUTH_SOCK and SSH_AGENT_PID are set"
    return 0
  fi

  if [[ -z "${SSH_PRIVATE_KEY}" && ! -f "${HOME}/.ssh/id_rsa" ]]; then
    Log::displayError "File '${HOME}/.ssh/id_rsa' is missing and env variable SSH_PRIVATE_KEY is empty"
    return 1
  fi
  local errorCode=0
  ssh-add -l &>/dev/null || errorCode=$?
  if [[ "${errorCode}" = "2" ]]; then
    # ssh agent is not started
    Log::displayInfo "Starting ssh agent"
    eval "$(ssh-agent)" || return 2
    export SSH_AUTH_SOCK
    export SSH_AGENT_PID
  fi

  if [[ -z "${SSH_PRIVATE_KEY}" ]]; then
    ssh-add "${HOME}/.ssh/id_rsa" || return 3
  else
    ssh-add <(base64 -d <<<"${SSH_PRIVATE_KEY}") || return 3
  fi

  # Check key has been added to ssh agent
  ssh-add -l &>/dev/null || {
    Log::displayError "Your ssh key has not been loaded"
    return 4
  }
}

# @description load locale configuration
Engine::Config::loadLocaleConfig() {
  if [[ "${BASH_DEV_ENV_CONFIG_LOADED:-0}" = "1" ]]; then
    return 0
  fi
  if [[ "${LOAD_LOCALE_CONFIG:-1}" = "1" && ! -f "${PERSISTENT_TMPDIR}/localeConfig.initialized" ]]; then
    Log::displayInfo "Initializing locale en_US.UTF-8"
    export PATH="${PATH}:${HOME}/.local/bin"
    sudo sed -E -i -e 's/# en_US.UTF-8 UTF-8/en_US.UTF-8 UTF-8/' /etc/locale.gen
    echo 'LANG="en_US.UTF-8"' | sudo tee /etc/default/locale >/dev/null
    echo "LANG=en_US.UTF-8" | sudo tee /etc/locale.conf >/dev/null
    sudo locale-gen en_US.UTF-8
    sudo dpkg-reconfigure --frontend=noninteractive locales
    export LC_ALL=C
    export LANG=en_US.UTF-8
    export LC_MESSAGES=en_US.UTF-8
    touch "${PERSISTENT_TMPDIR}/localeConfig.initialized"
  fi
}

# @description log message to file
# @arg $1 message:String the message to display
Log::logWarning() {
  if ((BASH_FRAMEWORK_LOG_LEVEL >= __LEVEL_WARNING)); then
    Log::logMessage "${2:-WARNING}" "$1"
  fi
}

# @description log message to file
# @arg $1 message:String the message to display
Log::logError() {
  if ((BASH_FRAMEWORK_LOG_LEVEL >= __LEVEL_ERROR)); then
    Log::logMessage "${2:-ERROR}" "$1"
  fi
}

# @description check if tty (interactive mode) is active
# @noargs
# @exitcode 1 if tty not active
# @env NON_INTERACTIVE if 1 consider as not interactive even if environment is interactive
# @env INTERACTIVE if 1 consider as interactive even if environment is not interactive
Assert::tty() {
  if [[ "${NON_INTERACTIVE:-0}" = "1" ]]; then
    return 1
  fi
  if [[ "${INTERACTIVE:-0}" = "1" ]]; then
    return 0
  fi
  # check if stdout or stderr is connected to terminal
  [[ -t 1 || -t 2 ]]
}

# @description log message to file
# @arg $1 message:String the message to display
Log::logFatal() {
  Log::logMessage "${2:-FATAL}" "$1"
}

# @description Internal: common log message
# @example text
#   [date]|[levelMsg]|message
#
# @example text
#   2020-01-19 19:20:21|ERROR  |log error
#   2020-01-19 19:20:21|SKIPPED|log skipped
#
# @arg $1 levelMsg:String message's level description (eg: STATUS, ERROR, ...)
# @arg $2 msg:String the message to display
# @env BASH_FRAMEWORK_LOG_FILE String log file to use, do nothing if empty
# @env BASH_FRAMEWORK_LOG_LEVEL int log level log only if > OFF or fatal messages
# @stderr diagnostics information is displayed
# @require Env::requireLoad
# @require Log::requireLoad
Log::logMessage() {
  local levelMsg="$1"
  local msg="$2"
  local date

  if [[ -n "${BASH_FRAMEWORK_LOG_FILE}" ]] && ((BASH_FRAMEWORK_LOG_LEVEL > __LEVEL_OFF)); then
    date="$(date '+%Y-%m-%d %H:%M:%S')"
    touch "${BASH_FRAMEWORK_LOG_FILE}"
    printf "%s|%7s|%s\n" "${date}" "${levelMsg}" "${msg}" >>"${BASH_FRAMEWORK_LOG_FILE}"
  fi
}

# @description To be called before logging in the log file
# @arg $1 file:string log file name
# @arg $2 maxLogFilesCount:int maximum number of log files
Log::rotate() {
  local file="$1"
  local maxLogFilesCount="${2:-5}"

  if [[ ! -f "${file}" ]]; then
    Log::displayDebug "Log file ${file} doesn't exist yet"
    return 0
  fi
  local i
  for ((i = maxLogFilesCount - 1; i > 0; i--)); do
    Log::displayInfo "Log rotation ${file}.${i} to ${file}.$((i + 1))"
    mv "${file}."{"${i}","$((i + 1))"} &>/dev/null || true
  done
  if cp "${file}" "${file}.1" &>/dev/null; then
    echo >"${file}" # reset log file
    Log::displayInfo "Log rotation ${file} to ${file}.1"
  fi
}

# @description select right file to load depending if file exists in this order:
# - from conf.override
# - from embedded file if provided
# - from conf dir
# @arg $1 file:String
# @arg $2 embedFile:String eventual embedded file
# @exitcode 1 if file does not exist at all
Conf::dynamicConfFile() {
  local file="${1/#\//}" # remove first slash if any
  local embedFile="${2:-}"
  if [[ -f "${CONF_OVERRIDE_DIR}/${file}" ]]; then
    echo "${CONF_OVERRIDE_DIR}/${file}"
    return 0
  elif [[ -f "${embedFile}" ]]; then
    echo "${embedFile}"
    return 0
  fi
  if [[ "${IGNORE_ERROR:-0}" = "0" ]]; then
    Log::displayWarning "Conf::dynamicConfFile - ${file} does not exist in any config dirs declared"
    return 1
  fi
}

# @description Display given text on full line with TEST_COLOR style
# @arg $1 text:String text to display
Log::headLine() {
  local type="$1"
  local text="$2"
  local message="${type}   - ${text}"
  if [[ -z "${type}" ]]; then
    message="${text}"
  else
    Log::computeDuration
    message="$(printf '%-7s - %s%s' "${type}" "${LOG_CONTEXT:-}${LOG_LAST_DURATION_STR:-}" "${text}")"
  fi
  echo -e "${__TEST_COLOR}$(UI::textLine "${message}" " ")${__RESET_COLOR}" >&2
}

# @description display message to reflect last installation status
# @arg $1:statFile
# @arg $2:msg
Stats::statusLine() {
  local statFile="$1"
  local msg="$2"
  if [[ ! -f "${statFile}" ]]; then
    return 0
  fi
  Log::computeDuration
  (
    # shellcheck source=src/Stats/logStats.example
    source "${statFile}" || exit 1

    local color="${__TEST_ERROR_COLOR}"
    local statusMsg
    if [[ "${status}" = "0" ]]; then
      if [[ "${skipped}" = "0" ]]; then
        color="${__SUCCESS_COLOR}"
        statusMsg="SUCCESS - ${LOG_CONTEXT:-}${LOG_LAST_DURATION_STR}${msg} successful"
      fi
    elif [[ "${status}" = "-1" ]]; then
      statusMsg="ABORTED - ${LOG_CONTEXT:-}${LOG_LAST_DURATION_STR}${msg} not executed"
    else
      statusMsg="ERROR   - ${LOG_CONTEXT:-}${LOG_LAST_DURATION_STR}${msg} in error"
    fi
    # overwrite final TEST line
    echo -e "${color}${statusMsg}${__RESET_COLOR}"
  )
}

# @description extract stats form log
# @arg $1 logFile:String the log file to parse
# @arg $2 status:int the status of the command associated to that log file
# @arg $3 statsFile:String where to write stats
# @arg $4 startDate:String date at which log started
# @stdout output with the format provided by this example src/Stats/aggregateStats.example
# @see src/Stats/aggregateStats.example
Stats::computeFromLog() {
  local logFile="$1"
  local status="$2"
  local statsFile="$3"
  local startDate="$4"
  local endDate
  endDate="$(date +%s)"
  local duration="$((endDate - startDate))"

  local logStatsAwkScript
  logStatsAwkScript="$(
    cat <<'EOF'
BEGIN {
  error=0
  warning=0
  skipped=0
  help=0
  success=0
}
{
  buffer = substr($0, 1, 20)
  if(match(buffer, /(ERROR)[ ]+- /, arr) != 0) {
    error+=1
  } else if(match(buffer, /(WARNING)[ ]+- /, arr) != 0) {
    warning+=1
  } else if(match(buffer, /(SKIPPED)[ ]+- /, arr) != 0) {
    skipped+=1
  } else if(match(buffer, /(ERROR)[ ]+- /, arr) != 0) {
    error+=1
  } else if(match(buffer, /(HELP)[ ]+- /, arr) != 0) {
    help+=1
  } else if(match(buffer, /(SUCCESS)[ ]+- /, arr) != 0) {
    success+=1
  }

}
END {
  error = (stat != 0) || error
  print "error=" error
  print "warning=" warning
  print "skipped=" skipped
  print "help=" help
  success = (stat == 0) || success
  print "success=" success
}
EOF
  )"

  (
    if [[ -f "${logFile}" ]]; then
      awk -v status="${status}" --source "${logStatsAwkScript}" "${logFile}"
      echo "status=${status}"
      echo "duration=${duration}"
    else
      # not executed
      echo "status=-1"
    fi
  ) >"${statsFile}"
}

# @description aggregate number of skip/error/... log messages
# and export the result in aggregateStatFile
# @arg $1 statFile:String the current stat file to add to aggregateStatFile
# @arg $2 appCount:int number of app requested to be installed
# @arg $@ statFiles:String[] the files in which each step stats have been aggregated aggregated
# if it doesn't exist, the file is created with needed variables set to 0
# stats will be saved
Stats::aggregateGlobalStats() {
  local aggregateStatFile="$1"
  local appCount="$2"
  shift 2 || true
  local -a statFiles=("$@")

  (
    if [[ ! -f "${aggregateStatFile}" ]]; then
      Stats::aggregateStatsInitialContent "${appCount}" >"${aggregateStatFile}"
    fi
    # shellcheck source=src/Stats/aggregateStats.example
    source "${aggregateStatFile}"

    local -i globalError=0
    local -i globalWarning=0
    local -i globalSkipped=0
    local -i globalHelp=0
    local -i globalSuccess=0
    local -i globalStatus=0
    ((globalDuration = duration)) || true
    for statFile in "${statFiles[@]}"; do
      if [[ ! -f "${statFile}" ]]; then
        continue
      fi
      # shellcheck source=src/Stats/logStats.example
      source "${statFile}"

      # all statuses need to be 0 for global status to be O
      globalError=$((globalError || error))
      globalWarning=$((globalWarning || warning))
      globalSkipped=$((globalSkipped || skipped))
      globalHelp=$((globalHelp || help))
      globalSuccess=$((globalSuccess || success))
      globalStatus=$((globalStatus || status))
      globalDuration=$((globalDuration + duration))
    done
    # shellcheck source=src/Stats/aggregateStats.example
    source "${aggregateStatFile}"
    ((count++)) || true
    if ((globalStatus == 0)); then
      ((statusSuccess++)) || true
    fi
    if ((globalStatus > 0 || globalError > 0)); then
      ((error++)) || true
    fi
    if ((globalWarning > 0)); then
      ((warning++)) || true
    fi
    if ((globalSkipped > 0)); then
      ((skipped++)) || true
    fi
    if ((globalHelp > 0)); then
      ((help++)) || true
    fi
    if ((globalSuccess > 0)); then
      ((success++)) || true
    fi
    (
      echo "count=${count}"
      echo "appCount=${appCount}"
      echo "error=${error}"
      echo "warning=${warning}"
      echo "skipped=${skipped}"
      echo "help=${help}"
      echo "success=${success}"
      echo "duration=${globalDuration}"
      echo "statusSuccess=${statusSuccess}"
    ) >"${aggregateStatFile}"
  )
}

# @description check if apt package is installed
# @arg $1 package:String the package name to check
# @require Linux::requireUbuntu
# @stdout diagnostics logs
Linux::Apt::isPackageInstalled() {
  local package="$1"
  dpkg -l "${package}" | grep -Eq "^ii  ${package}"
}

# @description update apt packages list
# @feature Retry::default
# Linux::requireSudoCommand
# @require Linux::requireUbuntu
# @stdout diagnostics logs
Linux::Apt::update() {
  Log::displayInfo "Apt update ..."
  Retry::default sudo apt-get update -y --fix-missing -o Acquire::ForceIPv4=true
}

# @description apt-get install
# @arg $@ softwares:String[] list of softwares to install
# @feature Retry::default
# Linux::requireSudoCommand
# @require Linux::requireUbuntu
# @stdout diagnostics logs
Linux::Apt::install() {
  Log::displayInfo "Apt install $*"
  Retry::default sudo apt-get install -y -q "$@"
}

# @description log message to file
# @arg $1 message:String the message to display
Log::logHelp() {
  if ((BASH_FRAMEWORK_LOG_LEVEL >= __LEVEL_INFO)); then
    Log::logMessage "${2:-HELP}" "$1"
  fi
}

# @description generate temp directory where default
# and overridden directories have been merged
#   - if overridden dir exists, create a new temp folder
#     - copy all files from default folder
#     - overwrite with files from overridden folder
#     - (Later) delete files listed in .remove$$ file
#     - return the path of this temp folder
#   - else just return the default folder path
# Then it is easier to pick overridden or default files/folders
#
# @arg $1 defaultDir:String usually the embed directory
# @arg $2 overriddenDirPath:String the path to the directory
#   that could be overridden
# @exitcode 1 if default dir does not exist
# @exitcode 2 if error during copy
Conf::getOverriddenDir() {
  local defaultDir="$1"
  local overriddenDirPath="$2"

  if [[ ! -d "${defaultDir}" ]]; then
    Log::displayError "Directory ${defaultDir} does not exists"
    return 1
  fi
  if [[ ! -d "${overriddenDirPath}" || -z "$(ls -A "${overriddenDirPath}")" ]]; then
    Log::displayInfo "Conf::getOverriddenDir - directory ${overriddenDirPath} does not exist, keep default one ${defaultDir}"
    echo "${defaultDir}"
    return 0
  fi
  local tempDir
  tempDir="$(mktemp -d)"
  (
    shopt -s dotglob
    cp -R "${defaultDir}/." "${tempDir}"
    cp -R "${overriddenDirPath}/." "${tempDir}"
  ) || return 2
  echo "${tempDir}"
}

# @description install dir to given directory but backup it before
# @arg $1 fromDir:String the source base directory
# @arg $2 toDir:String the target base directory
# @env OVERWRITE_CONFIG_FILES Boolean (default:0) if 1 will overwrite existing files
# @env CHANGE_WINDOWS_FILES Boolean (default:0) if 1 and target directory is in windows file system, overwrite it
# @env USERNAME (default: ${USERNAME} if SUDO empty else root) the user name that will be used to set target files ownership
# @env USERGROUP (default: ${USERGROUP} if SUDO empty else root) the group name that will be used to set target files ownership
# @env BASE_MNT_C String windows C drive base PATH
# @env PRETTY_ROOT_DIR used to make paths relative to this directory to reduce length of messages
# @env SUDO String allows to use custom sudo prefix command
# @env BACKUP_BEFORE_INSTALL Boolean (default:1) backup directory before installing the dir
# @exitcode 1 if source directory is not readable
# @exitcode 2 if error during structure replication
# @exitcode 2 if error during file copy
# @exitcode 0 if copy successful
# @exitcode 0 with warning message if CHANGE_WINDOWS_FILES=0 and target directory in C drive
# @stderr diagnostics information is displayed, skipped information if OVERWRITE_CONFIG_FILES or CHANGE_WINDOWS_FILES are set to 1
Install::structure() {
  local fromDir="$1"
  local toDir="$2"
  local userName="root"
  local userGroup="root"
  if [[ -z "${SUDO:-}" ]]; then
    userName="${USERNAME:-root}"
    userGroup="${USERGROUP:-root}"
  fi

  if [[ ! -d "${fromDir}" || ! -r "${fromDir}" ]]; then
    Log::displayError "Install::structure - cannot read source directory '${fromDir}'"
    return 1
  fi

  # skip if CHANGE_WINDOWS_FILES is 0 and target dir is c drive
  if [[ "${CHANGE_WINDOWS_FILES:-0}" = "0" && "${toDir}" =~ ^${BASE_MNT_C:-/mnt/c} ]]; then
    Log::displayWarning "Install::structure - Directory '${fromDir}' - Skip install (because CHANGE_WINDOWS_FILES=0 in .env file)"
    return 0
  fi

  # first replicate directory structure
  # shellcheck disable=SC2317
  createStructure() {
    local dir="$1"
    if ! ${SUDO} test -d "${dir}"; then
      if ! ${SUDO:-} mkdir -p "${dir}"; then
        Log::displayError "Install::structure - impossible to create directory '${dir}'"
        exit 1
      fi
    fi

    if ! ${SUDO:-} chown "${userName}":"${userGroup}" "${dir}"; then
      Log::displayError "Install::structure - impossible to update directory owner '${dir}' with ${userName}:${userGroup}"
      exit 1
    fi
  }
  local dir

  (
    local dir
    shopt -s lastpipe
    # -links 2 allows to exclude empty directories
    ${SUDO:-} find "${fromDir}" -depth -type d -links 2 -print0 |
      while read -rd '' dir; do
        if ! createStructure "${toDir}/${dir#"${fromDir}"}"; then
          # error already reported by createStructure
          exit 1
        fi
      done || {
      if [[ "${PIPESTATUS[0]}" != "0" ]]; then
        Log::displayError "Install::structure - replicated directory structure - find directories on '${fromDir}' resulted in an error"
        exit 2
      fi
    }
  ) || return 2

  # for each file, copy it
  (
    local file
    shopt -s lastpipe
    ${SUDO:-} find "${fromDir}" -depth -type f -print0 |
      while read -rd '' file; do
        local localFile="${file#"${fromDir}/"}"
        if ! Install::file "${fromDir}/${localFile}" "${toDir}/${localFile}"; then
          # error already reported by Install::file
          exit 1
        fi
      done || {
      if [[ "${PIPESTATUS[0]}" != "0" ]]; then
        Log::displayError "Install::structure - replicated file structure - find files on '${fromDir}' resulted in an error"
        exit 2
      fi
    }
  ) || return 3

  # shellcheck disable=SC2295
  Log::displaySuccess "Installed directory '${toDir#${PRETTY_ROOT_DIR}/}' from '${fromDir#${PRETTY_ROOT_DIR}/}'"
}

# @description install callback
#   set file with root ownership and execution bit
# @arg $1 fromFile:String
# @arg $2 targetFile:String
# @arg $3 userName:String (optional) (default: ${USERNAME}) the user name that will be used to set target files ownership
# @arg $4 userGroup:String (optional) (default: ${USERNAME}) the group name that will be used to set target files ownership
# @env USERNAME (default: root) the user name that will be used to set target files ownership
# @env USERGROUP (default: root) the group name that will be used to set target files ownership
# @env SUDO String allows to use custom sudo prefix command
# @exitcode 1 on any failure
# @see Install::file
Install::setUserRightsCallback() {
  # shellcheck disable=SC2034 # $1 not used
  local fromFile="$1"
  local targetFile="$2"
  local userName="${3:-${USERNAME:-root}}"
  local userGroup="${4:-${USERGROUP:-root}}"

  ${SUDO:-} chown "${userName}":"${userGroup}" "${targetFile}"
}

# @description install callback
#   default callback used called when file copy has failed
# @arg $1 fromFile:String
# @arg $2 targetFile:String
# @env FRAMEWORK_ROOT_DIR used to make paths relative to this directory to reduce length of messages
# @exitcode 1 always fail
# @stderr diagnostics information is displayed
# @see Install::file
Install::unableToCopyCallback() {
  local fromDir="$1"
  local fileName="$2"
  local targetFile="$3"
  Log::fatal "unable to copy file '${fromDir#"${FRAMEWORK_ROOT_DIR}/"}/${fileName}' to '${targetFile}'"
}

# @description Display message using info color (blue) but warning level
# @arg $1 message:String the message to display
Log::displayStatus() {
  local type="${2:-STATUS}"
  if ((BASH_FRAMEWORK_DISPLAY_LEVEL >= __LEVEL_WARNING)); then
    Log::computeDuration
    echo -e "${__INFO_COLOR}${type}  - ${LOG_CONTEXT:-}${LOG_LAST_DURATION_STR:-}${1}${__RESET_COLOR}" >&2
  fi
  Log::logStatus "$1" "${type}"
}

# @description Backup given file in the same directory or in BACKUP_DIR directory
# backup file name is composed by following fields separated by -:
#   - if BACKUP_DIR is not empty then escaped dir name separated by @
#   - filename(without path)
#   - date with format %Y%m%d_%H:%M:%S (Eg: 20240326_14:45:08)
# @arg $1 file:String the file to backup
# @stderr messages about backup file location
# @env SUDO String allows to use custom sudo prefix command
# @env BACKUP_DIR if not set backup the file in the same directory as original file
# @exitcode 1 on copy failure
Backup::file() {
  local file="$1"
  if [[ -f "${file}" ]]; then
    local backupFile fileDirname escapedDirname
    fileDirname="${file%/*}"
    escapedDirname=${fileDirname/\//}      # remove first slash
    escapedDirname=${escapedDirname//\//@} # replace all slashes by @
    if [[ -z "${BACKUP_DIR:-}" ]]; then
      backupFile="${fileDirname}/${file##*/}-$(date +"%Y%m%d_%H:%M:%S")"
    else
      backupFile="${BACKUP_DIR}/${escapedDirname}@${file##*/}-$(date +"%Y%m%d_%H:%M:%S")"
    fi
    Log::displayInfo "Backup file '${file}' to ${backupFile}"
    ${SUDO:-} cp "${file}" "${backupFile}"
  fi
}

# @description Display message using success color (bg green/fg white)
# @arg $1 message:String the message to display
Log::displaySuccess() {
  if ((BASH_FRAMEWORK_DISPLAY_LEVEL >= __LEVEL_INFO)); then
    Log::computeDuration
    echo -e "${__SUCCESS_COLOR}SUCCESS - ${LOG_CONTEXT:-}${LOG_LAST_DURATION_STR:-}${1}${__RESET_COLOR}" >&2
  fi
  Log::logSuccess "$1"
}

# @description ensure command tar is available
# @exitcode 1 if tar command not available
# @stderr diagnostics information is displayed
Linux::requireTarCommand() {
  Assert::commandExists tar
}

# @description load color theme
# @noargs
# @env BASH_FRAMEWORK_THEME String theme to use
# @env LOAD_THEME int 0 to avoid loading theme
# @exitcode 0 always successful
UI::requireTheme() {
  if [[ "${LOAD_THEME:-1}" = "1" ]]; then
    UI::theme "${BASH_FRAMEWORK_THEME-default}"
  fi
}

# @description ensure linux distribution is ubuntu
# @exitcode 1 if linux distribution is not ubuntu
Linux::requireUbuntu() {
  if ! Array::contains "$(Linux::getDistributorId)" "ubuntu" "debian"; then
    Log::fatal "this script should be executed under Ubuntu or Debian OS"
  fi
}

# @description checks if variable name provided exists
# @arg $1 varName:String
# @exitcode 1 if variable doesn't exist
# @exitcode 2 if variable value empty
# @exitcode 3 if variable name invalid
# @see Assert::validVariableName
# @stderr diagnostics information is displayed
Assert::varExistsAndNotEmpty() {
  local varName="$1"
  if ! Assert::validVariableName "${varName}"; then
    Log::displayError "${varName} - invalid variable name"
    return 3
  fi
  if [[ -z "${!varName+unset}" ]]; then
    Log::displayError "${varName} - not defined"
    return 1
  elif [[ -z "${!varName}" ]]; then
    Log::displayError "${varName} - please provide a value"
    return 2
  fi
}

# @description check if an element is contained in an array
#
# @arg $1 needle:String
# @arg $@ array:String[]
# @exitcode 0 if found
# @exitcode 1 otherwise
# @example
#   Array::contains "${libPath}" "${__BASH_FRAMEWORK_IMPORTED_FILES[@]}"
Array::contains() {
  local element
  for element in "${@:2}"; do
    [[ "${element}" = "$1" ]] && return 0
  done
  return 1
}

# @description check if argument respects ldap login naming convention
# only using lowercase characters a-z
# @arg $1 ldapLogin:String
# @exitcode 1 if regexp not matches
Assert::ldapLogin() {
  [[ $1 =~ ^[a-z]+$ ]]
}

# @description check if argument respects 2 or more words separated by a space
# it supports accentuated characters and names with hyphen(-)
# @arg $1 firstNameLastName:String
# @exitcode 1 if regexp not matches
# @see https://regex101.com/r/JyyfOM/1
Assert::firstNameLastName() {
  local regexp="^[^ ]+([ ][^ ]+)+$"
  [[ $1 =~ ${regexp} ]]
}

# @description check if param is valid email address
# @warning it is a very simple check, no RFC validation
# @arg $1 emailAddress:String the full email address
# @exitcode 1 if invalid email address
Assert::emailAddress() {
  local expectedRegexp="^\S+@\S+$"

  [[ "$1" =~ ${expectedRegexp} ]]
}

# @description determine if the script is executed under WSL
# cspell:disable
# @example text
#   uname GitBash windows (with wsl) => MINGW64_NT-10.0 ZOXFL-6619QN2 2.10.0(0.325/5/3) 2018-06-13 23:34 x86_64 Msys
#   uname GitBash windows (wo wsl)   => MINGW64_NT-10.0 frsa02-j5cbkc2 2.9.0(0.318/5/3) 2018-01-12 23:37 x86_64 Msys
#   uname wsl => Linux ZOXFL-6619QN2 4.4.0-17134-Microsoft #112-Microsoft Thu Jun 07 22:57:00 PST 2018 x86_64 x86_64 x86_64 GNU/Linux
# cspell:enable
#
# @exitcode 1 on error
Assert::wsl() {
  [[ "$(uname -o)" = "GNU/Linux" ]]
}

# @description retrieve path from wslvar and then use wslpath to resolve it
# using cache (cache is refreshed every day)
# @arg $1 var:String the var to retrieve using wslvar
# @arg $@ args:String[] (optional) additional arguments to pass to wslvar
# @env WSL_TMPDIR String temp directory to store the wslpath cache (default value: TMPDIR), you can use PERSISTENT_TMPDIR instead
# @exitcode * if Linux::Wsl::originalWslpath cannot find the path or Linux::Wsl::originalWslvar cannot find the var
# @stderr diagnostics information is displayed
# @require Linux::Wsl::requireWsl
# @feature cache
Linux::Wsl::cachedWslpathFromWslVar2() {
  # shellcheck disable=SC2034
  local -n cachedWslpathFromWslVar2_value=$1
  shift || true
  local value
  Linux::Wsl::cachedWslvar2 value "$@"
  Linux::Wsl::cachedWslpath2 cachedWslpathFromWslVar2_value "${value}" || return 1
}

declare -Agx bash_tools_wslvar=()
# @description retrieve wslvar using cache (cache is refreshed every day)
# @arg $1 cachedWslvar2_var:&String the variable to set by reference if the value is found
# @arg $@ args:String[] arguments to pass to wslvar
# @env WSL_TMPDIR String temp directory to store the wslvar cache (default value: TMPDIR), you can use PERSISTENT_TMPDIR instead
# @exitcode * if Linux::Wsl::originalWslvar cannot find the variable
# @stderr diagnostics information is displayed
# @require Linux::Wsl::requireWsl
# @feature cache
Linux::Wsl::cachedWslvar2() {
  # shellcheck disable=SC2034
  local -n cachedWslvar2_var="$1"
  shift || true
  local -a args=("$@")
  local tempWslvarFile="${WSL_TMPDIR:-${PERSISTENT_TMPDIR:-/tmp}}/bash_tools_wslvar"
  local key
  key="$(Linux::Wsl::getKeyFromWslpathOptions "${args[@]}")"
  Cache::getPropertyValue2 \
    "${tempWslvarFile}" \
    bash_tools_wslvar \
    cachedWslvar2_var \
    "${key}" \
    Linux::Wsl::originalWslvar "${args[@]}"
}

# @description Display message using skip color (yellow)
# @arg $1 message:String the message to display
Log::displaySkipped() {
  if ((BASH_FRAMEWORK_DISPLAY_LEVEL >= __LEVEL_INFO)); then
    Log::computeDuration
    echo -e "${__SKIPPED_COLOR}SKIPPED - ${LOG_CONTEXT:-}${LOG_LAST_DURATION_STR:-}${1}${__RESET_COLOR}" >&2
  fi
  Log::logSkipped "$1"
}

# @description Display given text and complete the rest of the line with given character
# @arg $1 text:String text to display
# @arg $2 character:String (default:#) character to use to complete the line
UI::textLine() {
  local text="$1"
  local character="${2:-#}"
  ((textSize = ${#text}))
  ((fullWith = $(tput cols)))
  ((remainingWidth = $((fullWith - textSize))))
  echo -n "${text}"
  printf '%*s\n' "${remainingWidth}" '' | tr ' ' "${character}"
}

# @description default aggregateStats file Content
Stats::aggregateStatsInitialContent() {
  local appCount="$1"
  echo "count=0"
  echo "appCount=${appCount}"
  echo "error=0"
  echo "warning=0"
  echo "skipped=0"
  echo "help=0"
  echo "success=0"
  echo "duration=0"
  echo "statusSuccess=0"
}

# @description Retry a command 5 times with a delay of 15 seconds between each attempt
# @arg $@ command:String[] the command to run
# @exitcode 0 on success
# @exitcode 1 if max retries count reached
Retry::default() {
  Retry::parameterized 5 15 "" "$@"
}

# @description log message to file
# @arg $1 message:String the message to display
Log::logStatus() {
  if ((BASH_FRAMEWORK_LOG_LEVEL >= __LEVEL_WARNING)); then
    Log::logMessage "${2:-STATUS}" "$1"
  fi
}

# @description log message to file
# @arg $1 message:String the message to display
Log::logSuccess() {
  if ((BASH_FRAMEWORK_LOG_LEVEL >= __LEVEL_INFO)); then
    Log::logMessage "${2:-SUCCESS}" "$1"
  fi
}

# @description retrieve linux distributor id
# @noargs
# @exitcode 1 if lsb_release fails or not found
# @stdout the linux distributor id
Linux::getDistributorId() {
  (
    source /etc/os-release
    echo "${ID}"
  )
}

# @description check if argument respects this framework variable naming convention
# - if variable begins with an uppercase or underscore, following letters have to be uppercase or underscore
# - variable name can includes ':' or '_' or digits but not as first letter
# here valid variable name examples
#
# @arg $1 variableName:String
# @exitcode 1 if regexp not matches
# @see https://regex101.com/r/BUlPXS/1
Assert::validVariableName() {
  [[ "$1" =~ (^[a-z][A-Za-z_0-9:]+$)|(^[A-Z_][A-Z_0-9:]+$) ]]
}

declare -Agx bash_tools_wslpath=()
# @description retrieve wslpath using cache (cache is refreshed every day)
# @arg $@ args:String[] arguments to pass to wslpath
# @env WSL_TMPDIR String temp directory to store the wslpath cache (default value: TMPDIR), you can use PERSISTENT_TMPDIR instead
# @exitcode * if Linux::Wsl::originalWslpath cannot find the path
# @stderr diagnostics information is displayed
# @require Linux::Wsl::requireWsl
# @feature cache
Linux::Wsl::cachedWslpath2() {
  # shellcheck disable=SC2034
  local -n cachedWslpath2_value=$1
  shift || true
  local tempEnvFile key
  tempEnvFile="${WSL_TMPDIR:-${PERSISTENT_TMPDIR:-/tmp}}/bash_tools_wslpath"

  key="$(Linux::Wsl::getKeyFromWslpathOptions "$@")"
  Cache::getPropertyValue2 \
    "${tempEnvFile}" \
    bash_tools_wslpath \
    cachedWslpath2_value \
    "${key}" \
    Linux::Wsl::originalWslpath "$@"
}

# @description Compute a cache from wslpath options
# @arg $@ args:String[] arguments passed to wslpath
# @stderr diagnostics information is displayed
# @stdout the cache key deduced from the options
# @require Linux::Wsl::requireWsl
# @feature cache
# @internal
Linux::Wsl::getKeyFromWslpathOptions() {
  local options
  options=$(getopt -o "auwm" -- "$@" 2>/dev/null) || {
    Log::displayError "invalid options specified"
    return 1
  }
  local key="wslpath"
  eval set -- "${options}"
  while true; do
    case "$1" in
      -a | -u | -w | -m)
        key="${key}$1"
        ;;
      --)
        shift || true
        break
        ;;
      *)
        shift || true
        Log::displayWarning "Unknown key $1"
        ;;
    esac
    shift || true
  done
  key="${key}_$1"
  # replace some characters \:/
  key="${key//\\//}"
  key="${key//:/_}"
  key="${key////_}"
  echo "${key}"
}

# @description get property value from file
# if not present compute it using propertyNotFoundCallback (if provided) and store it in property file
# @arg $1 propertyFile:String the file in which the property will be searched
# @arg $2 key:String the property key to search in property file
# @arg $3 propertyNotFoundCallback:Function (optional) a callback to call if property key is not found in property file
# @arg $@ args:String[] (optional) the arguments to pass to the propertyNotFoundCallback
# @exitcode 1 if value is not found
# @exitcode * if propertyNotFoundCallback fails
# @stdout the property value given by property file or by the propertyNotFoundCallback
Cache::getPropertyValue2() {
  local propertyFile="$1"
  local -n propertiesMap=$2
  local -n getPropertyValue2_val=$3
  local key="$4"
  local propertyNotFoundCallback=$5
  shift 5 || true
  local -a args=("$@")

  if [[ "${#propertiesMap[@]}" = "0" && -s "${propertyFile}" ]]; then
    local line
    while IFS="" read -r line; do
      if [[ "${line}" =~ ^([^=]+)=(.+)$ ]]; then
        propertiesMap["${BASH_REMATCH[1]}"]="${BASH_REMATCH[2]}"
      fi
    done <"${propertyFile}"
  fi

  if [[ -n "${propertiesMap[${key}]+abc}" ]]; then
    getPropertyValue2_val="${propertiesMap[${key}]}"
    return 0
  elif [[ "$(type -t "${propertyNotFoundCallback}")" = "function" ]]; then
    getPropertyValue2_val="$("${propertyNotFoundCallback}" "${args[@]}")" || return $?
    propertiesMap["${key}"]="${getPropertyValue2_val}"
    echo "${key}=${getPropertyValue2_val}" >>"${propertyFile}"
    return 0
  fi
  return 1
}

# @description call simply original wslvar command
# @arg $@ args:String[] args to pass to wslvar
# @exitcode * wslvar exit code
# @stdout wslvar stdout
# @require Linux::Wsl::requireWsl
Linux::Wsl::originalWslvar() {
  wslvar "$@" | sed -z '$ s/[\r\n]$//'
}

# @description log message to file
# @arg $1 message:String the message to display
Log::logSkipped() {
  if ((BASH_FRAMEWORK_LOG_LEVEL >= __LEVEL_INFO)); then
    Log::logMessage "${2:-SKIPPED}" "$1"
  fi
}

# @description Retry a command several times depending on parameters
# @arg $1 maxRetries:int    $1 max retries
# @arg $2 delay:int between attempt
# @arg $3 message:String to display to describe the attempt
# @arg $@ rest of parameters, the command to run
# @exitcode 0 on success
# @exitcode 1 if max retries count reached
# @exitcode 2 if maxRetries invalid value
Retry::parameterized() {
  local maxRetries=$1
  shift || true
  local delayBetweenTries=$1
  shift || true
  local message="$1"
  shift || true
  local retriesCount=1
  if [[ "${maxRetries}" -lt 1 ]]; then
    Log::displayError "invalid maxRetry value"
    return 2
  fi

  while true; do
    Log::displayInfo "Attempt ${retriesCount}/${maxRetries}: ${message}"
    if "$@"; then
      break
    elif [[ "${retriesCount}" -lt "${maxRetries}" ]]; then
      Log::displayDebug "Command failed. Wait for ${delayBetweenTries} seconds"
      ((retriesCount++))
      sleep "${delayBetweenTries}"
    else
      Log::displayError "The command has failed after ${retriesCount} attempts."
      return 1
    fi
  done
  return 0
}

# @description ensure linux runs under wsl
# @env WSL_GARBAGE_COLLECT int 0 to disable garbage collect of cache files
# @exitcode 1 if linux does not run under wsl
Linux::Wsl::requireWsl() {
  Assert::wsl || return 1
  if [[ "${WSL_GARBAGE_COLLECT:-1}" = "1" ]]; then
    local tempEnvDir
    tempEnvDir="${WSL_TMPDIR:-${PERSISTENT_TMPDIR:-/tmp}}"
    File::garbageCollect "${tempEnvDir}/bash_tools_wslpath_${USER_ID:-$(id -un)}" "1"
    tempEnvDir="${WSL_TMPDIR:-${PERSISTENT_TMPDIR:-/tmp}}"
    File::garbageCollect "${tempEnvDir}/bash_tools_wslvar_${USER_ID:-$(id -un)}" "1"
  fi
}

# @description call simply original wslpath command
# @arg $@ args:String[] args to pass to wslpath
# @exitcode * wslpath exit code
# @stdout wslpath stdout
# @require Linux::Wsl::requireWsl
Linux::Wsl::originalWslpath() {
  wslpath "$@" | sed -z '$ s/[\r\n]$//'
}

# @description delete files older than n days in given path
# @warning use this function with caution as it will delete all files in given path without any prompt
# @arg $1 path:String the directory in which files will be deleted or the file to delete
# @arg $2 mtime:String expiration time in days (eg: 1 means 1 day) (default value: 1). Eg: +1 match files that have been accessed at least two days ago (rounding effect)
# @arg $3 maxdepth:int Descend at most levels (a non-negative integer) levels of directories below the starting-points. (default value: 1)
# @exitcode 1 if path not provided or empty
# @exitcode * find command failure code
# @stderr find output on error or diagnostics logs
# @see man find atime
File::garbageCollect() {
  local path="$1"
  local mtime="$2"
  local maxdepth="${3:-1}"

  if [[ -z "${path}" ]]; then
    return 1
  fi

  if [[ ! -e "${path}" ]]; then
    # path already removed
    return 0
  fi

  Log::displayInfo "Garbage collect files older than ${mtime} days in path ${path} with max depth ${maxdepth}"
  find "${path}" -depth -maxdepth "${maxdepth}" -type f -mtime "${mtime}" -print -delete
}

# FUNCTIONS

Compiler::Embed::extractDirFromBase64 "${TMPDIR:-/tmp}/conf_dir" "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"

declare -gx embed_dir_conf_dir="${TMPDIR:-/tmp}/conf_dir"
Compiler::Embed::extractFileFromBase64 "${PERSISTENT_TMPDIR:-/tmp}/0c229512d6ad87e541bb8bba4db63095/loadConfigFiles" "IyEvdXNyL2Jpbi9lbnYgYmFzaAojIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjCiMgR0VORVJBVEVEIEZBQ0FERSBGUk9NIGh0dHBzOi8vZ2l0aHViLmNvbS9mY2hhc3RhbmV0L2Jhc2gtZGV2LWVudi90cmVlL21hc3Rlci9zcmMvX2JpbmFyaWVzL190b29scy9sb2FkQ29uZmlnRmlsZXMuc2gKIyBETyBOT1QgRURJVCBJVAojIEBnZW5lcmF0ZWQKIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIwojIHNoZWxsY2hlY2sgZGlzYWJsZT1TQzIyODgsU0MyMDM0CiMgQklOX0ZJTEU9JHtCQVNIX0RFVl9FTlZfUk9PVF9ESVJ9L2Jpbi9sb2FkQ29uZmlnRmlsZXMKIyBWQVJfUkVMQVRJVkVfRlJBTUVXT1JLX0RJUl9UT19DVVJSRU5UX0RJUj0KIyBWQVJfTE9BRF9SRVFVSVJFUz0wCiMgVkFSX0xPQURfQ09ORklHPTAKIyBGQUNBREUKCiMgZW5zdXJlIHRoYXQgbm8gdXNlciBhbGlhc2VzIGNvdWxkIGludGVyZmVyZSB3aXRoCiMgY29tbWFuZHMgdXNlZCBpbiB0aGlzIHNjcmlwdAp1bmFsaWFzIC1hIHx8IHRydWUKc2hvcHQgLXUgZXhwYW5kX2FsaWFzZXMKCiMgc2hlbGxjaGVjayBkaXNhYmxlPVNDMjAzNAooKGZhaWx1cmVzID0gMCkpIHx8IHRydWUKCiMgQmFzaCB3aWxsIHJlbWVtYmVyICYgcmV0dXJuIHRoZSBoaWdoZXN0IGV4aXQgY29kZSBpbiBhIGNoYWluIG9mIHBpcGVzLgojIFRoaXMgd2F5IHlvdSBjYW4gY2F0Y2ggdGhlIGVycm9yIGluc2lkZSBwaXBlcywgZS5nLiBteXNxbGR1bXAgfCBnemlwCnNldCAtbyBwaXBlZmFpbApzZXQgLW8gZXJyZXhpdAoKIyBDb21tYW5kIFN1YnN0aXR1dGlvbiBjYW4gaW5oZXJpdCBlcnJleGl0IG9wdGlvbiBzaW5jZSBiYXNoIHY0LjQKc2hvcHQgLXMgaW5oZXJpdF9lcnJleGl0IHx8IHRydWUKCiMgaWYgc2V0LCBhbmQgam9iIGNvbnRyb2wgaXMgbm90IGFjdGl2ZSwgdGhlIHNoZWxsIHJ1bnMgdGhlIGxhc3QgY29tbWFuZAojIG9mIGEgcGlwZWxpbmUgbm90IGV4ZWN1dGVkIGluIHRoZSBiYWNrZ3JvdW5kIGluIHRoZSBjdXJyZW50IHNoZWxsCiMgZW52aXJvbm1lbnQuCnNob3B0IC1zIGxhc3RwaXBlCgojIGEgbG9nIGlzIGdlbmVyYXRlZCB3aGVuIGEgY29tbWFuZCBmYWlscwpzZXQgLW8gZXJydHJhY2UKCiMgdXNlIG51bGxnbG9iIHNvIHRoYXQgKGZpbGUqLnBocCkgd2lsbCByZXR1cm4gYW4gZW1wdHkgYXJyYXkgaWYgbm8gZmlsZQojIG1hdGNoZXMgdGhlIHdpbGRjYXJkCnNob3B0IC1zIG51bGxnbG9iCgojIGVuc3VyZSByZWdleHAgYXJlIGludGVycHJldGVkIHdpdGhvdXQgYWNjZW50dWF0ZWQgY2hhcmFjdGVycwpleHBvcnQgTENfQUxMPVBPU0lYCgpleHBvcnQgVEVSTT14dGVybS0yNTZjb2xvcgoKIyBhdm9pZCBpbnRlcmFjdGl2ZSBpbnN0YWxsCmV4cG9ydCBERUJJQU5fRlJPTlRFTkQ9bm9uaW50ZXJhY3RpdmUKZXhwb3J0IERFQkNPTkZfTk9OSU5URVJBQ1RJVkVfU0VFTj10cnVlCgojIHN0b3JlIGNvbW1hbmQgYXJndW1lbnRzIGZvciBsYXRlciB1c2FnZQojIHNoZWxsY2hlY2sgZGlzYWJsZT1TQzIwMzQKZGVjbGFyZSAtYSBCQVNIX0ZSQU1FV09SS19BUkdWPSgiJEAiKQojIHNoZWxsY2hlY2sgZGlzYWJsZT1TQzIwMzQKZGVjbGFyZSAtYSBPUklHSU5BTF9CQVNIX0ZSQU1FV09SS19BUkdWPSgiJEAiKQoKIyBAc2VlIGh0dHBzOi8vdW5peC5zdGFja2V4Y2hhbmdlLmNvbS9hLzM4Njg1NgojIHNoZWxsY2hlY2sgZGlzYWJsZT1TQzIzMTcKaW50ZXJydXB0TWFuYWdlbWVudCgpIHsKICAjIHJlc3RvcmUgU0lHSU5UIGhhbmRsZXIKICB0cmFwIC0gSU5UCiAgIyBlbnN1cmUgdGhhdCBDdHJsLUMgaXMgdHJhcHBlZCBieSB0aGlzIHNjcmlwdCBhbmQgbm90IGJ5IHN1YiBwcm9jZXNzCiAgIyByZXBvcnQgdG8gdGhlIHBhcmVudCB0aGF0IHdlIGhhdmUgaW5kZWVkIGJlZW4gaW50ZXJydXB0ZWQKICBraWxsIC1zIElOVCAiJCQiCn0KdHJhcCBpbnRlcnJ1cHRNYW5hZ2VtZW50IElOVApTQ1JJUFRfTkFNRT0kezAjIyovfQpSRUFMX1NDUklQVF9GSUxFPSIkKHJlYWRsaW5rIC1lICIkKHJlYWxwYXRoICIke0JBU0hfU09VUkNFWzBdfSIpIikiCmlmIFtbIC1uICIke0VNQkVEX0NVUlJFTlRfRElSfSIgXV07IHRoZW4KICBDVVJSRU5UX0RJUj0iJHtFTUJFRF9DVVJSRU5UX0RJUn0iCmVsc2UKICBDVVJSRU5UX0RJUj0iJHtSRUFMX1NDUklQVF9GSUxFJS8qfSIKZmkKCiMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIwojIFRlbXAgZGlyIG1hbmFnZW1lbnQKIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjCgpLRUVQX1RFTVBfRklMRVM9IiR7S0VFUF9URU1QX0ZJTEVTOi0wfSIKZXhwb3J0IEtFRVBfVEVNUF9GSUxFUwoKIyBQRVJTSVNURU5UX1RNUERJUiBpcyBub3QgZGVsZXRlZCBieSB0cmFwcwpQRVJTSVNURU5UX1RNUERJUj0iJHtUTVBESVI6LS90bXB9L2Jhc2gtZnJhbWV3b3JrIgpleHBvcnQgUEVSU0lTVEVOVF9UTVBESVIKaWYgW1sgISAtZCAiJHtQRVJTSVNURU5UX1RNUERJUn0iIF1dOyB0aGVuCiAgbWtkaXIgLXAgIiR7UEVSU0lTVEVOVF9UTVBESVJ9IgpmaQoKIyBzaGVsbGNoZWNrIGRpc2FibGU9U0MyMDM0ClRNUERJUj0iJChta3RlbXAgLWQgLXAgIiR7UEVSU0lTVEVOVF9UTVBESVI6LS90bXB9IiAtdCBiYXNoLWZyYW1ld29yay0kJC1YWFhYWFgpIgpleHBvcnQgVE1QRElSCgojIHRlbXAgZGlyIGNsZWFuaW5nCiMgc2hlbGxjaGVjayBkaXNhYmxlPVNDMjMxNwpjbGVhbk9uRXhpdCgpIHsKICBsb2NhbCByYz0kPwogIGlmIFtbICIke0tFRVBfVEVNUF9GSUxFUzotMH0iID0gIjEiIF1dOyB0aGVuCiAgICBMb2c6OmRpc3BsYXlJbmZvICJLRUVQX1RFTVBfRklMRVM9MSB0ZW1wIGZpbGVzIGtlcHQgaGVyZSAnJHtUTVBESVJ9JyIKICBlbGlmIFtbIC1uICIke1RNUERJUit4eHh9IiBdXTsgdGhlbgogICAgTG9nOjpkaXNwbGF5RGVidWcgIktFRVBfVEVNUF9GSUxFUz0wIHJlbW92aW5nIHRlbXAgZmlsZXMgJyR7VE1QRElSfSciCiAgICBybSAtUmYgIiR7VE1QRElSOi0vdG1wL2Zha2V9IiA+L2Rldi9udWxsIDI+JjEKICBmaQogIGV4aXQgIiR7cmN9Igp9CnRyYXAgY2xlYW5PbkV4aXQgRVhJVCBIVVAgUVVJVCBBQlJUIFRFUk0KCiMgQGRlc2NyaXB0aW9uIExvZyBuYW1lc3BhY2UgcHJvdmlkZXMgMiBraW5kIG9mIGZ1bmN0aW9ucwojIC0gTG9nOjpkaXNwbGF5KiBhbGxvd3MgdG8gZGlzcGxheSBnaXZlbiBtZXNzYWdlIHdpdGgKIyAgIGdpdmVuIGRpc3BsYXkgbGV2ZWwKIyAtIExvZzo6bG9nKiBhbGxvd3MgdG8gbG9nIGdpdmVuIG1lc3NhZ2Ugd2l0aAojICAgZ2l2ZW4gbG9nIGxldmVsCiMgTG9nOjpkaXNwbGF5KiBmdW5jdGlvbnMgYXV0b21hdGljYWxseSBsb2cgdGhlIG1lc3NhZ2UgdG9vCiMgQHNlZSBFbnY6OnJlcXVpcmVMb2FkIHRvIGxvYWQgdGhlIGRpc3BsYXkgYW5kIGxvZyBsZXZlbCBmcm9tIC5lbnYgZmlsZQoKIyBAZGVzY3JpcHRpb24gbG9nIGxldmVsIG9mZgpleHBvcnQgX19MRVZFTF9PRkY9MAojIEBkZXNjcmlwdGlvbiBsb2cgbGV2ZWwgZXJyb3IKZXhwb3J0IF9fTEVWRUxfRVJST1I9MQojIEBkZXNjcmlwdGlvbiBsb2cgbGV2ZWwgd2FybmluZwpleHBvcnQgX19MRVZFTF9XQVJOSU5HPTIKIyBAZGVzY3JpcHRpb24gbG9nIGxldmVsIGluZm8KZXhwb3J0IF9fTEVWRUxfSU5GTz0zCiMgQGRlc2NyaXB0aW9uIGxvZyBsZXZlbCBzdWNjZXNzCmV4cG9ydCBfX0xFVkVMX1NVQ0NFU1M9MwojIEBkZXNjcmlwdGlvbiBsb2cgbGV2ZWwgZGVidWcKZXhwb3J0IF9fTEVWRUxfREVCVUc9NAoKIyBAZGVzY3JpcHRpb24gdmVyYm9zZSBsZXZlbCBvZmYKZXhwb3J0IF9fVkVSQk9TRV9MRVZFTF9PRkY9MAojIEBkZXNjcmlwdGlvbiB2ZXJib3NlIGxldmVsIGluZm8KZXhwb3J0IF9fVkVSQk9TRV9MRVZFTF9JTkZPPTEKIyBAZGVzY3JpcHRpb24gdmVyYm9zZSBsZXZlbCBpbmZvCmV4cG9ydCBfX1ZFUkJPU0VfTEVWRUxfREVCVUc9MgojIEBkZXNjcmlwdGlvbiB2ZXJib3NlIGxldmVsIGluZm8KZXhwb3J0IF9fVkVSQk9TRV9MRVZFTF9UUkFDRT0zCgojIEBkZXNjcmlwdGlvbiBEaXNwbGF5IG1lc3NhZ2UgdXNpbmcgaW5mbyBjb2xvciAoYmcgbGlnaHQgYmx1ZS9mZyB3aGl0ZSkKIyBAYXJnICQxIG1lc3NhZ2U6U3RyaW5nIHRoZSBtZXNzYWdlIHRvIGRpc3BsYXkKIyBAZW52IERJU1BMQVlfRFVSQVRJT04gaW50IChkZWZhdWx0IDApIGlmIDEgZGlzcGxheSBlbGFwc2VkIHRpbWUgaW5mb3JtYXRpb24gYmV0d2VlbiAyIGluZm8gbG9ncwpMb2c6OmRpc3BsYXlJbmZvKCkgewogIGxvY2FsIHR5cGU9IiR7MjotSU5GT30iCiAgaWYgKChCQVNIX0ZSQU1FV09SS19ESVNQTEFZX0xFVkVMID49IF9fTEVWRUxfSU5GTykpOyB0aGVuCiAgICBMb2c6OmNvbXB1dGVEdXJhdGlvbgogICAgZWNobyAtZSAiJHtfX0lORk9fQ09MT1J9JHt0eXBlfSAgICAtICR7TE9HX0NPTlRFWFQ6LX0ke0xPR19MQVNUX0RVUkFUSU9OX1NUUjotfSR7MX0ke19fUkVTRVRfQ09MT1J9IiA+JjIKICBmaQogIExvZzo6bG9nSW5mbyAiJDEiICIke3R5cGV9Igp9CgojIEBkZXNjcmlwdGlvbiBEaXNwbGF5IG1lc3NhZ2UgdXNpbmcgZGVidWcgY29sb3IgKGdyZXkpCiMgQGFyZyAkMSBtZXNzYWdlOlN0cmluZyB0aGUgbWVzc2FnZSB0byBkaXNwbGF5CkxvZzo6ZGlzcGxheURlYnVnKCkgewogIGlmICgoQkFTSF9GUkFNRVdPUktfRElTUExBWV9MRVZFTCA+PSBfX0xFVkVMX0RFQlVHKSk7IHRoZW4KICAgIExvZzo6Y29tcHV0ZUR1cmF0aW9uCiAgICBlY2hvIC1lICIke19fREVCVUdfQ09MT1J9REVCVUcgICAtICR7TE9HX0NPTlRFWFQ6LX0ke0xPR19MQVNUX0RVUkFUSU9OX1NUUjotfSR7MX0ke19fUkVTRVRfQ09MT1J9IiA+JjIKICBmaQogIExvZzo6bG9nRGVidWcgIiQxIgp9CgojIEBkZXNjcmlwdGlvbiBjaGVja3MgaWYgZnVuY3Rpb24gbmFtZSBwcm92aWRlZCBleGlzdHMKIyBAYXJnICQxIGZ1bmN0aW9uTmFtZTpTdHJpbmcKIyBAZXhpdGNvZGUgMSBpZiBmdW5jdGlvbiBuYW1lIGRvZXNuJ3QgZXhpc3QKQXNzZXJ0OjpmdW5jdGlvbkV4aXN0cygpIHsKICBkZWNsYXJlIC1GICIkMSIgPi9kZXYvbnVsbAp9CgojIEBkZXNjcmlwdGlvbiBlbnN1cmUgQ09NTUFORF9CSU5fRElSIGVudiB2YXIgaXMgc2V0CiMgYW5kIFBBVEggY29ycmVjdGx5IHByZXBhcmVkCiMgQG5vYXJncwojIEBzZXQgQ09NTUFORF9CSU5fRElSIHN0cmluZyB0aGUgZGlyZWN0b3J5IHdoZXJlIHRvIGZpbmQgdGhpcyBjb21tYW5kCiMgQHNldCBQQVRIIHN0cmluZyBhZGQgZGlyZWN0b3J5IHdoZXJlIHRvIGZpbmQgdGhpcyBjb21tYW5kIGJpbmFyeQpDb21waWxlcjo6RmFjYWRlOjpyZXF1aXJlQ29tbWFuZEJpbkRpcigpIHsKICBDT01NQU5EX0JJTl9ESVI9IiR7Q1VSUkVOVF9ESVJ9IgogIEVudjo6cGF0aFByZXBlbmQgIiR7Q09NTUFORF9CSU5fRElSfSIKfQoKZGVjbGFyZSAtZyBGSVJTVF9MT0dfREFURSBMT0dfTEFTVF9MT0dfREFURSBMT0dfTEFTVF9MT0dfREFURV9JTklUIExPR19MQVNUX0RVUkFUSU9OX1NUUgpGSVJTVF9MT0dfREFURT0iJHtFUE9DSFJFQUxUSU1FL1teMC05XS99IgpMT0dfTEFTVF9MT0dfREFURT0iJHtGSVJTVF9MT0dfREFURX0iCkxPR19MQVNUX0xPR19EQVRFX0lOSVQ9MQpMT0dfTEFTVF9EVVJBVElPTl9TVFI9IiIKCiMgQGRlc2NyaXB0aW9uIERpc3BsYXkgbWVzc2FnZSB1c2luZyBpbmZvIGNvbG9yIChiZyBsaWdodCBibHVlL2ZnIHdoaXRlKQojIEBhcmcgJDEgbWVzc2FnZTpTdHJpbmcgdGhlIG1lc3NhZ2UgdG8gZGlzcGxheQojIEBlbnYgRElTUExBWV9EVVJBVElPTiBpbnQgKGRlZmF1bHQgMCkgaWYgMSBkaXNwbGF5IGVsYXBzZWQgdGltZSBpbmZvcm1hdGlvbiBiZXR3ZWVuIDIgaW5mbyBsb2dzCkxvZzo6Y29tcHV0ZUR1cmF0aW9uKCkgewogIGlmICgoRElTUExBWV9EVVJBVElPTiA9PSAxKSk7IHRoZW4KICAgIGxvY2FsIC1pIGR1cmF0aW9uPTAKICAgIGxvY2FsIC1pIGRlbHRhPTAKICAgIGxvY2FsIC1pIGN1cnJlbnRMb2dEYXRlCiAgICBjdXJyZW50TG9nRGF0ZT0iJHtFUE9DSFJFQUxUSU1FL1teMC05XS99IgogICAgaWYgKChMT0dfTEFTVF9MT0dfREFURV9JTklUID09IDEpKTsgdGhlbgogICAgICBMT0dfTEFTVF9MT0dfREFURV9JTklUPTAKICAgICAgTE9HX0xBU1RfRFVSQVRJT05fU1RSPSJSZWYiCiAgICBlbHNlCiAgICAgIGR1cmF0aW9uPSQoKChjdXJyZW50TG9nRGF0ZSAtIEZJUlNUX0xPR19EQVRFKSAvIDEwMDAwMDApKQogICAgICBkZWx0YT0kKCgoY3VycmVudExvZ0RhdGUgLSBMT0dfTEFTVF9MT0dfREFURSkgLyAxMDAwMDAwKSkKICAgICAgTE9HX0xBU1RfRFVSQVRJT05fU1RSPSIke2R1cmF0aW9ufXMvKyR7ZGVsdGF9cyIKICAgIGZpCiAgICBMT0dfTEFTVF9MT0dfREFURT0iJHtjdXJyZW50TG9nRGF0ZX0iCiAgICAjIHNoZWxsY2hlY2sgZGlzYWJsZT1TQzIwMzQKICAgIGxvY2FsIG1pY3JvU2Vjb25kcz0iJHtFUE9DSFJFQUxUSU1FIyoufSIKICAgIExPR19MQVNUX0RVUkFUSU9OX1NUUj0iJChwcmludGYgJyUoJVQpVC4lMDMuMGZcbicgIiR7RVBPQ0hTRUNPTkRTfSIgIiR7bWljcm9TZWNvbmRzOjA6M30iKSgke0xPR19MQVNUX0RVUkFUSU9OX1NUUn0pIC0gIgogIGVsc2UKICAgICMgc2hlbGxjaGVjayBkaXNhYmxlPVNDMjAzNAogICAgTE9HX0xBU1RfRFVSQVRJT05fU1RSPSIiCiAgZmkKfQoKIyBAZGVzY3JpcHRpb24gbG9nIG1lc3NhZ2UgdG8gZmlsZQojIEBhcmcgJDEgbWVzc2FnZTpTdHJpbmcgdGhlIG1lc3NhZ2UgdG8gZGlzcGxheQpMb2c6OmxvZ0luZm8oKSB7CiAgaWYgKChCQVNIX0ZSQU1FV09SS19MT0dfTEVWRUwgPj0gX19MRVZFTF9JTkZPKSk7IHRoZW4KICAgIExvZzo6bG9nTWVzc2FnZSAiJHsyOi1JTkZPfSIgIiQxIgogIGZpCn0KCiMgQGRlc2NyaXB0aW9uIGxvZyBtZXNzYWdlIHRvIGZpbGUKIyBAYXJnICQxIG1lc3NhZ2U6U3RyaW5nIHRoZSBtZXNzYWdlIHRvIGRpc3BsYXkKTG9nOjpsb2dEZWJ1ZygpIHsKICBpZiAoKEJBU0hfRlJBTUVXT1JLX0xPR19MRVZFTCA+PSBfX0xFVkVMX0RFQlVHKSk7IHRoZW4KICAgIExvZzo6bG9nTWVzc2FnZSAiJHsyOi1ERUJVR30iICIkMSIKICBmaQp9CgojIEBkZXNjcmlwdGlvbiBwcmVwZW5kIGRpcmVjdG9yaWVzIHRvIHRoZSBQQVRIIGVudmlyb25tZW50IHZhcmlhYmxlCiMgQGFyZyAkQCBhcmdzOlN0cmluZ1tdIGxpc3Qgb2YgZGlyZWN0b3JpZXMgdG8gcHJlcGVuZAojIEBzZXQgUEFUSCB1cGRhdGUgUEFUSCB3aXRoIHRoZSBkaXJlY3RvcmllcyBwcmVwZW5kZWQKRW52OjpwYXRoUHJlcGVuZCgpIHsKICBsb2NhbCBhcmcKICBmb3IgYXJnIGluICIkQCI7IGRvCiAgICBpZiBbWyAtZCAiJHthcmd9IiAmJiAiOiR7UEFUSH06IiAhPSAqIjoke2FyZ306IiogXV07IHRoZW4KICAgICAgUEFUSD0iJChyZWFscGF0aCAiJHthcmd9Iik6JHtQQVRIfSIKICAgIGZpCiAgZG9uZQp9CgojIEBkZXNjcmlwdGlvbiBJbnRlcm5hbDogY29tbW9uIGxvZyBtZXNzYWdlCiMgQGV4YW1wbGUgdGV4dAojICAgW2RhdGVdfFtsZXZlbE1zZ118bWVzc2FnZQojCiMgQGV4YW1wbGUgdGV4dAojICAgMjAyMC0wMS0xOSAxOToyMDoyMXxFUlJPUiAgfGxvZyBlcnJvcgojICAgMjAyMC0wMS0xOSAxOToyMDoyMXxTS0lQUEVEfGxvZyBza2lwcGVkCiMKIyBAYXJnICQxIGxldmVsTXNnOlN0cmluZyBtZXNzYWdlJ3MgbGV2ZWwgZGVzY3JpcHRpb24gKGVnOiBTVEFUVVMsIEVSUk9SLCAuLi4pCiMgQGFyZyAkMiBtc2c6U3RyaW5nIHRoZSBtZXNzYWdlIHRvIGRpc3BsYXkKIyBAZW52IEJBU0hfRlJBTUVXT1JLX0xPR19GSUxFIFN0cmluZyBsb2cgZmlsZSB0byB1c2UsIGRvIG5vdGhpbmcgaWYgZW1wdHkKIyBAZW52IEJBU0hfRlJBTUVXT1JLX0xPR19MRVZFTCBpbnQgbG9nIGxldmVsIGxvZyBvbmx5IGlmID4gT0ZGIG9yIGZhdGFsIG1lc3NhZ2VzCiMgQHN0ZGVyciBkaWFnbm9zdGljcyBpbmZvcm1hdGlvbiBpcyBkaXNwbGF5ZWQKIyBAcmVxdWlyZSBFbnY6OnJlcXVpcmVMb2FkCiMgQHJlcXVpcmUgTG9nOjpyZXF1aXJlTG9hZApMb2c6OmxvZ01lc3NhZ2UoKSB7CiAgbG9jYWwgbGV2ZWxNc2c9IiQxIgogIGxvY2FsIG1zZz0iJDIiCiAgbG9jYWwgZGF0ZQoKICBpZiBbWyAtbiAiJHtCQVNIX0ZSQU1FV09SS19MT0dfRklMRX0iIF1dICYmICgoQkFTSF9GUkFNRVdPUktfTE9HX0xFVkVMID4gX19MRVZFTF9PRkYpKTsgdGhlbgogICAgZGF0ZT0iJChkYXRlICcrJVktJW0tJWQgJUg6JU06JVMnKSIKICAgIHRvdWNoICIke0JBU0hfRlJBTUVXT1JLX0xPR19GSUxFfSIKICAgIHByaW50ZiAiJXN8JTdzfCVzXG4iICIke2RhdGV9IiAiJHtsZXZlbE1zZ30iICIke21zZ30iID4+IiR7QkFTSF9GUkFNRVdPUktfTE9HX0ZJTEV9IgogIGZpCn0KCiMgQGRlc2NyaXB0aW9uIGVuc3VyZSBlbnYgZmlsZXMgYXJlIGxvYWRlZAojIEBhcmcgJEAgbGlzdCBvZiBkZWZhdWx0IGZpbGVzIHRvIGxvYWQgYXQgdGhlIGVuZAojIEBleGl0Y29kZSAxIGlmIG9uZSBvZiBlbnYgZmlsZXMgZmFpbHMgdG8gbG9hZAojIEBzdGRlcnIgZGlhZ25vc3RpY3MgaW5mb3JtYXRpb24gaXMgZGlzcGxheWVkCiMgc2hlbGxjaGVjayBkaXNhYmxlPVNDMjEyMApFbnY6OnJlcXVpcmVMb2FkKCkgewogIGxvY2FsIC1hIGRlZmF1bHRGaWxlcz0oIiRAIikKICAjIGdldCBsaXN0IG9mIHBvc3NpYmxlIGNvbmZpZyBmaWxlcwogIGxvY2FsIC1hIGNvbmZpZ0ZpbGVzPSgpCiAgaWYgW1sgLW4gIiR7QkFTSF9GUkFNRVdPUktfRU5WX0ZJTEVTWzBdKzF9IiBdXTsgdGhlbgogICAgIyBCQVNIX0ZSQU1FV09SS19FTlZfRklMRVMgaXMgYW4gYXJyYXkKICAgIGNvbmZpZ0ZpbGVzKz0oIiR7QkFTSF9GUkFNRVdPUktfRU5WX0ZJTEVTW0BdfSIpCiAgZmkKICBsb2NhbCBsb2NhbEZyYW1ld29ya0NvbmZpZ0ZpbGUKICBsb2NhbEZyYW1ld29ya0NvbmZpZ0ZpbGU9IiQocHdkKS8uZnJhbWV3b3JrLWNvbmZpZyIKICBpZiBbWyAtZiAiJHtsb2NhbEZyYW1ld29ya0NvbmZpZ0ZpbGV9IiBdXTsgdGhlbgogICAgY29uZmlnRmlsZXMrPSgiJHtsb2NhbEZyYW1ld29ya0NvbmZpZ0ZpbGV9IikKICBmaQogIGlmIFtbIC1mICIke0ZSQU1FV09SS19ST09UX0RJUn0vLmZyYW1ld29yay1jb25maWciIF1dOyB0aGVuCiAgICBjb25maWdGaWxlcys9KCIke0ZSQU1FV09SS19ST09UX0RJUn0vLmZyYW1ld29yay1jb25maWciKQogIGZpCiAgY29uZmlnRmlsZXMrPSgiJHtvcHRpb25FbnZGaWxlc1tAXX0iKQogIGNvbmZpZ0ZpbGVzKz0oIiR7ZGVmYXVsdEZpbGVzW0BdfSIpCgogIGZvciBmaWxlIGluICIke2NvbmZpZ0ZpbGVzW0BdfSI7IGRvCiAgICAjIHNoZWxsY2hlY2sgc291cmNlPS8uZnJhbWV3b3JrLWNvbmZpZwogICAgQ1VSUkVOVF9MT0FERURfRU5WX0ZJTEU9IiR7ZmlsZX0iIHNvdXJjZSAiJHtmaWxlfSIgfHwgewogICAgICBMb2c6OmRpc3BsYXlFcnJvciAid2hpbGUgbG9hZGluZyBjb25maWcgZmlsZTogJHtmaWxlfSIKICAgICAgcmV0dXJuIDEKICAgIH0KICBkb25lCn0KCiMgQGRlc2NyaXB0aW9uIGFjdGl2YXRlIG9yIG5vdCBMb2c6OmRpc3BsYXkqIGFuZCBMb2c6OmxvZyogZnVuY3Rpb25zCiMgYmFzZWQgb24gQkFTSF9GUkFNRVdPUktfRElTUExBWV9MRVZFTCBhbmQgQkFTSF9GUkFNRVdPUktfTE9HX0xFVkVMCiMgZW52aXJvbm1lbnQgdmFyaWFibGVzIGxvYWRlZCBieSBFbnY6OnJlcXVpcmVMb2FkCiMgdHJ5IHRvIGNyZWF0ZSBsb2cgZmlsZSBhbmQgcm90YXRlIGl0IGlmIG5lY2Vzc2FyeQojIEBub2FyZ3MKIyBAc2V0IEJBU0hfRlJBTUVXT1JLX0xPR19MRVZFTCBpbnQgdG8gT0ZGIGxldmVsIGlmIEJBU0hfRlJBTUVXT1JLX0xPR19GSUxFIGlzIGVtcHR5IG9yIG5vdCB3cml0YWJsZQojIEBlbnYgQkFTSF9GUkFNRVdPUktfRElTUExBWV9MRVZFTCBpbnQKIyBAZW52IEJBU0hfRlJBTUVXT1JLX0xPR19MRVZFTCBpbnQKIyBAZW52IEJBU0hfRlJBTUVXT1JLX0xPR19GSUxFIFN0cmluZwojIEBlbnYgQkFTSF9GUkFNRVdPUktfTE9HX0ZJTEVfTUFYX1JPVEFUSU9OIGludCBkbyBsb2cgcm90YXRpb24gaWYgPiAwCiMgQGV4aXRjb2RlIDAgYWx3YXlzIHN1Y2Nlc3NmdWwKIyBAc3RkZXJyIGRpYWdub3N0aWNzIGluZm9ybWF0aW9uIGFib3V0IGxvZyBmaWxlIGlzIGRpc3BsYXllZAojIEByZXF1aXJlIEVudjo6cmVxdWlyZUxvYWQKIyBAcmVxdWlyZSBVSTo6cmVxdWlyZVRoZW1lCkxvZzo6cmVxdWlyZUxvYWQoKSB7CiAgaWYgW1sgLXogIiR7QkFTSF9GUkFNRVdPUktfTE9HX0ZJTEU6LX0iIF1dOyB0aGVuCiAgICBCQVNIX0ZSQU1FV09SS19MT0dfTEVWRUw9JHtfX0xFVkVMX09GRn0KICAgIGV4cG9ydCBCQVNIX0ZSQU1FV09SS19MT0dfTEVWRUwKICBmaQoKICBpZiAoKEJBU0hfRlJBTUVXT1JLX0xPR19MRVZFTCA+IF9fTEVWRUxfT0ZGKSk7IHRoZW4KICAgIGlmIFtbICEgLWYgIiR7QkFTSF9GUkFNRVdPUktfTE9HX0ZJTEV9IiBdXTsgdGhlbgogICAgICBpZiBbWyAhIC1kICIke0JBU0hfRlJBTUVXT1JLX0xPR19GSUxFJS8qfSIgXV07IHRoZW4KICAgICAgICBpZiAhIG1rZGlyIC1wICIke0JBU0hfRlJBTUVXT1JLX0xPR19GSUxFJS8qfSIgMj4vZGV2L251bGw7IHRoZW4KICAgICAgICAgIEJBU0hfRlJBTUVXT1JLX0xPR19MRVZFTD0ke19fTEVWRUxfT0ZGfQogICAgICAgICAgZWNobyAtZSAiJHtfX0VSUk9SX0NPTE9SfUVSUk9SICAgLSBkaXJlY3RvcnkgJHtCQVNIX0ZSQU1FV09SS19MT0dfRklMRSUvKn0gaXMgbm90IHdyaXRhYmxlJHtfX1JFU0VUX0NPTE9SfSIgPiYyCiAgICAgICAgZmkKICAgICAgZWxpZiAhIHRvdWNoIC0tbm8tY3JlYXRlICIke0JBU0hfRlJBTUVXT1JLX0xPR19GSUxFfSIgMj4vZGV2L251bGw7IHRoZW4KICAgICAgICBCQVNIX0ZSQU1FV09SS19MT0dfTEVWRUw9JHtfX0xFVkVMX09GRn0KICAgICAgICBlY2hvIC1lICIke19fRVJST1JfQ09MT1J9RVJST1IgICAtIEZpbGUgJHtCQVNIX0ZSQU1FV09SS19MT0dfRklMRX0gaXMgbm90IHdyaXRhYmxlJHtfX1JFU0VUX0NPTE9SfSIgPiYyCiAgICAgIGZpCiAgICBlbGlmIFtbICEgLXcgIiR7QkFTSF9GUkFNRVdPUktfTE9HX0ZJTEV9IiBdXTsgdGhlbgogICAgICBCQVNIX0ZSQU1FV09SS19MT0dfTEVWRUw9JHtfX0xFVkVMX09GRn0KICAgICAgZWNobyAtZSAiJHtfX0VSUk9SX0NPTE9SfUVSUk9SICAgLSBGaWxlICR7QkFTSF9GUkFNRVdPUktfTE9HX0ZJTEV9IGlzIG5vdCB3cml0YWJsZSR7X19SRVNFVF9DT0xPUn0iID4mMgogICAgZmkKICBmaQoKICBpZiAoKEJBU0hfRlJBTUVXT1JLX0xPR19MRVZFTCA+IF9fTEVWRUxfT0ZGKSk7IHRoZW4KICAgICMgd2lsbCBhbHdheXMgYmUgY3JlYXRlZCBldmVuIGlmIG5vdCBpbiBpbmZvIGxldmVsCiAgICBMb2c6OmxvZ01lc3NhZ2UgIklORk8iICJMb2dnaW5nIHRvIGZpbGUgJHtCQVNIX0ZSQU1FV09SS19MT0dfRklMRX0gLSBMb2cgbGV2ZWwgJHtCQVNIX0ZSQU1FV09SS19MT0dfTEVWRUx9IgogICAgaWYgKChCQVNIX0ZSQU1FV09SS19MT0dfRklMRV9NQVhfUk9UQVRJT04gPiAwKSk7IHRoZW4KICAgICAgTG9nOjpyb3RhdGUgIiR7QkFTSF9GUkFNRVdPUktfTE9HX0ZJTEV9IiAiJHtCQVNIX0ZSQU1FV09SS19MT0dfRklMRV9NQVhfUk9UQVRJT059IgogICAgZmkKICBmaQp9CgojIEBkZXNjcmlwdGlvbiBEaXNwbGF5IG1lc3NhZ2UgdXNpbmcgZXJyb3IgY29sb3IgKHJlZCkKIyBAYXJnICQxIG1lc3NhZ2U6U3RyaW5nIHRoZSBtZXNzYWdlIHRvIGRpc3BsYXkKTG9nOjpkaXNwbGF5RXJyb3IoKSB7CiAgaWYgKChCQVNIX0ZSQU1FV09SS19ESVNQTEFZX0xFVkVMID49IF9fTEVWRUxfRVJST1IpKTsgdGhlbgogICAgTG9nOjpjb21wdXRlRHVyYXRpb24KICAgIGVjaG8gLWUgIiR7X19FUlJPUl9DT0xPUn1FUlJPUiAgIC0gJHtMT0dfQ09OVEVYVDotfSR7TE9HX0xBU1RfRFVSQVRJT05fU1RSOi19JHsxfSR7X19SRVNFVF9DT0xPUn0iID4mMgogIGZpCiAgTG9nOjpsb2dFcnJvciAiJDEiCn0KCiMgQGRlc2NyaXB0aW9uIFRvIGJlIGNhbGxlZCBiZWZvcmUgbG9nZ2luZyBpbiB0aGUgbG9nIGZpbGUKIyBAYXJnICQxIGZpbGU6c3RyaW5nIGxvZyBmaWxlIG5hbWUKIyBAYXJnICQyIG1heExvZ0ZpbGVzQ291bnQ6aW50IG1heGltdW0gbnVtYmVyIG9mIGxvZyBmaWxlcwpMb2c6OnJvdGF0ZSgpIHsKICBsb2NhbCBmaWxlPSIkMSIKICBsb2NhbCBtYXhMb2dGaWxlc0NvdW50PSIkezI6LTV9IgoKICBpZiBbWyAhIC1mICIke2ZpbGV9IiBdXTsgdGhlbgogICAgTG9nOjpkaXNwbGF5RGVidWcgIkxvZyBmaWxlICR7ZmlsZX0gZG9lc24ndCBleGlzdCB5ZXQiCiAgICByZXR1cm4gMAogIGZpCiAgbG9jYWwgaQogIGZvciAoKGkgPSBtYXhMb2dGaWxlc0NvdW50IC0gMTsgaSA+IDA7IGktLSkpOyBkbwogICAgTG9nOjpkaXNwbGF5SW5mbyAiTG9nIHJvdGF0aW9uICR7ZmlsZX0uJHtpfSB0byAke2ZpbGV9LiQoKGkgKyAxKSkiCiAgICBtdiAiJHtmaWxlfS4ieyIke2l9IiwiJCgoaSArIDEpKSJ9ICY+L2Rldi9udWxsIHx8IHRydWUKICBkb25lCiAgaWYgY3AgIiR7ZmlsZX0iICIke2ZpbGV9LjEiICY+L2Rldi9udWxsOyB0aGVuCiAgICBlY2hvID4iJHtmaWxlfSIgIyByZXNldCBsb2cgZmlsZQogICAgTG9nOjpkaXNwbGF5SW5mbyAiTG9nIHJvdGF0aW9uICR7ZmlsZX0gdG8gJHtmaWxlfS4xIgogIGZpCn0KCiMgQGRlc2NyaXB0aW9uIGxvYWQgY29sb3IgdGhlbWUKIyBAbm9hcmdzCiMgQGVudiBCQVNIX0ZSQU1FV09SS19USEVNRSBTdHJpbmcgdGhlbWUgdG8gdXNlCiMgQGVudiBMT0FEX1RIRU1FIGludCAwIHRvIGF2b2lkIGxvYWRpbmcgdGhlbWUKIyBAZXhpdGNvZGUgMCBhbHdheXMgc3VjY2Vzc2Z1bApVSTo6cmVxdWlyZVRoZW1lKCkgewogIGlmIFtbICIke0xPQURfVEhFTUU6LTF9IiA9ICIxIiBdXTsgdGhlbgogICAgVUk6OnRoZW1lICIke0JBU0hfRlJBTUVXT1JLX1RIRU1FLWRlZmF1bHR9IgogIGZpCn0KCiMgQGRlc2NyaXB0aW9uIGxvZyBtZXNzYWdlIHRvIGZpbGUKIyBAYXJnICQxIG1lc3NhZ2U6U3RyaW5nIHRoZSBtZXNzYWdlIHRvIGRpc3BsYXkKTG9nOjpsb2dFcnJvcigpIHsKICBpZiAoKEJBU0hfRlJBTUVXT1JLX0xPR19MRVZFTCA+PSBfX0xFVkVMX0VSUk9SKSk7IHRoZW4KICAgIExvZzo6bG9nTWVzc2FnZSAiJHsyOi1FUlJPUn0iICIkMSIKICBmaQp9CgojIEBkZXNjcmlwdGlvbiBsb2FkIGNvbG9ycyB0aGVtZSBjb25zdGFudHMKIyBAd2FybmluZyBpZiB0dHkgbm90IG9wZW5lZCwgbm9Db2xvciB0aGVtZSB3aWxsIGJlIGNob3NlbgojIEBhcmcgJDEgdGhlbWU6U3RyaW5nIHRoZSB0aGVtZSB0byB1c2UgKGRlZmF1bHQsIG5vQ29sb3IpCiMgQGFyZyAkQCBhcmdzOlN0cmluZ1tdCiMgQHNldCBfX0VSUk9SX0NPTE9SIFN0cmluZyBpbmRpY2F0ZSBlcnJvciBzdGF0dXMKIyBAc2V0IF9fSU5GT19DT0xPUiBTdHJpbmcgaW5kaWNhdGUgaW5mbyBzdGF0dXMKIyBAc2V0IF9fU1VDQ0VTU19DT0xPUiBTdHJpbmcgaW5kaWNhdGUgc3VjY2VzcyBzdGF0dXMKIyBAc2V0IF9fV0FSTklOR19DT0xPUiBTdHJpbmcgaW5kaWNhdGUgd2FybmluZyBzdGF0dXMKIyBAc2V0IF9fU0tJUFBFRF9DT0xPUiBTdHJpbmcgaW5kaWNhdGUgc2tpcHBlZCBzdGF0dXMKIyBAc2V0IF9fREVCVUdfQ09MT1IgU3RyaW5nIGluZGljYXRlIGRlYnVnIHN0YXR1cwojIEBzZXQgX19IRUxQX0NPTE9SIFN0cmluZyBpbmRpY2F0ZSBoZWxwIHN0YXR1cwojIEBzZXQgX19URVNUX0NPTE9SIFN0cmluZyBub3QgdXNlZAojIEBzZXQgX19URVNUX0VSUk9SX0NPTE9SIFN0cmluZyBub3QgdXNlZAojIEBzZXQgX19IRUxQX1RJVExFX0NPTE9SIFN0cmluZyB1c2VkIHRvIGRpc3BsYXkgaGVscCB0aXRsZSBpbiBoZWxwIHN0cmluZ3MKIyBAc2V0IF9fSEVMUF9PUFRJT05fQ09MT1IgU3RyaW5nIHVzZWQgdG8gZGlzcGxheSBoaWdobGlnaHQgb3B0aW9ucyBpbiBoZWxwIHN0cmluZ3MKIwojIEBzZXQgX19SRVNFVF9DT0xPUiBTdHJpbmcgcmVzZXQgZGVmYXVsdCBjb2xvcgojCiMgQHNldCBfX0hFTFBfRVhBTVBMRSBTdHJpbmcgdG8gcmVtb3ZlCiMgQHNldCBfX0hFTFBfVElUTEUgU3RyaW5nIHRvIHJlbW92ZQojIEBzZXQgX19IRUxQX05PUk1BTCBTdHJpbmcgdG8gcmVtb3ZlCiMgc2hlbGxjaGVjayBkaXNhYmxlPVNDMjAzNApVSTo6dGhlbWUoKSB7CiAgbG9jYWwgdGhlbWU9IiR7MS1kZWZhdWx0fSIKICBpZiBbWyAhICIke3RoZW1lfSIgPX4gLWZvcmNlJCBdXSAmJiAhIEFzc2VydDo6dHR5OyB0aGVuCiAgICB0aGVtZT0ibm9Db2xvciIKICBmaQogIGNhc2UgIiR7dGhlbWV9IiBpbgogICAgZGVmYXVsdCB8IGRlZmF1bHQtZm9yY2UpCiAgICAgIHRoZW1lPSJkZWZhdWx0IgogICAgICA7OwogICAgbm9Db2xvcikgOzsKICAgICopCiAgICAgIExvZzo6ZmF0YWwgImludmFsaWQgdGhlbWUgcHJvdmlkZWQiCiAgICAgIDs7CiAgZXNhYwogIGlmIFtbICIke3RoZW1lfSIgPSAiZGVmYXVsdCIgXV07IHRoZW4KICAgIEJBU0hfRlJBTUVXT1JLX1RIRU1FPSJkZWZhdWx0IgogICAgIyBjaGVjayBjb2xvcnMgYXBwbGljYWJsZSBodHRwczovL21pc2MuZmxvZ2lzb2Z0LmNvbS9iYXNoL3RpcF9jb2xvcnNfYW5kX2Zvcm1hdHRpbmcKICAgIF9fRVJST1JfQ09MT1I9J1xlWzMxbScgICAgICAgICAjIFJlZAogICAgX19JTkZPX0NPTE9SPSdcZVs0NG0nICAgICAgICAgICMgd2hpdGUgb24gbGlnaHRCbHVlCiAgICBfX1NVQ0NFU1NfQ09MT1I9J1xlWzMybScgICAgICAgIyBHcmVlbgogICAgX19XQVJOSU5HX0NPTE9SPSdcZVszM20nICAgICAgICMgWWVsbG93CiAgICBfX1NLSVBQRURfQ09MT1I9J1xlWzMzbScgICAgICAgIyBZZWxsb3cKICAgIF9fREVCVUdfQ09MT1I9J1xlWzM3bScgICAgICAgICAjIEdyZXkKICAgIF9fSEVMUF9DT0xPUj0nXGVbNzs0OTszM20nICAgICAjIEJsYWNrIG9uIEdvbGQKICAgIF9fVEVTVF9DT0xPUj0nXGVbMTAwbScgICAgICAgICAjIExpZ2h0IG1hZ2VudGEKICAgIF9fVEVTVF9FUlJPUl9DT0xPUj0nXGVbNDFtJyAgICAjIHdoaXRlIG9uIHJlZAogICAgX19IRUxQX1RJVExFX0NPTE9SPSJcZVsxOzM3bSIgICMgQm9sZAogICAgX19IRUxQX09QVElPTl9DT0xPUj0iXGVbMTszNG0iICMgQmx1ZQogICAgIyBJbnRlcm5hbDogcmVzZXQgY29sb3IKICAgIF9fUkVTRVRfQ09MT1I9J1xlWzBtJyAjIFJlc2V0IENvbG9yCiAgICAjIHNoZWxsY2hlY2sgZGlzYWJsZT1TQzIxNTUsU0MyMDM0CiAgICBfX0hFTFBfRVhBTVBMRT0iJChlY2hvIC1lICJcZVsyOzk3bSIpIgogICAgIyBzaGVsbGNoZWNrIGRpc2FibGU9U0MyMTU1LFNDMjAzNAogICAgX19IRUxQX1RJVExFPSIkKGVjaG8gLWUgIlxlWzE7MzdtIikiCiAgICAjIHNoZWxsY2hlY2sgZGlzYWJsZT1TQzIxNTUsU0MyMDM0CiAgICBfX0hFTFBfTk9STUFMPSIkKGVjaG8gLWUgIlwwMzNbMG0iKSIKICBlbHNlCiAgICBCQVNIX0ZSQU1FV09SS19USEVNRT0ibm9Db2xvciIKICAgICMgY2hlY2sgY29sb3JzIGFwcGxpY2FibGUgaHR0cHM6Ly9taXNjLmZsb2dpc29mdC5jb20vYmFzaC90aXBfY29sb3JzX2FuZF9mb3JtYXR0aW5nCiAgICBfX0VSUk9SX0NPTE9SPScnCiAgICBfX0lORk9fQ09MT1I9JycKICAgIF9fU1VDQ0VTU19DT0xPUj0nJwogICAgX19XQVJOSU5HX0NPTE9SPScnCiAgICBfX1NLSVBQRURfQ09MT1I9JycKICAgIF9fREVCVUdfQ09MT1I9JycKICAgIF9fSEVMUF9DT0xPUj0nJwogICAgX19URVNUX0NPTE9SPScnCiAgICBfX1RFU1RfRVJST1JfQ09MT1I9JycKICAgIF9fSEVMUF9USVRMRV9DT0xPUj0nJwogICAgX19IRUxQX09QVElPTl9DT0xPUj0nJwogICAgIyBJbnRlcm5hbDogcmVzZXQgY29sb3IKICAgIF9fUkVTRVRfQ09MT1I9JycKICAgIF9fSEVMUF9FWEFNUExFPScnCiAgICBfX0hFTFBfVElUTEU9JycKICAgIF9fSEVMUF9OT1JNQUw9JycKICBmaQp9CgojIEBkZXNjcmlwdGlvbiBjaGVjayBpZiB0dHkgKGludGVyYWN0aXZlIG1vZGUpIGlzIGFjdGl2ZQojIEBub2FyZ3MKIyBAZXhpdGNvZGUgMSBpZiB0dHkgbm90IGFjdGl2ZQojIEBlbnYgTk9OX0lOVEVSQUNUSVZFIGlmIDEgY29uc2lkZXIgYXMgbm90IGludGVyYWN0aXZlIGV2ZW4gaWYgZW52aXJvbm1lbnQgaXMgaW50ZXJhY3RpdmUKIyBAZW52IElOVEVSQUNUSVZFIGlmIDEgY29uc2lkZXIgYXMgaW50ZXJhY3RpdmUgZXZlbiBpZiBlbnZpcm9ubWVudCBpcyBub3QgaW50ZXJhY3RpdmUKQXNzZXJ0Ojp0dHkoKSB7CiAgaWYgW1sgIiR7Tk9OX0lOVEVSQUNUSVZFOi0wfSIgPSAiMSIgXV07IHRoZW4KICAgIHJldHVybiAxCiAgZmkKICBpZiBbWyAiJHtJTlRFUkFDVElWRTotMH0iID0gIjEiIF1dOyB0aGVuCiAgICByZXR1cm4gMAogIGZpCiAgIyBjaGVjayBpZiBzdGRvdXQgb3Igc3RkZXJyIGlzIGNvbm5lY3RlZCB0byB0ZXJtaW5hbAogIFtbIC10IDEgfHwgLXQgMiBdXQp9CgojIEBkZXNjcmlwdGlvbiBEaXNwbGF5IG1lc3NhZ2UgdXNpbmcgZXJyb3IgY29sb3IgKHJlZCkgYW5kIGV4aXQgaW1tZWRpYXRlbHkgd2l0aCBlcnJvciBzdGF0dXMgMQojIEBhcmcgJDEgbWVzc2FnZTpTdHJpbmcgdGhlIG1lc3NhZ2UgdG8gZGlzcGxheQpMb2c6OmZhdGFsKCkgewogIExvZzo6Y29tcHV0ZUR1cmF0aW9uCiAgZWNobyAtZSAiJHtfX0VSUk9SX0NPTE9SfUZBVEFMICAgLSAke0xPR19DT05URVhUOi19JHtMT0dfTEFTVF9EVVJBVElPTl9TVFI6LX0kezF9JHtfX1JFU0VUX0NPTE9SfSIgPiYyCiAgTG9nOjpsb2dGYXRhbCAiJDEiCiAgZXhpdCAxCn0KCiMgQGRlc2NyaXB0aW9uIGxvZyBtZXNzYWdlIHRvIGZpbGUKIyBAYXJnICQxIG1lc3NhZ2U6U3RyaW5nIHRoZSBtZXNzYWdlIHRvIGRpc3BsYXkKTG9nOjpsb2dGYXRhbCgpIHsKICBMb2c6OmxvZ01lc3NhZ2UgIiR7MjotRkFUQUx9IiAiJDEiCn0KCiMgRlVOQ1RJT05TCgpmYWNhZGVfbWFpbl9sb2FkQ29uZmlnRmlsZXNzaCgpIHsKCmlmIEFzc2VydDo6ZnVuY3Rpb25FeGlzdHMgaW5pdEZhY2FkZTsgdGhlbgogIGluaXRGYWNhZGUKZmkKTE9BRF9MT0NBTEVfQ09ORklHPSIxIgoKIyBAcmVxdWlyZSBDb21waWxlcjo6RmFjYWRlOjpyZXF1aXJlQ29tbWFuZEJpbkRpcgoKZGVjbGFyZSBkaXI9IiQxIgppZiBbWyAhIC1kICIke2Rpcn0iIF1dOyB0aGVuCiAgcmV0dXJuIDEKZmkKc2hpZnQgfHwgdHJ1ZQpkZWNsYXJlIC1hIGV4dGVuc2lvbnM9KCIkQCIpCmlmICgoJHsjZXh0ZW5zaW9uc1tAXX0gPCAxKSk7IHRoZW4KICBleGl0IDIKZmkKZGVjbGFyZSAtYSBmaW5kQ21kPSgKICBmaW5kICIke2Rpcn0iIC1leGVjdXRhYmxlIC10eXBlICdmLGwnICcoJwopCmZvciBleHQgaW4gIiR7ZXh0ZW5zaW9uc1tAXX0iOyBkbwogIGZpbmRDbWQrPSgtbmFtZSBcKi4iJHtleHR9IiAtbykKZG9uZQp1bnNldCAnZmluZENtZFstMV0nCmZpbmRDbWQrPSgnKScgLXByaW50ZiAnJXBcbicpCgoiJHtmaW5kQ21kW0BdfSIgMj4vZGV2L251bGwgfCBhd2sgLXYgZXh0PSIkKHByaW50ZiAnJXN8JyAiJHtleHRlbnNpb25zW0BdfSIpIiAnCiAgQkVHSU4gewogICAgRlM9Ii4iOwogICAgc3BsaXQoZXh0LCBleHRBcnIsICJ8Iik7CiAgICBmb3IgKGkgaW4gZXh0QXJyKSB7CiAgICAgIGV4dEluZGV4W2V4dEFycltpXV0gPSBpOwogICAgfQogIH0KICBmdW5jdGlvbiBiYXNlbmFtZVdpdGhvdXRFeHRlbnNpb24oZmlsZSkgewogICAgc3ViKCIuKi8iLCAiIiwgZmlsZSkKICAgIHN1YigvXC5bXi5dKyQvLCAiIiwgZmlsZSkKICAgIHJldHVybiBmaWxlCiAgfQogIHsKICAgIGlmICgkTkYgaW4gZXh0SW5kZXgpIHsKICAgICAgZmlsZUJhc2U9YmFzZW5hbWVXaXRob3V0RXh0ZW5zaW9uKCQwKQogICAgICBwcmludCBmaWxlQmFzZSAiXHQiIGV4dEluZGV4WyRORl0gIlx0IiAkMDsKICAgIH0KICB9CicgfCBzb3J0IC10JCdcdCcgLWsxLDEgLWsyLDIgfCBjdXQgLWYzLQoKfQoKZmFjYWRlX21haW5fbG9hZENvbmZpZ0ZpbGVzc2ggIiRAIgo=" "755"

declare -gx embed_file_loadConfigFiles="${PERSISTENT_TMPDIR:-/tmp}/0c229512d6ad87e541bb8bba4db63095/loadConfigFiles"
Compiler::Embed::extractFileFromBase64 "${PERSISTENT_TMPDIR:-/tmp}/8537ff72412594780cf9f312e8925b1e/talkScript" "cGFyYW0oCiAgICBbUGFyYW1ldGVyKE1hbmRhdG9yeT0kdHJ1ZSwgUG9zaXRpb249MCldCiAgICBbc3RyaW5nXQogICAgJG1zZyA9ICcnCikKCkFkZC1UeXBlIC1Bc3NlbWJseU5hbWUgU3lzdGVtLnNwZWVjaAokc3BlYWsgPSBOZXctT2JqZWN0IFN5c3RlbS5TcGVlY2guU3ludGhlc2lzLlNwZWVjaFN5bnRoZXNpemVyCiRzcGVhay5TcGVhaygkbXNnKQo=" "644"

declare -gx embed_file_talkScript="${PERSISTENT_TMPDIR:-/tmp}/8537ff72412594780cf9f312e8925b1e/talkScript"

facade_main_ShellZshsh() {

# REQUIRES
Linux::requireTarCommand
Env::requireLoad
UI::requireTheme
Linux::requireUbuntu
Log::requireLoad
Linux::Wsl::requireWsl
Compiler::Facade::requireCommandBinDir

if Assert::functionExists initFacade; then
  initFacade
fi
LOAD_LOCALE_CONFIG="1"
Engine::Config::loadConfig
# @description create sudoer file and add traps to remove it at the end
# @arg $1 sudoerFile:String the file path to create
# @env USERNAME
# shellcheck disable=SC2317
local sudoerFile="${SUDOER_FILE_PREFIX}/etc/sudoers.d/bash-dev-env-no-password"
if [[ -f "${sudoerFile}" ]] || sudo test -f "${sudoerFile}"; then
  # sudoerFile probably already managed by parent script
  true
else
  cleanSudoer() {
    local rc=$?
    if [[ -f "${sudoerFile}" ]]; then
      ${SUDO:-sudo} rm -f "${sudoerFile}" || true
    fi
    exit "${rc}"
  }
  trap cleanSudoer EXIT HUP QUIT ABRT TERM

  Log::displayInfo "Creating sudoer file"
  echo "${USERNAME} ALL=(ALL) NOPASSWD: ALL" |
    ${SUDO:-sudo} tee "${sudoerFile}" >/dev/null
  ${SUDO:-sudo} chmod 0440 "${sudoerFile}"
fi

# @require Compiler::Facade::requireCommandBinDir
# ROOT_DIR_RELATIVE_TO_BIN_DIR=..
# FACADE
# IMPLEMENT InstallScripts::interface
# EMBED "${BASH_DEV_ENV_ROOT_DIR}/src/_binaries/ShellZsh/conf" as conf_dir
# EMBED "${BASH_DEV_ENV_ROOT_DIR}/bin/loadConfigFiles" as loadConfigFiles
# EMBED "${FRAMEWORK_ROOT_DIR}/src/UI/talk.ps1" as talkScript

declare -a BASH_FRAMEWORK_ARGV_FILTERED=()

copyrightCallback() {
  if [[ -z "${copyrightBeginYear}" ]]; then
    copyrightBeginYear="$(date +%Y)"
  fi
  echo "Copyright (c) ${copyrightBeginYear}-now Franois Chastanet"
}

# shellcheck disable=SC2317 # if function is overridden
updateArgListInfoVerboseCallback() {
  BASH_FRAMEWORK_ARGV_FILTERED+=(--verbose)
}
# shellcheck disable=SC2317 # if function is overridden
updateArgListDebugVerboseCallback() {
  BASH_FRAMEWORK_ARGV_FILTERED+=(-vv)
}
# shellcheck disable=SC2317 # if function is overridden
updateArgListTraceVerboseCallback() {
  BASH_FRAMEWORK_ARGV_FILTERED+=(-vvv)
}
# shellcheck disable=SC2317 # if function is overridden
updateArgListEnvFileCallback() { :; }
# shellcheck disable=SC2317 # if function is overridden
updateArgListLogLevelCallback() { :; }
# shellcheck disable=SC2317 # if function is overridden
updateArgListDisplayLevelCallback() { :; }
# shellcheck disable=SC2317 # if function is overridden
updateArgListNoColorCallback() {
  BASH_FRAMEWORK_ARGV_FILTERED+=(--no-color)
}
# shellcheck disable=SC2317 # if function is overridden
updateArgListThemeCallback() { :; }
# shellcheck disable=SC2317 # if function is overridden
updateArgListQuietCallback() { :; }

# shellcheck disable=SC2317 # if function is overridden
optionHelpCallback() {
  installScriptCommand help
  exit 0
}

# shellcheck disable=SC2317 # if function is overridden
optionVersionCallback() {
  echo "${SCRIPT_NAME} version 1.0"
  exit 0
}

# shellcheck disable=SC2317 # if function is overridden
optionEnvFileCallback() {
  local envFile="$2"
  Log::displayWarning "Command ${SCRIPT_NAME} - Option --env-file is deprecated and will be removed in the future"
  if [[ ! -f "${envFile}" || ! -r "${envFile}" ]]; then
    Log::displayError "Command ${SCRIPT_NAME} - Option --env-file - File '${envFile}' doesn't exist"
    exit 1
  fi
}

# shellcheck disable=SC2317 # if function is overridden
optionInfoVerboseCallback() {
  BASH_FRAMEWORK_ARGS_VERBOSE_OPTION='--verbose'
  BASH_FRAMEWORK_ARGS_VERBOSE=${__VERBOSE_LEVEL_INFO}
  echo "BASH_FRAMEWORK_DISPLAY_LEVEL=${__LEVEL_INFO}" >> "${overrideEnvFile}"
}

# shellcheck disable=SC2317 # if function is overridden
optionDebugVerboseCallback() {
  BASH_FRAMEWORK_ARGS_VERBOSE_OPTION='-vv'
  BASH_FRAMEWORK_ARGS_VERBOSE=${__VERBOSE_LEVEL_DEBUG}
  echo "BASH_FRAMEWORK_DISPLAY_LEVEL=${__LEVEL_DEBUG}" >> "${overrideEnvFile}"
}

# shellcheck disable=SC2317 # if function is overridden
optionTraceVerboseCallback() {
  BASH_FRAMEWORK_ARGS_VERBOSE_OPTION='-vvv'
  BASH_FRAMEWORK_ARGS_VERBOSE=${__VERBOSE_LEVEL_TRACE}
  echo "BASH_FRAMEWORK_DISPLAY_LEVEL=${__LEVEL_DEBUG}" >> "${overrideEnvFile}"
}

getLevel() {
  local levelName="$1"
  case "${levelName^^}" in
    OFF)
      echo "${__LEVEL_OFF}"
      ;;
    ERR | ERROR)
      echo "${__LEVEL_ERROR}"
      ;;
    WARN | WARNING)
      echo "${__LEVEL_WARNING}"
      ;;
    INFO)
      echo "${__LEVEL_INFO}"
      ;;
    DEBUG | TRACE)
      echo "${__LEVEL_DEBUG}"
      ;;
    *)
      Log::displayError "Command ${SCRIPT_NAME} - Invalid level ${level}"
      return 1
  esac
}

getVerboseLevel() {
  local levelName="$1"
  case "${levelName^^}" in
    OFF)
      echo "${__VERBOSE_LEVEL_OFF}"
      ;;
    ERR | ERROR | WARN | WARNING | INFO)
      echo "${__VERBOSE_LEVEL_INFO}"
      ;;
    DEBUG)
      echo "${__VERBOSE_LEVEL_DEBUG}"
      ;;
    TRACE)
      echo "${__VERBOSE_LEVEL_TRACE}"
      ;;
    *)
      Log::displayError "Command ${SCRIPT_NAME} - Invalid level ${level}"
      return 1
  esac
}

# shellcheck disable=SC2317 # if function is overridden
optionDisplayLevelCallback() {
  local level="$2"
  local logLevel verboseLevel
  logLevel="$(getLevel "${level}")"
  verboseLevel="$(getVerboseLevel "${level}")"
  BASH_FRAMEWORK_ARGS_VERBOSE=${verboseLevel}
  echo "BASH_FRAMEWORK_DISPLAY_LEVEL=${logLevel}" >> "${overrideEnvFile}"
}

# shellcheck disable=SC2317 # if function is overridden
optionLogLevelCallback() {
  local level="$2"
  local logLevel verboseLevel
  logLevel="$(getLevel "${level}")"
  verboseLevel="$(getVerboseLevel "${level}")"
  BASH_FRAMEWORK_ARGS_VERBOSE=${verboseLevel}
  echo "BASH_FRAMEWORK_LOG_LEVEL=${logLevel}" >> "${overrideEnvFile}"
}

# shellcheck disable=SC2317 # if function is overridden
optionLogFileCallback() {
  local logFile="$2"
  echo "BASH_FRAMEWORK_LOG_FILE='${logFile}'" >> "${overrideEnvFile}"
}

# shellcheck disable=SC2317 # if function is overridden
optionQuietCallback() {
  echo "BASH_FRAMEWORK_QUIET_MODE=1" >> "${overrideEnvFile}"
}

# shellcheck disable=SC2317 # if function is overridden
optionNoColorCallback() {
  UI::theme "noColor"
}

# shellcheck disable=SC2317 # if function is overridden
optionThemeCallback() {
  UI::theme "$2"
}

displayConfig() {
  echo "Config"
  UI::drawLine "-"
  local var
  while read -r var; do
    printf '%-40s = %s\n' "${var}" "$(declare -p "${var}" | sed -E -e 's/^[^=]+=(.*)/\1/')"
  done < <(typeset -p | awk 'match($3, "^(BASH_FRAMEWORK_[^=]+)=", m) { print m[1] }' | sort)
  exit 0
}

optionBashFrameworkConfigCallback() {
  if [[ ! -f "$2" ]]; then
    Log::fatal "Command ${SCRIPT_NAME} - Bash framework config file '$2' does not exists"
  fi
}

defaultFrameworkConfig="$(
  cat <<'EOF'
# copied from src/_includes/.framework-config.default
# shellcheck disable=SC2034

REAL_SCRIPT_FILE="${REAL_SCRIPT_FILE:-$(readlink -e "$(realpath "${BASH_SOURCE[0]}")")}"
FRAMEWORK_ROOT_DIR="${FRAMEWORK_ROOT_DIR:-${REAL_SCRIPT_FILE%/*/*}}"
FRAMEWORK_SRC_DIR="${FRAMEWORK_SRC_DIR:-${FRAMEWORK_ROOT_DIR}/src}"
FRAMEWORK_BIN_DIR="${FRAMEWORK_BIN_DIR:-${FRAMEWORK_ROOT_DIR}/bin}"
FRAMEWORK_VENDOR_DIR="${FRAMEWORK_VENDOR_DIR:-${FRAMEWORK_ROOT_DIR}/vendor}"
FRAMEWORK_VENDOR_BIN_DIR="${FRAMEWORK_VENDOR_BIN_DIR:-${FRAMEWORK_ROOT_DIR}/vendor/bin}"

# describe the functions that will be skipped from being imported
FRAMEWORK_FUNCTIONS_IGNORE_REGEXP="${FRAMEWORK_FUNCTIONS_IGNORE_REGEXP:-^(Namespace::functions|Functions::myFunction|Namespace::requireSomething|Acquire::ForceIPv4)$}"
# describe the files that do not contain function to be imported
NON_FRAMEWORK_FILES_REGEXP="${NON_FRAMEWORK_FILES_REGEXP:-(^bin/|.framework-config|.bats$|/testsData/|^manualTests/|/_.sh$|/ZZZ.sh$|/__all.sh$|^src/_binaries|^src/_includes|^src/batsHeaders.sh$|^src/_standalone)}"
# describe the files that are allowed to not have an associated bats file
BATS_FILE_NOT_NEEDED_REGEXP="${BATS_FILE_NOT_NEEDED_REGEXP:-(^bin/|.framework-config|.bats$|/testsData/|^manualTests/|/_.sh$|/ZZZ.sh$|/__all.sh$|^src/batsHeaders.sh$|^src/_includes)}"
# describe the files that are allowed to not have a function matching the filename
FRAMEWORK_FILES_FUNCTION_MATCHING_IGNORE_REGEXP="${FRAMEWORK_FILES_FUNCTION_MATCHING_IGNORE_REGEXP:-^bin/|^\.framework-config$|\.tpl$|/testsData/|^manualTests/|\.bats$}"
# Source directories
if [[ ! -v FRAMEWORK_SRC_DIRS ]]; then
  FRAMEWORK_SRC_DIRS=(
    "${FRAMEWORK_ROOT_DIR}/src"
  )
fi

# export here all the variables that will be used in your templates
export REPOSITORY_URL="${REPOSITORY_URL:-https://github.com/fchastanet/bash-tools-framework}"

BASH_FRAMEWORK_THEME="${BASH_FRAMEWORK_THEME:-default}"
BASH_FRAMEWORK_LOG_LEVEL="${BASH_FRAMEWORK_LOG_LEVEL:-0}"
BASH_FRAMEWORK_DISPLAY_LEVEL="${BASH_FRAMEWORK_DISPLAY_LEVEL:-3}"
BASH_FRAMEWORK_LOG_FILE="${BASH_FRAMEWORK_LOG_FILE:-${FRAMEWORK_ROOT_DIR}/logs/${0##*/}.log}"
BASH_FRAMEWORK_LOG_FILE_MAX_ROTATION="${BASH_FRAMEWORK_LOG_FILE_MAX_ROTATION:-5}"
EOF
)"

overrideEnvFile="$(Framework::createTempFile "overrideEnvFile")"

commandOptionParseFinished() {
  # load default template framework config
  defaultEnvFile="${PERSISTENT_TMPDIR}/.framework-config"
  echo "${defaultFrameworkConfig}" > "${defaultEnvFile}"
  local -a files=("${defaultEnvFile}")
  if [[ -f "${envFile}" ]]; then
    files+=("${envFile}")
  fi
  # shellcheck disable=SC2154
  if [[ -f "${optionBashFrameworkConfig}" ]]; then
    files+=("${optionBashFrameworkConfig}")
  fi
  files+=("${overrideEnvFile}")
  Env::requireLoad "${files[@]}"
  Log::requireLoad
  # shellcheck disable=SC2154
  if [[ "${optionConfig}" = "1" ]]; then
    displayConfig
  fi
}

export SKIP_INSTALL
export SKIP_CONFIGURE
export SKIP_TEST
export SKIP_DEPENDENCIES

installScriptCommand() {
  local options_parse_cmd="$1"
  shift || true

  if [[ "${options_parse_cmd}" = "parse" ]]; then
    SKIP_CONFIGURE="0"
    local -i options_parse_optionParsedCountSKIP_CONFIGURE
    ((options_parse_optionParsedCountSKIP_CONFIGURE = 0)) || true
    SKIP_INSTALL="0"
    local -i options_parse_optionParsedCountSKIP_INSTALL
    ((options_parse_optionParsedCountSKIP_INSTALL = 0)) || true
    SKIP_TEST="0"
    local -i options_parse_optionParsedCountSKIP_TEST
    ((options_parse_optionParsedCountSKIP_TEST = 0)) || true
    SKIP_DEPENDENCIES="0"
    local -i options_parse_optionParsedCountSKIP_DEPENDENCIES
    ((options_parse_optionParsedCountSKIP_DEPENDENCIES = 0)) || true
    local -i options_parse_optionParsedCountOptionBashFrameworkConfig
    ((options_parse_optionParsedCountOptionBashFrameworkConfig = 0)) || true
    optionConfig="0"
    local -i options_parse_optionParsedCountOptionConfig
    ((options_parse_optionParsedCountOptionConfig = 0)) || true
    optionInfoVerbose="0"
    local -i options_parse_optionParsedCountOptionInfoVerbose
    ((options_parse_optionParsedCountOptionInfoVerbose = 0)) || true
    optionDebugVerbose="0"
    local -i options_parse_optionParsedCountOptionDebugVerbose
    ((options_parse_optionParsedCountOptionDebugVerbose = 0)) || true
    optionTraceVerbose="0"
    local -i options_parse_optionParsedCountOptionTraceVerbose
    ((options_parse_optionParsedCountOptionTraceVerbose = 0)) || true
    optionNoColor="0"
    local -i options_parse_optionParsedCountOptionNoColor
    ((options_parse_optionParsedCountOptionNoColor = 0)) || true
    optionTheme="default"
    local -i options_parse_optionParsedCountOptionTheme
    ((options_parse_optionParsedCountOptionTheme = 0)) || true
    optionHelp="0"
    local -i options_parse_optionParsedCountOptionHelp
    ((options_parse_optionParsedCountOptionHelp = 0)) || true
    optionVersion="0"
    local -i options_parse_optionParsedCountOptionVersion
    ((options_parse_optionParsedCountOptionVersion = 0)) || true
    optionQuiet="0"
    local -i options_parse_optionParsedCountOptionQuiet
    ((options_parse_optionParsedCountOptionQuiet = 0)) || true
    local -i options_parse_optionParsedCountOptionLogLevel
    ((options_parse_optionParsedCountOptionLogLevel = 0)) || true
    local -i options_parse_optionParsedCountOptionLogFile
    ((options_parse_optionParsedCountOptionLogFile = 0)) || true
    local -i options_parse_optionParsedCountOptionDisplayLevel
    ((options_parse_optionParsedCountOptionDisplayLevel = 0)) || true
    # shellcheck disable=SC2034
    local -i options_parse_parsedArgIndex=0
    while (($# > 0)); do
      local options_parse_arg="$1"
      local argOptDefaultBehavior=0
      case "${options_parse_arg}" in
        # Option 1/18
        # Option SKIP_CONFIGURE --skip-config|--skip-configure|--skip-configuration variableType Boolean min 0 max 1 authorizedValues '' regexp ''
        --skip-config | --skip-configure | --skip-configuration)
          # shellcheck disable=SC2034
          SKIP_CONFIGURE="1"
          if ((options_parse_optionParsedCountSKIP_CONFIGURE >= 1)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
            return 1
          fi
          ((++options_parse_optionParsedCountSKIP_CONFIGURE))
          ;;
        # Option 2/18
        # Option SKIP_INSTALL --skip-install|--skip-installation variableType Boolean min 0 max 1 authorizedValues '' regexp ''
        --skip-install | --skip-installation)
          # shellcheck disable=SC2034
          SKIP_INSTALL="1"
          if ((options_parse_optionParsedCountSKIP_INSTALL >= 1)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
            return 1
          fi
          ((++options_parse_optionParsedCountSKIP_INSTALL))
          ;;
        # Option 3/18
        # Option SKIP_TEST --skip-test|--skip-tests variableType Boolean min 0 max 1 authorizedValues '' regexp ''
        --skip-test | --skip-tests)
          # shellcheck disable=SC2034
          SKIP_TEST="1"
          if ((options_parse_optionParsedCountSKIP_TEST >= 1)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
            return 1
          fi
          ((++options_parse_optionParsedCountSKIP_TEST))
          ;;
        # Option 4/18
        # Option SKIP_DEPENDENCIES --skip-dependencies|--skip-deps variableType Boolean min 0 max 1 authorizedValues '' regexp ''
        --skip-dependencies | --skip-deps)
          # shellcheck disable=SC2034
          SKIP_DEPENDENCIES="1"
          if ((options_parse_optionParsedCountSKIP_DEPENDENCIES >= 1)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
            return 1
          fi
          ((++options_parse_optionParsedCountSKIP_DEPENDENCIES))
          ;;
        # Option 5/18
        # Option optionBashFrameworkConfig --bash-framework-config variableType String min 0 max 1 authorizedValues '' regexp ''
        --bash-framework-config)
          shift
          if (($# == 0)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - a value needs to be specified"
            return 1
          fi
          if ((options_parse_optionParsedCountOptionBashFrameworkConfig >= 1)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
            return 1
          fi
          ((++options_parse_optionParsedCountOptionBashFrameworkConfig))
          # shellcheck disable=SC2034
          optionBashFrameworkConfig="$1"
          optionBashFrameworkConfigCallback "${options_parse_arg}" "${optionBashFrameworkConfig}"
          ;;
        # Option 6/18
        # Option optionConfig --config variableType Boolean min 0 max 1 authorizedValues '' regexp ''
        --config)
          # shellcheck disable=SC2034
          optionConfig="1"
          if ((options_parse_optionParsedCountOptionConfig >= 1)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
            return 1
          fi
          ((++options_parse_optionParsedCountOptionConfig))
          ;;
        # Option 7/18
        # Option optionInfoVerbose --verbose|-v variableType Boolean min 0 max 1 authorizedValues '' regexp ''
        --verbose | -v)
          # shellcheck disable=SC2034
          optionInfoVerbose="1"
          if ((options_parse_optionParsedCountOptionInfoVerbose >= 1)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
            return 1
          fi
          ((++options_parse_optionParsedCountOptionInfoVerbose))
          optionInfoVerboseCallback "${options_parse_arg}"
          updateArgListInfoVerboseCallback "${options_parse_arg}"
          ;;
        # Option 8/18
        # Option optionDebugVerbose -vv variableType Boolean min 0 max 1 authorizedValues '' regexp ''
        -vv)
          # shellcheck disable=SC2034
          optionDebugVerbose="1"
          if ((options_parse_optionParsedCountOptionDebugVerbose >= 1)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
            return 1
          fi
          ((++options_parse_optionParsedCountOptionDebugVerbose))
          optionDebugVerboseCallback "${options_parse_arg}"
          updateArgListDebugVerboseCallback "${options_parse_arg}"
          ;;
        # Option 9/18
        # Option optionTraceVerbose -vvv variableType Boolean min 0 max 1 authorizedValues '' regexp ''
        -vvv)
          # shellcheck disable=SC2034
          optionTraceVerbose="1"
          if ((options_parse_optionParsedCountOptionTraceVerbose >= 1)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
            return 1
          fi
          ((++options_parse_optionParsedCountOptionTraceVerbose))
          optionTraceVerboseCallback "${options_parse_arg}"
          updateArgListTraceVerboseCallback "${options_parse_arg}"
          ;;
        # Option 10/18
        # Option optionEnvFiles --env-file variableType StringArray min 0 max -1 authorizedValues '' regexp ''
        --env-file)
          shift
          if (($# == 0)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - a value needs to be specified"
            return 1
          fi
          ((++options_parse_optionParsedCountOptionEnvFiles))
          optionEnvFiles+=("$1")
          optionEnvFileCallback "${options_parse_arg}" "${optionEnvFiles[@]}"
          updateArgListEnvFileCallback "${options_parse_arg}" "${optionEnvFiles[@]}"
          ;;
        # Option 11/18
        # Option optionNoColor --no-color variableType Boolean min 0 max 1 authorizedValues '' regexp ''
        --no-color)
          # shellcheck disable=SC2034
          optionNoColor="1"
          if ((options_parse_optionParsedCountOptionNoColor >= 1)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
            return 1
          fi
          ((++options_parse_optionParsedCountOptionNoColor))
          optionNoColorCallback "${options_parse_arg}"
          updateArgListNoColorCallback "${options_parse_arg}"
          ;;
        # Option 12/18
        # Option optionTheme --theme variableType String min 0 max 1 authorizedValues 'default|default-force|noColor' regexp ''
        --theme)
          shift
          if (($# == 0)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - a value needs to be specified"
            return 1
          fi
          if [[ ! "$1" =~ default|default-force|noColor ]]; then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - value '$1' is not part of authorized values(default|default-force|noColor)"
            return 1
          fi
          if ((options_parse_optionParsedCountOptionTheme >= 1)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
            return 1
          fi
          ((++options_parse_optionParsedCountOptionTheme))
          # shellcheck disable=SC2034
          optionTheme="$1"
          optionThemeCallback "${options_parse_arg}" "${optionTheme}"
          updateArgListThemeCallback "${options_parse_arg}" "${optionTheme}"
          ;;
        # Option 13/18
        # Option optionHelp --help|-h variableType Boolean min 0 max 1 authorizedValues '' regexp ''
        --help | -h)
          # shellcheck disable=SC2034
          optionHelp="1"
          if ((options_parse_optionParsedCountOptionHelp >= 1)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
            return 1
          fi
          ((++options_parse_optionParsedCountOptionHelp))
          optionHelpCallback "${options_parse_arg}"
          ;;
        # Option 14/18
        # Option optionVersion --version variableType Boolean min 0 max 1 authorizedValues '' regexp ''
        --version)
          # shellcheck disable=SC2034
          optionVersion="1"
          if ((options_parse_optionParsedCountOptionVersion >= 1)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
            return 1
          fi
          ((++options_parse_optionParsedCountOptionVersion))
          optionVersionCallback "${options_parse_arg}"
          ;;
        # Option 15/18
        # Option optionQuiet --quiet|-q variableType Boolean min 0 max 1 authorizedValues '' regexp ''
        --quiet | -q)
          # shellcheck disable=SC2034
          optionQuiet="1"
          if ((options_parse_optionParsedCountOptionQuiet >= 1)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
            return 1
          fi
          ((++options_parse_optionParsedCountOptionQuiet))
          optionQuietCallback "${options_parse_arg}"
          updateArgListQuietCallback "${options_parse_arg}"
          ;;
        # Option 16/18
        # Option optionLogLevel --log-level variableType String min 0 max 1 authorizedValues 'OFF|ERR|ERROR|WARN|WARNING|INFO|DEBUG|TRACE' regexp ''
        --log-level)
          shift
          if (($# == 0)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - a value needs to be specified"
            return 1
          fi
          if [[ ! "$1" =~ OFF|ERR|ERROR|WARN|WARNING|INFO|DEBUG|TRACE ]]; then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - value '$1' is not part of authorized values(OFF|ERR|ERROR|WARN|WARNING|INFO|DEBUG|TRACE)"
            return 1
          fi
          if ((options_parse_optionParsedCountOptionLogLevel >= 1)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
            return 1
          fi
          ((++options_parse_optionParsedCountOptionLogLevel))
          # shellcheck disable=SC2034
          optionLogLevel="$1"
          optionLogLevelCallback "${options_parse_arg}" "${optionLogLevel}"
          updateArgListLogLevelCallback "${options_parse_arg}" "${optionLogLevel}"
          ;;
        # Option 17/18
        # Option optionLogFile --log-file variableType String min 0 max 1 authorizedValues '' regexp ''
        --log-file)
          shift
          if (($# == 0)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - a value needs to be specified"
            return 1
          fi
          if ((options_parse_optionParsedCountOptionLogFile >= 1)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
            return 1
          fi
          ((++options_parse_optionParsedCountOptionLogFile))
          # shellcheck disable=SC2034
          optionLogFile="$1"
          optionLogFileCallback "${options_parse_arg}" "${optionLogFile}"
          updateArgListLogFileCallback "${options_parse_arg}" "${optionLogFile}"
          ;;
        # Option 18/18
        # Option optionDisplayLevel --display-level variableType String min 0 max 1 authorizedValues 'OFF|ERR|ERROR|WARN|WARNING|INFO|DEBUG|TRACE' regexp ''
        --display-level)
          shift
          if (($# == 0)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - a value needs to be specified"
            return 1
          fi
          if [[ ! "$1" =~ OFF|ERR|ERROR|WARN|WARNING|INFO|DEBUG|TRACE ]]; then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - value '$1' is not part of authorized values(OFF|ERR|ERROR|WARN|WARNING|INFO|DEBUG|TRACE)"
            return 1
          fi
          if ((options_parse_optionParsedCountOptionDisplayLevel >= 1)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
            return 1
          fi
          ((++options_parse_optionParsedCountOptionDisplayLevel))
          # shellcheck disable=SC2034
          optionDisplayLevel="$1"
          optionDisplayLevelCallback "${options_parse_arg}" "${optionDisplayLevel}"
          updateArgListDisplayLevelCallback "${options_parse_arg}" "${optionDisplayLevel}"
          ;;
        -*)
          if [[ "${argOptDefaultBehavior}" = "0" ]]; then
            Log::displayError "Command ${SCRIPT_NAME} - Invalid option ${options_parse_arg}"
            return 1
          fi
          ;;
        *)
          if [[ "${argOptDefaultBehavior}" = "0" ]]; then
            Log::displayError "Command ${SCRIPT_NAME} - Argument - too much arguments provided"
            return 1
          fi
          ;;
      esac
      shift || true
    done
    commandOptionParseFinished
    InstallScripts::command
    Log::displayDebug "Command ${SCRIPT_NAME} - parse arguments: ${BASH_FRAMEWORK_ARGV[*]}"
    Log::displayDebug "Command ${SCRIPT_NAME} - parse filtered arguments: ${BASH_FRAMEWORK_ARGV_FILTERED[*]}"
  elif [[ "${options_parse_cmd}" = "help" ]]; then
    Array::wrap2 ' ' 80 0 "\e[1;37mDESCRIPTION:\e[0m" "$(helpDescriptionCallback)"
    echo

    echo -e "$(Array::wrap2 " " 80 2 "${__HELP_TITLE_COLOR}USAGE:${__RESET_COLOR}" "${SCRIPT_NAME}" "[OPTIONS]")"
    echo -e "$(Array::wrap2 " " 80 2 "${__HELP_TITLE_COLOR}USAGE:${__RESET_COLOR}" \
      "${SCRIPT_NAME}" \
      "[--skip-config|--skip-configure|--skip-configuration]" "[--skip-install|--skip-installation]" "[--skip-test|--skip-tests]" "[--skip-dependencies|--skip-deps]" "[--bash-framework-config <String>]" "[--config]" "[--verbose|-v]" "[-vv]" "[-vvv]" "[--env-file <String>]" "[--no-color]" "[--theme <String>]" "[--help|-h]" "[--version]" "[--quiet|-q]" "[--log-level <String>]" "[--log-file <String>]" "[--display-level <String>]")"
    echo
    echo -e "${__HELP_TITLE_COLOR}OPTIONS:${__RESET_COLOR}"
    echo -e "  ${__HELP_OPTION_COLOR}--skip-config${__HELP_NORMAL}, ${__HELP_OPTION_COLOR}--skip-configure${__HELP_NORMAL}, ${__HELP_OPTION_COLOR}--skip-configuration${__HELP_NORMAL} {single}"
    local -a helpArray
    # shellcheck disable=SC2054
    helpArray=(skip\ software\ configuration)
    echo -e "    $(Array::wrap2 " " 76 4 "${helpArray[@]}")"
    echo -e "  ${__HELP_OPTION_COLOR}--skip-install${__HELP_NORMAL}, ${__HELP_OPTION_COLOR}--skip-installation${__HELP_NORMAL} {single}"
    local -a helpArray
    # shellcheck disable=SC2054
    helpArray=(skip\ software\ installation)
    echo -e "    $(Array::wrap2 " " 76 4 "${helpArray[@]}")"
    echo -e "  ${__HELP_OPTION_COLOR}--skip-test${__HELP_NORMAL}, ${__HELP_OPTION_COLOR}--skip-tests${__HELP_NORMAL} {single}"
    local -a helpArray
    # shellcheck disable=SC2054
    helpArray=(skip\ software\ installation\ test)
    echo -e "    $(Array::wrap2 " " 76 4 "${helpArray[@]}")"
    echo -e "  ${__HELP_OPTION_COLOR}--skip-dependencies${__HELP_NORMAL}, ${__HELP_OPTION_COLOR}--skip-deps${__HELP_NORMAL} {single}"
    local -a helpArray
    # shellcheck disable=SC2054
    helpArray=(install\ the\ software\ requested\ without\ resolving\ dependencies)
    echo -e "    $(Array::wrap2 " " 76 4 "${helpArray[@]}")"
    echo
    echo -e "${__HELP_TITLE_COLOR}GLOBAL OPTIONS:${__RESET_COLOR}"
    echo -e "  ${__HELP_OPTION_COLOR}--bash-framework-config <String>${__HELP_NORMAL} {single}"
    local -a helpArray
    # shellcheck disable=SC2054
    helpArray=(use\ alternate\ bash\ framework\ configuration.)
    echo -e "    $(Array::wrap2 " " 76 4 "${helpArray[@]}")"
    echo -e "  ${__HELP_OPTION_COLOR}--config${__HELP_NORMAL} {single}"
    local -a helpArray
    # shellcheck disable=SC2054
    helpArray=(Display\ configuration)
    echo -e "    $(Array::wrap2 " " 76 4 "${helpArray[@]}")"
    echo -e "  ${__HELP_OPTION_COLOR}--verbose${__HELP_NORMAL}, ${__HELP_OPTION_COLOR}-v${__HELP_NORMAL} {single}"
    local -a helpArray
    # shellcheck disable=SC2054
    helpArray=(info\ level\ verbose\ mode\ \(alias\ of\ --display-level\ INFO\))
    echo -e "    $(Array::wrap2 " " 76 4 "${helpArray[@]}")"
    echo -e "  ${__HELP_OPTION_COLOR}-vv${__HELP_NORMAL} {single}"
    local -a helpArray
    # shellcheck disable=SC2054
    helpArray=(debug\ level\ verbose\ mode\ \(alias\ of\ --display-level\ DEBUG\))
    echo -e "    $(Array::wrap2 " " 76 4 "${helpArray[@]}")"
    echo -e "  ${__HELP_OPTION_COLOR}-vvv${__HELP_NORMAL} {single}"
    local -a helpArray
    # shellcheck disable=SC2054
    helpArray=(trace\ level\ verbose\ mode\ \(alias\ of\ --display-level\ TRACE\))
    echo -e "    $(Array::wrap2 " " 76 4 "${helpArray[@]}")"
    echo -e "  ${__HELP_OPTION_COLOR}--env-file <String>${__HELP_NORMAL} {list} (optional)"
    local -a helpArray
    # shellcheck disable=SC2054
    helpArray=(Load\ the\ specified\ env\ file\ \(deprecated\,\ please\ use\ --bash-framework-config\ option\ instead\))
    echo -e "    $(Array::wrap2 " " 76 4 "${helpArray[@]}")"
    echo -e "  ${__HELP_OPTION_COLOR}--no-color${__HELP_NORMAL} {single}"
    local -a helpArray
    # shellcheck disable=SC2054
    helpArray=(Produce\ monochrome\ output.\ alias\ of\ --theme\ noColor.)
    echo -e "    $(Array::wrap2 " " 76 4 "${helpArray[@]}")"
    echo -e "  ${__HELP_OPTION_COLOR}--theme <String>${__HELP_NORMAL} {single}"
    local -a helpArray
    # shellcheck disable=SC2054
    helpArray=(choose\ color\ theme\ -\ default-force\ means\ colors\ will\ be\ produced\ even\ if\ command\ is\ piped)
    echo -e "    $(Array::wrap2 " " 76 4 "${helpArray[@]}")"
    echo '    Default value: default'
    echo '    Possible values: default|default-force|noColor'
    echo -e "  ${__HELP_OPTION_COLOR}--help${__HELP_NORMAL}, ${__HELP_OPTION_COLOR}-h${__HELP_NORMAL} {single}"
    local -a helpArray
    # shellcheck disable=SC2054
    helpArray=(Display\ this\ command\ help)
    echo -e "    $(Array::wrap2 " " 76 4 "${helpArray[@]}")"
    echo -e "  ${__HELP_OPTION_COLOR}--version${__HELP_NORMAL} {single}"
    local -a helpArray
    # shellcheck disable=SC2054
    helpArray=(Print\ version\ information\ and\ quit)
    echo -e "    $(Array::wrap2 " " 76 4 "${helpArray[@]}")"
    echo -e "  ${__HELP_OPTION_COLOR}--quiet${__HELP_NORMAL}, ${__HELP_OPTION_COLOR}-q${__HELP_NORMAL} {single}"
    local -a helpArray
    # shellcheck disable=SC2054
    helpArray=(quiet\ mode\,\ doesn\'t\ display\ any\ output)
    echo -e "    $(Array::wrap2 " " 76 4 "${helpArray[@]}")"
    echo -e "  ${__HELP_OPTION_COLOR}--log-level <String>${__HELP_NORMAL} {single}"
    local -a helpArray
    # shellcheck disable=SC2054
    helpArray=(Set\ log\ level)
    echo -e "    $(Array::wrap2 " " 76 4 "${helpArray[@]}")"
    echo '    Possible values: OFF|ERR|ERROR|WARN|WARNING|INFO|DEBUG|TRACE'
    echo -e "  ${__HELP_OPTION_COLOR}--log-file <String>${__HELP_NORMAL} {single}"
    local -a helpArray
    # shellcheck disable=SC2054
    helpArray=(Set\ log\ file)
    echo -e "    $(Array::wrap2 " " 76 4 "${helpArray[@]}")"
    echo -e "  ${__HELP_OPTION_COLOR}--display-level <String>${__HELP_NORMAL} {single}"
    local -a helpArray
    # shellcheck disable=SC2054
    helpArray=(set\ display\ level)
    echo -e "    $(Array::wrap2 " " 76 4 "${helpArray[@]}")"
    echo '    Possible values: OFF|ERR|ERROR|WARN|WARNING|INFO|DEBUG|TRACE'
    Array::wrap2 ' ' 76 0 "$(helpLongDescriptionCallback)"
    echo
    echo -n -e "${__HELP_TITLE_COLOR}VERSION: ${__RESET_COLOR}"
    echo '1.0'
    echo
    echo -e "${__HELP_TITLE_COLOR}AUTHOR:${__RESET_COLOR}"
    echo '[Franois Chastanet](https://github.com/fchastanet)'
    echo
    echo -e "${__HELP_TITLE_COLOR}SOURCE FILE:${__RESET_COLOR}"
    echo 'https://github.com/fchastanet/bash-dev-env/tree/master/src/_binaries/ShellZsh/ShellZsh.sh'
    echo
    echo -e "${__HELP_TITLE_COLOR}LICENSE:${__RESET_COLOR}"
    echo 'MIT License'
    echo
    Array::wrap2 ' ' 76 4 "$(copyrightCallback)"
  else
    Log::displayError "Command ${SCRIPT_NAME} - Option command invalid: '${options_parse_cmd}'"
    return 1
  fi
}

# default action called by the facade if no interface action recognized
defaultFacadeAction() {
  installScriptCommand parse "${BASH_FRAMEWORK_ARGV[@]}"
}

stringOrNone() {
  local string="$1"
  echo -e "${string:-${__HELP_EXAMPLE}None${__HELP_NORMAL}}"
}

helpDescriptionCallback() {
  helpDescription
  echo
}

helpLongDescriptionCallback() {
  helpDescription
  echo

  echo -e "${__HELP_TITLE}List of needed variables:${__HELP_NORMAL}"
  stringOrNone "$(helpVariables)"

  echo -e "${__HELP_TITLE}List of dependencies:${__HELP_NORMAL}"
  stringOrNone "$(dependencies)"
}

isInstallImplemented() {
  ! InstallScripts::scriptFunctionEmpty install
}

isTestInstallImplemented() {
  ! InstallScripts::scriptFunctionEmpty testInstall
}

isConfigureImplemented() {
  ! InstallScripts::scriptFunctionEmpty configure
}

isTestConfigureImplemented() {
  ! InstallScripts::scriptFunctionEmpty testConfigure
}

fullScriptName() {
  File::relativeToDir "${REAL_SCRIPT_FILE}" "${BASH_DEV_ENV_ROOT_DIR}"
}

scriptName() {
  echo "ShellZsh"
}

helpDescription() {
  echo "Default Zsh configuration"
}

dependencies() {
  echo "installScripts/ShellBash"
}

listVariables() {
  echo "HOME"
  echo "USERNAME"
  echo "USERGROUP"
}

fortunes() {
  if [[ "${USER_SHELL}" = "/usr/bin/zsh" ]]; then
    echo -e "${__INFO_COLOR}$(scriptName)${__RESET_COLOR} -- Zsh ref card manual ${__HELP_EXAMPLE}<http://www.bash2zsh.com/zsh_refcard/refcard.pdf>${__RESET_COLOR}."
    echo "%"
    if [[ "${ZSH_PREFERRED_THEME:-${ZSH_DEFAULT_THEME}}" != "powerlevel10k/powerlevel10k" ]]; then
      echo -e "${__INFO_COLOR}$(scriptName)${__RESET_COLOR} -- ${__HELP_EXAMPLE}Powerlevel10k${__RESET_COLOR} - use the command ${__HELP_EXAMPLE}p10k configure${__RESET_COLOR} to customize shell prompt."
      echo "%"
    fi
  else
    if command -v zsh &>/dev/null; then
      echo -e "${__INFO_COLOR}$(scriptName)${__RESET_COLOR} -- ${__HELP_EXAMPLE}${USER_SHELL}${__RESET_COLOR} is set as default shell, you can switch to zsh using ${__HELP_EXAMPLE}chsh -s /usr/bin/zsh${__RESET_COLOR}."
      echo "%"
    else
      echo -e "${__INFO_COLOR}$(scriptName)${__RESET_COLOR} -- ${__HELP_EXAMPLE}Zsh${__RESET_COLOR} is not set as your default shell, you can give it a try using ${__HELP_EXAMPLE}installAndConfigure ZshProfile${__RESET_COLOR}."
      echo "%"
    fi
  fi
}

# jscpd:ignore-start
helpVariables() { :; }
defaultVariables() { :; }
checkVariables() { :; }
breakOnConfigFailure() { :; }
breakOnTestFailure() { :; }
# jscpd:ignore-end

install() {
  local -a packages=(
    zsh
    # needed by some zinit packages
    subversion
  )
  Linux::Apt::installIfNecessary --no-install-recommends "${packages[@]}"

  Log::displayInfo "install plugin manager"
  if command -v zinit &>/dev/null; then
    zinit self-update
    zinit update --all --parallel
  else
    NO_INPUT=1 NO_TUTORIAL=1 bash -c "$(
      curl \
        --fail --show-error --silent \
        --location https://raw.githubusercontent.com/zdharma-continuum/zinit/HEAD/scripts/install.sh
    )"
  fi
}

assertZshFunctionExists() {
  local functionName="$1"
  zsh -i -c "typeset -f '${functionName}' &>/dev/null" || {
    Log::displayError "Zsh function ${functionName} does not exist"
    return 1
  }
}

testInstall() {
  local -i failures=0
  Assert::commandExists zsh || ((++failures))
  Assert::commandExists "svn" || ((++failures))
  assertZshFunctionExists zinit || ((++failures))
  return "${failures}"
}

configure() {
  if [[ "${PREFERRED_SHELL}" = "ShellZsh" ]]; then
    if [[ "${USER_SHELL}" != "/usr/bin/zsh" ]]; then
      sudo usermod --shell /usr/bin/zsh "${USERNAME}"
      USER_SHELL="/usr/bin/zsh"
      Log::displayHelp "You have to log in/log out to make zsh by default"
    fi
    Log::displayHelp "Zsh is set as default shell, you can switch back to bash using 'chsh -s /usr/bin/bash'"
  fi
  # shellcheck disable=SC2154
  Conf::copyStructure \
    "${embed_dir_conf_dir}" \
    "${CONF_OVERRIDE_DIR}/$(scriptName)" \
    ".bash-dev-env"

  Conf::copyStructure \
    "${embed_dir_conf_dir}" \
    "${CONF_OVERRIDE_DIR}/$(scriptName)" \
    "home" \
    "${HOME}"

  # shellcheck disable=SC2154
  OVERWRITE_CONFIG_FILES=1 Install::file \
    "${embed_file_loadConfigFiles}" \
    "${HOME}/.bash-dev-env/loadConfigFiles"
}

declare -a confFiles=(
  "${HOME}/.bash-dev-env/interactive.d/zsh-syntax-complete-suggest.zsh"
  "${HOME}/.bash-dev-env/interactive.d/zsh-beep.zsh"
  "${HOME}/.bash-dev-env/interactive.d/zsh-history.zsh"
  "${HOME}/.bash-dev-env/interactive.d/zsh-ls-colors.zsh"
  "${HOME}/.bash-dev-env/interactive.d/zsh-ssh.zsh"
  "${HOME}/.bash-dev-env/interactive.d/zsh-z.zsh"
  "${HOME}/.bash-dev-env/themes.d/powerlevel10k.zsh"
  "${HOME}/.bash-dev-env/themes.d/pure.zsh"
  "${HOME}/.bash-dev-env/themes.d/starship.zsh"
  "${HOME}/.bash-dev-env/loadConfigFiles"
  "${HOME}/.zshrc"
  "${HOME}/.zprofile"
  "${HOME}/.p10k.zsh"
)
testConfigure() {
  local -i failures=0
  local file
  for file in "${confFiles[@]}"; do
    Assert::fileExists "${file}" || ((++failures))
  done
  Log::displayInfo "Try to load .zshrc"
  (zsh -i -c 'echo "Hello Zsh"' || exit 1) || {
    Log::displayError "something goes bad while loading ~/.zshrc"
    ((++failures))
  }

  return "${failures}"
}

local action=$1
shift || true
case ${action} in
  scriptName)
    scriptName "$@"
    ;;
  helpDescription)
    helpDescription "$@"
    ;;
  helpVariables)
    helpVariables "$@"
    ;;
  listVariables)
    listVariables "$@"
    ;;
  defaultVariables)
    defaultVariables "$@"
    ;;
  checkVariables)
    checkVariables "$@"
    ;;
  fortunes)
    fortunes "$@"
    ;;
  dependencies)
    dependencies "$@"
    ;;
  breakOnTestFailure)
    breakOnTestFailure "$@"
    ;;
  breakOnConfigFailure)
    breakOnConfigFailure "$@"
    ;;
  install)
    install "$@"
    ;;
  isInstallImplemented)
    isInstallImplemented "$@"
    ;;
  testInstall)
    testInstall "$@"
    ;;
  isTestInstallImplemented)
    isTestInstallImplemented "$@"
    ;;
  configure)
    configure "$@"
    ;;
  isConfigureImplemented)
    isConfigureImplemented "$@"
    ;;
  testConfigure)
    testConfigure "$@"
    ;;
  isTestConfigureImplemented)
    isTestConfigureImplemented "$@"
    ;;
  *)
    if Assert::functionExists defaultFacadeAction; then
      defaultFacadeAction "$1" "$@"
    else
      Log::displayError "invalid action requested: ${action}"
      exit 1
    fi
    ;;
esac
exit 0
}

facade_main_ShellZshsh "$@"
